
  EXPLORED Args.parser output 
 EXPLORED learningOn  true
 EXPLORED bidirectionality  true
 EXPLORED effect-filter  false
 EXPLORED specfile :: ./prudent_tests/hegel/Cobalt+/NLRRemove.spec
 EXPLORED goal Number :: 0
 EXPLORED Max path length :: 2
 EXPLORED Nested If :: 1typewhitespace var: fwstate
semicolon
typewhitespace var: srpair
semicolon
typewhitespace var: nlrecord
semicolon
typewhitespace var: user
semicolon
typewhitespace var: code
semicolon
stexcwhitespace var: device
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: int
whitespace colon
whitespace var: bool
semicolon
stexcwhitespace var: dsize
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: lmem
whitespace colon
whitespace lbrace
var: a
rbrace
whitespace colon
whitespace var: a
whitespace colon
whitespace var: bool
semicolon
stexcwhitespace var: lhd
whitespace colon
whitespace lbrace
var: a
rbrace
whitespace colon
whitespace var: a
semicolon
stexcwhitespace var: fst
whitespace colon
whitespace var: fwstate
whitespace colon
whitespace lbrace
var: srpair
rbrace
whitespace semicolon
stexcwhitespace var: snd
whitespace colon
whitespace var: fwstate
whitespace colon
whitespace lbrace
var: int
rbrace
semicolon
stexcwhitespace var: central
whitespace colon
whitespace lbrace
var: srpair
rbrace
whitespace colon
whitespace var: int
whitespace colon
whitespace var: bool
semicolon
stexcwhitespace var: cansend
whitespace colon
whitespace lbrace
var: srpair
rbrace
whitespace colon
whitespace var: int
whitespace colon
whitespace var: int
whitespace colon
whitespace var: bool
semicolon
stexcwhitespace var: is_central
whitespace colon
whitespace var: int
whitespace colon
whitespace var: bool
semicolon
stexcwhitespace var: nlmem
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
whitespace colon
whitespace var: string
whitespace colon
whitespace var: string
whitespace colon
whitespace var: bool
semicolon
stexcwhitespace var: ns
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
whitespace colon
whitespace var: string
whitespace colon
whitespace var: string
whitespace colon
whitespace var: nlrecord
semicolon
stexcwhitespace var: subscribed
whitespace colon
whitespace var: nlrecord
whitespace colon
whitespace var: bool
semicolon
stexcwhitespace var: nletter
whitespace colon
whitespace var: nlrecord
whitespace colon
whitespace var: string
semicolon
stexcwhitespace var: code
whitespace colon
whitespace var: nlrecord
whitespace colon
whitespace var: code
semicolon
stexcwhitespace var: articles
whitespace colon
whitespace var: nlrecord
whitespace colon
whitespace lbrace
var: string
rbrace
semicolon
stexcwhitespace var: email
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
whitespace colon
whitespace var: user
whitespace colon
whitespace var: bool
semicolon
stexcwhitespace var: promotions
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
whitespace colon
whitespace var: user
whitespace colon
whitespace var: bool
semicolon
var: add_device
whitespace colon
whitespace lparen
var: dtable
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace whitespace lparen
var: cstab
whitespace colon
whitespace lbrace
var: srpair
rbrace
rparen
whitespace arrow
whitespace whitespace lparen
var: d
whitespace colon
whitespace lcurly
var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace var: device
whitespace lparen
var: dtable
comma
whitespace var: v
rparen
whitespace equalopwhitespace falsercurly
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace var: fwstate
whitespace pipe
lambdalparen
var: s
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
dotwhitespace var: fst
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: cstab
whitespace conjwhitespace lparen
var: s
whitespace equalopwhitespace var: snd
whitespace lparen
var: v
rparen
whitespace implieswhitespace whitespace var: device
lparen
var: s
comma
whitespace var: d
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace var: dsize
lparen
var: s
rparen
whitespace equalopwhitespace var: dsize
lparen
var: dtable
rparen
whitespace pluswhitespace int: 1
rparen
whitespace rcurly
semicolon
var: diff_device
whitespace colon
whitespace lparen
var: sr
whitespace colon
whitespace lbrace
var: srpair
rbrace
rparen
whitespace arrow
whitespace lparen
var: dtable
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lparen
var: d
whitespace colon
whitespace lcurly
var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace truercurly
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace var: device
lparen
var: dtable
comma
whitespace var: v
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace notwhitespace lbrace
var: v
equalopvar: d
rbrace
whitespace rcurly
semicolon
var: add_connection
whitespace colon
whitespace lparen
var: sr
whitespace colon
whitespace lbrace
var: srpair
rbrace
rparen
whitespace arrow
whitespace lparen
var: dtable
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lparen
var: s
whitespace colon
whitespace lcurly
var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace var: device
lparen
var: dtable
comma
whitespace var: v
rparen
whitespace equalopwhitespace truercurly
rparen
whitespace arrow
whitespace lparen
var: r
whitespace colon
whitespace lcurly
var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace var: device
lparen
var: dtable
comma
whitespace var: v
rparen
whitespace equalopwhitespace truercurly
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace var: fwstate
whitespace pipe
whitespace lambdalparen
var: f
whitespace colon
whitespace lbrace
var: srpair
rbrace
rparen
dotwhitespace var: snd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: dtable
whitespace conjwhitespace lparen
var: f
whitespace equalopwhitespace var: fst
whitespace lparen
var: v
rparen
whitespace implieswhitespace var: cansend
lparen
var: f
comma
whitespace var: s
comma
whitespace var: r
rparen
whitespace equalopwhitespace truerparen
whitespace rcurly
semicolon
var: make_central
whitespace colon
whitespace lparen
var: sr
whitespace colon
whitespace lbrace
var: srpair
rbrace
rparen
whitespace arrow
whitespace lparen
var: dtable
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lparen
var: d
whitespace colon
whitespace lcurly
var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace var: device
lparen
var: dtable
comma
whitespace var: v
rparen
whitespace equalopwhitespace truercurly
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace var: fwstate
whitespace pipe
lambdalparen
var: f
whitespace colon
whitespace lbrace
var: srpair
rbrace
rparen
dotwhitespace var: snd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: dtable
whitespace conjwhitespace lparen
var: f
whitespace equalopwhitespace var: fst
whitespace lparen
var: v
rparen
whitespace implieswhitespace var: central
lparen
var: f
comma
whitespace var: d
rparen
whitespace equalopwhitespace truerparen
whitespace rcurly
semicolon
var: delete_device
whitespace colon
whitespace lparen
var: sr
whitespace colon
whitespace lbrace
var: srpair
rbrace
rparen
whitespace arrow
whitespace lparen
var: dtable
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lparen
var: d
whitespace colon
whitespace lcurly
var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace truercurly
rparen
whitespace arrow
whitespace lparen
var: y
whitespace colon
whitespace lcurly
var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace notwhitespace lbrace
var: v
whitespace equalopwhitespace var: d
rbrace
whitespace conjwhitespace var: device
lparen
var: dtable
comma
whitespace var: v
rparen
whitespace equalopwhitespace truewhitespace whitespace conjwhitespace var: central
lparen
var: sr
comma
whitespace var: v
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace whitespace var: device
lparen
var: dtable
comma
whitespace var: d
rparen
equalopwhitespace truercurly
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace var: fwstate
whitespace pipe
lambdalparen
var: f
whitespace colon
whitespace lbrace
var: srpair
rbrace
rparen
comma
whitespace lparen
var: s
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
dotwhitespace lparen
var: f
whitespace equalopwhitespace var: fst
whitespace lparen
var: v
rparen
whitespace conjwhitespace var: s
whitespace equalopwhitespace var: snd
whitespace lparen
var: v
rparen
rparen
whitespace implieswhitespace whitespace lparen
var: device
lparen
var: s
comma
whitespace var: d
rparen
whitespace equalopwhitespace falsewhitespace conjwhitespace var: central
lparen
var: f
comma
whitespace var: y
rparen
whitespace equalopwhitespace truewhitespace rparen
rcurly
semicolon
var: select
whitespace colon
whitespace lparen
var: db
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
rparen
whitespace arrow
whitespace lparen
var: n
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lparen
var: u
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace var: nlrecord
whitespace pipe
whitespace var: nlmem
lparen
var: db
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace var: nletter
lparen
var: v
rparen
whitespace equalopwhitespace var: n
whitespace conjwhitespace var: user
lparen
var: v
rparen
whitespace equalopwhitespace var: u
whitespace rcurly
semicolon
var: nlmem
whitespace colon
whitespace lparen
var: db
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
rparen
whitespace arrow
whitespace lparen
var: n
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lparen
var: u
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace var: bool
whitespace pipe
whitespace lparen
var: v
whitespace equalopwhitespace truewhitespace iffwhitespace var: nlmem
lparen
var: db
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace truerparen
whitespace conjwhitespace lparen
var: v
whitespace equalopwhitespace falsewhitespace iffwhitespace var: nlmem
lparen
var: db
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace falserparen
whitespace rcurly
semicolon
var: subscribe
whitespace colon
whitespace lparen
var: db
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
rparen
whitespace arrow
whitespace lparen
var: n
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lparen
var: u
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
whitespace pipe
whitespace var: nlmem
lparen
var: db
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace falsewhitespace conjwhitespace var: nlmem
lparen
var: v
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace var: subscribed
lparen
var: v
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace truewhitespace rcurly
semicolon
var: unsubscribe
whitespace colon
whitespace lparen
var: db
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
rparen
whitespace arrow
whitespace lparen
var: n
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lparen
var: u
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
whitespace pipe
whitespace var: nlmem
lparen
var: db
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace var: nlmem
lparen
var: v
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace var: subscribed
lparen
var: v
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace falsewhitespace rcurly
semicolon
var: confirm
whitespace colon
whitespace lparen
var: db
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
rparen
whitespace arrow
whitespace lparen
var: c
whitespace colon
whitespace var: code
rparen
whitespace arrow
whitespace lparen
var: n
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lparen
var: u
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
whitespace pipe
whitespace var: nlmem
lparen
var: db
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace lparen
lparen
var: c
whitespace equalopwhitespace var: Cs
whitespace implieswhitespace var: subscribed
lparen
var: v
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace truerparen
whitespace conjwhitespace lparen
var: c
whitespace equalopwhitespace var: Cu
whitespace implieswhitespace var: subscribed
lparen
var: v
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace falserparen
rparen
whitespace rcurly
semicolon
whitespace var: read
whitespace colon
whitespace lparen
var: db
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
rparen
whitespace arrow
whitespace lparen
var: n
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lparen
var: u
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace lbrace
var: string
rbrace
whitespace pipe
whitespace var: nlmem
lparen
var: db
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace var: subscribed
lparen
var: v
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace var: v
whitespace equalopwhitespace var: articles
lparen
var: v
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace rcurly
semicolon
whitespace var: remove
whitespace colon
whitespace lparen
var: db
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
rparen
whitespace arrow
whitespace lparen
var: n
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lparen
var: u
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
whitespace pipe
whitespace var: nlmem
lparen
var: v
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace falsercurly
semicolon
var: goal
whitespace colon
whitespace lparen
var: n
whitespace colon
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: nl
whitespace pipe
whitespace truercurly
rparen
whitespace arrow
whitespace lparen
var: u
whitespace colon
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: user
whitespace pipe
whitespace truercurly
rparen
whitespace arrow
whitespace whitespace lparen
var: D
whitespace colon
whitespace lcurly
var: v
colon
whitespace lbrace
var: nlrecord
rbrace
whitespace pipe
whitespace var: mem
whitespace lparen
var: v
whitespace comma
whitespace var: n
whitespace comma
whitespace var: u
rparen
whitespace equalopwhitespace truercurly
rparen
whitespace arrow
whitespace whitespace whitespace lcurly
var: v
whitespace colon
whitespace lparen

  EXPLORED Args.parser output 
 EXPLORED learningOn  true
 EXPLORED bidirectionality  true
 EXPLORED effect-filter  false
 EXPLORED specfile :: ./prudent_tests/hegel/Cobalt+/FWInvertDel.spec
 EXPLORED goal Number :: 0
 EXPLORED Max path length :: 2
 EXPLORED Nested If :: 1typewhitespace var: fwstate
semicolon
typewhitespace var: srpair
semicolon
typewhitespace var: nlrecord
semicolon
typewhitespace var: user
semicolon
typewhitespace var: code
semicolon
stexcwhitespace var: device
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: int
whitespace colon
whitespace var: bool
semicolon
stexcwhitespace var: dsize
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: lmem
whitespace colon
whitespace lbrace
var: a
rbrace
whitespace colon
whitespace var: a
whitespace colon
whitespace var: bool
semicolon
stexcwhitespace var: lhd
whitespace colon
whitespace lbrace
var: a
rbrace
whitespace colon
whitespace var: a
semicolon
stexcwhitespace var: fst
whitespace colon
whitespace var: fwstate
whitespace colon
whitespace lbrace
var: srpair
rbrace
whitespace semicolon
stexcwhitespace var: snd
whitespace colon
whitespace var: fwstate
whitespace colon
whitespace lbrace
var: int
rbrace
semicolon
stexcwhitespace var: central
whitespace colon
whitespace lbrace
var: srpair
rbrace
whitespace colon
whitespace var: int
whitespace colon
whitespace var: bool
semicolon
stexcwhitespace var: cansend
whitespace colon
whitespace lbrace
var: srpair
rbrace
whitespace colon
whitespace var: int
whitespace colon
whitespace var: int
whitespace colon
whitespace var: bool
semicolon
stexcwhitespace var: is_central
whitespace colon
whitespace var: int
whitespace colon
whitespace var: bool
semicolon
stexcwhitespace var: nlmem
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
whitespace colon
whitespace var: string
whitespace colon
whitespace var: string
whitespace colon
whitespace var: bool
semicolon
stexcwhitespace var: ns
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
whitespace colon
whitespace var: string
whitespace colon
whitespace var: string
whitespace colon
whitespace var: nlrecord
semicolon
stexcwhitespace var: subscribed
whitespace colon
whitespace var: nlrecord
whitespace colon
whitespace var: bool
semicolon
stexcwhitespace var: nletter
whitespace colon
whitespace var: nlrecord
whitespace colon
whitespace var: string
semicolon
stexcwhitespace var: code
whitespace colon
whitespace var: nlrecord
whitespace colon
whitespace var: code
semicolon
stexcwhitespace var: articles
whitespace colon
whitespace var: nlrecord
whitespace colon
whitespace lbrace
var: string
rbrace
semicolon
stexcwhitespace var: email
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
whitespace colon
whitespace var: user
whitespace colon
whitespace var: bool
semicolon
stexcwhitespace var: promotions
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
whitespace colon
whitespace var: user
whitespace colon
whitespace var: bool
semicolon
var: add_device
whitespace colon
whitespace lparen
var: dtable
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace whitespace lparen
var: cstab
whitespace colon
whitespace lbrace
var: srpair
rbrace
rparen
whitespace arrow
whitespace whitespace lparen
var: d
whitespace colon
whitespace lcurly
var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace var: device
whitespace lparen
var: dtable
comma
whitespace var: v
rparen
whitespace equalopwhitespace falsercurly
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace var: fwstate
whitespace pipe
lambdalparen
var: s
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
dotwhitespace var: fst
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: cstab
whitespace conjwhitespace lparen
var: s
whitespace equalopwhitespace var: snd
whitespace lparen
var: v
rparen
whitespace implieswhitespace whitespace var: device
lparen
var: s
comma
whitespace var: d
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace var: dsize
lparen
var: s
rparen
whitespace equalopwhitespace var: dsize
lparen
var: dtable
rparen
whitespace pluswhitespace int: 1
rparen
whitespace rcurly
semicolon
var: diff_device
whitespace colon
whitespace lparen
var: sr
whitespace colon
whitespace lbrace
var: srpair
rbrace
rparen
whitespace arrow
whitespace lparen
var: dtable
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lparen
var: d
whitespace colon
whitespace lcurly
var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace truercurly
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace var: device
lparen
var: dtable
comma
whitespace var: v
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace notwhitespace lbrace
var: v
equalopvar: d
rbrace
whitespace rcurly
semicolon
var: add_connection
whitespace colon
whitespace lparen
var: sr
whitespace colon
whitespace lbrace
var: srpair
rbrace
rparen
whitespace arrow
whitespace lparen
var: dtable
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lparen
var: s
whitespace colon
whitespace lcurly
var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace var: device
lparen
var: dtable
comma
whitespace var: v
rparen
whitespace equalopwhitespace truercurly
rparen
whitespace arrow
whitespace lparen
var: r
whitespace colon
whitespace lcurly
var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace var: device
lparen
var: dtable
comma
whitespace var: v
rparen
whitespace equalopwhitespace truercurly
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace var: fwstate
whitespace pipe
whitespace lambdalparen
var: f
whitespace colon
whitespace lbrace
var: srpair
rbrace
rparen
dotwhitespace var: snd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: dtable
whitespace conjwhitespace lparen
var: f
whitespace equalopwhitespace var: fst
whitespace lparen
var: v
rparen
whitespace implieswhitespace var: cansend
lparen
var: f
comma
whitespace var: s
comma
whitespace var: r
rparen
whitespace equalopwhitespace truerparen
whitespace rcurly
semicolon
var: make_central
whitespace colon
whitespace lparen
var: sr
whitespace colon
whitespace lbrace
var: srpair
rbrace
rparen
whitespace arrow
whitespace lparen
var: dtable
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lparen
var: d
whitespace colon
whitespace lcurly
var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace var: device
lparen
var: dtable
comma
whitespace var: v
rparen
whitespace equalopwhitespace truercurly
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace var: fwstate
whitespace pipe
lambdalparen
var: f
whitespace colon
whitespace lbrace
var: srpair
rbrace
rparen
dotwhitespace var: snd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: dtable
whitespace conjwhitespace lparen
var: f
whitespace equalopwhitespace var: fst
whitespace lparen
var: v
rparen
whitespace implieswhitespace var: central
lparen
var: f
comma
whitespace var: d
rparen
whitespace equalopwhitespace truerparen
whitespace rcurly
semicolon
var: delete_device
whitespace colon
whitespace lparen
var: sr
whitespace colon
whitespace lbrace
var: srpair
rbrace
rparen
whitespace arrow
whitespace lparen
var: dtable
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lparen
var: d
whitespace colon
whitespace lcurly
var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace truercurly
rparen
whitespace arrow
whitespace lparen
var: y
whitespace colon
whitespace lcurly
var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace notwhitespace lbrace
var: v
whitespace equalopwhitespace var: d
rbrace
whitespace conjwhitespace var: device
lparen
var: dtable
comma
whitespace var: v
rparen
whitespace equalopwhitespace truewhitespace whitespace conjwhitespace var: central
lparen
var: sr
comma
whitespace var: v
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace whitespace var: device
lparen
var: dtable
comma
whitespace var: d
rparen
equalopwhitespace truercurly
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace var: fwstate
whitespace pipe
lambdalparen
var: f
whitespace colon
whitespace lbrace
var: srpair
rbrace
rparen
comma
whitespace lparen
var: s
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
dotwhitespace lparen
var: f
whitespace equalopwhitespace var: fst
whitespace lparen
var: v
rparen
whitespace conjwhitespace var: s
whitespace equalopwhitespace var: snd
whitespace lparen
var: v
rparen
rparen
whitespace implieswhitespace whitespace lparen
var: device
lparen
var: s
comma
whitespace var: d
rparen
whitespace equalopwhitespace falsewhitespace conjwhitespace var: central
lparen
var: f
comma
whitespace var: y
rparen
whitespace equalopwhitespace truewhitespace rparen
rcurly
semicolon
var: select
whitespace colon
whitespace lparen
var: db
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
rparen
whitespace arrow
whitespace lparen
var: n
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lparen
var: u
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace var: nlrecord
whitespace pipe
whitespace var: nlmem
lparen
var: db
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace var: nletter
lparen
var: v
rparen
whitespace equalopwhitespace var: n
whitespace conjwhitespace var: user
lparen
var: v
rparen
whitespace equalopwhitespace var: u
whitespace rcurly
semicolon
var: nlmem
whitespace colon
whitespace lparen
var: db
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
rparen
whitespace arrow
whitespace lparen
var: n
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lparen
var: u
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace var: bool
whitespace pipe
whitespace lparen
var: v
whitespace equalopwhitespace truewhitespace iffwhitespace var: nlmem
lparen
var: db
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace truerparen
whitespace conjwhitespace lparen
var: v
whitespace equalopwhitespace falsewhitespace iffwhitespace var: nlmem
lparen
var: db
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace falserparen
whitespace rcurly
semicolon
var: subscribe
whitespace colon
whitespace lparen
var: db
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
rparen
whitespace arrow
whitespace lparen
var: n
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lparen
var: u
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
whitespace pipe
whitespace var: nlmem
lparen
var: db
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace falsewhitespace conjwhitespace var: nlmem
lparen
var: v
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace var: subscribed
lparen
var: v
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace truewhitespace rcurly
semicolon
var: unsubscribe
whitespace colon
whitespace lparen
var: db
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
rparen
whitespace arrow
whitespace lparen
var: n
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lparen
var: u
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
whitespace pipe
whitespace var: nlmem
lparen
var: db
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace var: nlmem
lparen
var: v
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace var: subscribed
lparen
var: v
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace falsewhitespace rcurly
semicolon
var: confirm
whitespace colon
whitespace lparen
var: db
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
rparen
whitespace arrow
whitespace lparen
var: c
whitespace colon
whitespace var: code
rparen
whitespace arrow
whitespace lparen
var: n
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lparen
var: u
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
whitespace pipe
whitespace var: nlmem
lparen
var: db
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace lparen
lparen
var: c
whitespace equalopwhitespace var: Cs
whitespace implieswhitespace var: subscribed
lparen
var: v
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace truerparen
whitespace conjwhitespace lparen
var: c
whitespace equalopwhitespace var: Cu
whitespace implieswhitespace var: subscribed
lparen
var: v
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace falserparen
rparen
whitespace rcurly
semicolon
whitespace var: read
whitespace colon
whitespace lparen
var: db
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
rparen
whitespace arrow
whitespace lparen
var: n
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lparen
var: u
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace lbrace
var: string
rbrace
whitespace pipe
whitespace var: nlmem
lparen
var: db
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace var: subscribed
lparen
var: v
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace var: v
whitespace equalopwhitespace var: articles
lparen
var: v
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace rcurly
semicolon
whitespace var: remove
whitespace colon
whitespace lparen
var: db
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
rparen
whitespace arrow
whitespace lparen
var: n
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lparen
var: u
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
whitespace pipe
whitespace var: nlmem
lparen
var: v
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace falsercurly
semicolon
var: goal
colon
whitespace whitespace lparen
var: sr
whitespace colon
whitespace lbrace
var: srpair
rbrace
rparen
whitespace arrow
whitespace whitespace lparen
var: dtable
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace whitespace lcurly
var: v
whitespace colon
whitespace lparen

  EXPLORED Args.parser output 
 EXPLORED learningOn  true
 EXPLORED bidirectionality  true
 EXPLORED effect-filter  false
 EXPLORED specfile :: ./prudent_tests/hegel/Cobalt+/FWInsert.spec
 EXPLORED goal Number :: 0
 EXPLORED Max path length :: 2
 EXPLORED Nested If :: 1typewhitespace var: fwstate
semicolon
typewhitespace var: srpair
semicolon
typewhitespace var: nlrecord
semicolon
typewhitespace var: user
semicolon
typewhitespace var: code
semicolon
stexcwhitespace var: device
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: int
whitespace colon
whitespace var: bool
semicolon
stexcwhitespace var: dsize
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: lmem
whitespace colon
whitespace lbrace
var: a
rbrace
whitespace colon
whitespace var: a
whitespace colon
whitespace var: bool
semicolon
stexcwhitespace var: lhd
whitespace colon
whitespace lbrace
var: a
rbrace
whitespace colon
whitespace var: a
semicolon
stexcwhitespace var: fst
whitespace colon
whitespace var: fwstate
whitespace colon
whitespace lbrace
var: srpair
rbrace
whitespace semicolon
stexcwhitespace var: snd
whitespace colon
whitespace var: fwstate
whitespace colon
whitespace lbrace
var: int
rbrace
semicolon
stexcwhitespace var: central
whitespace colon
whitespace lbrace
var: srpair
rbrace
whitespace colon
whitespace var: int
whitespace colon
whitespace var: bool
semicolon
stexcwhitespace var: cansend
whitespace colon
whitespace lbrace
var: srpair
rbrace
whitespace colon
whitespace var: int
whitespace colon
whitespace var: int
whitespace colon
whitespace var: bool
semicolon
stexcwhitespace var: is_central
whitespace colon
whitespace var: int
whitespace colon
whitespace var: bool
semicolon
stexcwhitespace var: nlmem
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
whitespace colon
whitespace var: string
whitespace colon
whitespace var: string
whitespace colon
whitespace var: bool
semicolon
stexcwhitespace var: ns
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
whitespace colon
whitespace var: string
whitespace colon
whitespace var: string
whitespace colon
whitespace var: nlrecord
semicolon
stexcwhitespace var: subscribed
whitespace colon
whitespace var: nlrecord
whitespace colon
whitespace var: bool
semicolon
stexcwhitespace var: nletter
whitespace colon
whitespace var: nlrecord
whitespace colon
whitespace var: string
semicolon
stexcwhitespace var: code
whitespace colon
whitespace var: nlrecord
whitespace colon
whitespace var: code
semicolon
stexcwhitespace var: articles
whitespace colon
whitespace var: nlrecord
whitespace colon
whitespace lbrace
var: string
rbrace
semicolon
stexcwhitespace var: email
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
whitespace colon
whitespace var: user
whitespace colon
whitespace var: bool
semicolon
stexcwhitespace var: promotions
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
whitespace colon
whitespace var: user
whitespace colon
whitespace var: bool
semicolon
var: add_device
whitespace colon
whitespace lparen
var: dtable
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace whitespace lparen
var: cstab
whitespace colon
whitespace lbrace
var: srpair
rbrace
rparen
whitespace arrow
whitespace whitespace lparen
var: d
whitespace colon
whitespace lcurly
var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace var: device
whitespace lparen
var: dtable
comma
whitespace var: v
rparen
whitespace equalopwhitespace falsercurly
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace var: fwstate
whitespace pipe
lambdalparen
var: s
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
dotwhitespace var: fst
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: cstab
whitespace conjwhitespace lparen
var: s
whitespace equalopwhitespace var: snd
whitespace lparen
var: v
rparen
whitespace implieswhitespace whitespace var: device
lparen
var: s
comma
whitespace var: d
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace var: dsize
lparen
var: s
rparen
whitespace equalopwhitespace var: dsize
lparen
var: dtable
rparen
whitespace pluswhitespace int: 1
rparen
whitespace rcurly
semicolon
var: diff_device
whitespace colon
whitespace lparen
var: sr
whitespace colon
whitespace lbrace
var: srpair
rbrace
rparen
whitespace arrow
whitespace lparen
var: dtable
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lparen
var: d
whitespace colon
whitespace lcurly
var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace truercurly
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace var: device
lparen
var: dtable
comma
whitespace var: v
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace notwhitespace lbrace
var: v
equalopvar: d
rbrace
whitespace rcurly
semicolon
var: add_connection
whitespace colon
whitespace lparen
var: sr
whitespace colon
whitespace lbrace
var: srpair
rbrace
rparen
whitespace arrow
whitespace lparen
var: dtable
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lparen
var: s
whitespace colon
whitespace lcurly
var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace var: device
lparen
var: dtable
comma
whitespace var: v
rparen
whitespace equalopwhitespace truercurly
rparen
whitespace arrow
whitespace lparen
var: r
whitespace colon
whitespace lcurly
var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace var: device
lparen
var: dtable
comma
whitespace var: v
rparen
whitespace equalopwhitespace truercurly
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace var: fwstate
whitespace pipe
whitespace lambdalparen
var: f
whitespace colon
whitespace lbrace
var: srpair
rbrace
rparen
dotwhitespace var: snd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: dtable
whitespace conjwhitespace lparen
var: f
whitespace equalopwhitespace var: fst
whitespace lparen
var: v
rparen
whitespace implieswhitespace var: cansend
lparen
var: f
comma
whitespace var: s
comma
whitespace var: r
rparen
whitespace equalopwhitespace truerparen
whitespace rcurly
semicolon
var: make_central
whitespace colon
whitespace lparen
var: sr
whitespace colon
whitespace lbrace
var: srpair
rbrace
rparen
whitespace arrow
whitespace lparen
var: dtable
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lparen
var: d
whitespace colon
whitespace lcurly
var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace var: device
lparen
var: dtable
comma
whitespace var: v
rparen
whitespace equalopwhitespace truercurly
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace var: fwstate
whitespace pipe
lambdalparen
var: f
whitespace colon
whitespace lbrace
var: srpair
rbrace
rparen
dotwhitespace var: snd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: dtable
whitespace conjwhitespace lparen
var: f
whitespace equalopwhitespace var: fst
whitespace lparen
var: v
rparen
whitespace implieswhitespace var: central
lparen
var: f
comma
whitespace var: d
rparen
whitespace equalopwhitespace truerparen
whitespace rcurly
semicolon
var: delete_device
whitespace colon
whitespace lparen
var: sr
whitespace colon
whitespace lbrace
var: srpair
rbrace
rparen
whitespace arrow
whitespace lparen
var: dtable
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lparen
var: d
whitespace colon
whitespace lcurly
var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace truercurly
rparen
whitespace arrow
whitespace lparen
var: y
whitespace colon
whitespace lcurly
var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace notwhitespace lbrace
var: v
whitespace equalopwhitespace var: d
rbrace
whitespace conjwhitespace var: device
lparen
var: dtable
comma
whitespace var: v
rparen
whitespace equalopwhitespace truewhitespace whitespace conjwhitespace var: central
lparen
var: sr
comma
whitespace var: v
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace whitespace var: device
lparen
var: dtable
comma
whitespace var: d
rparen
equalopwhitespace truercurly
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace var: fwstate
whitespace pipe
lambdalparen
var: f
whitespace colon
whitespace lbrace
var: srpair
rbrace
rparen
comma
whitespace lparen
var: s
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
dotwhitespace lparen
var: f
whitespace equalopwhitespace var: fst
whitespace lparen
var: v
rparen
whitespace conjwhitespace var: s
whitespace equalopwhitespace var: snd
whitespace lparen
var: v
rparen
rparen
whitespace implieswhitespace whitespace lparen
var: device
lparen
var: s
comma
whitespace var: d
rparen
whitespace equalopwhitespace falsewhitespace conjwhitespace var: central
lparen
var: f
comma
whitespace var: y
rparen
whitespace equalopwhitespace truewhitespace rparen
rcurly
semicolon
var: select
whitespace colon
whitespace lparen
var: db
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
rparen
whitespace arrow
whitespace lparen
var: n
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lparen
var: u
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace var: nlrecord
whitespace pipe
whitespace var: nlmem
lparen
var: db
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace var: nletter
lparen
var: v
rparen
whitespace equalopwhitespace var: n
whitespace conjwhitespace var: user
lparen
var: v
rparen
whitespace equalopwhitespace var: u
whitespace rcurly
semicolon
var: nlmem
whitespace colon
whitespace lparen
var: db
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
rparen
whitespace arrow
whitespace lparen
var: n
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lparen
var: u
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace var: bool
whitespace pipe
whitespace lparen
var: v
whitespace equalopwhitespace truewhitespace iffwhitespace var: nlmem
lparen
var: db
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace truerparen
whitespace conjwhitespace lparen
var: v
whitespace equalopwhitespace falsewhitespace iffwhitespace var: nlmem
lparen
var: db
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace falserparen
whitespace rcurly
semicolon
var: subscribe
whitespace colon
whitespace lparen
var: db
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
rparen
whitespace arrow
whitespace lparen
var: n
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lparen
var: u
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
whitespace pipe
whitespace var: nlmem
lparen
var: db
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace falsewhitespace conjwhitespace var: nlmem
lparen
var: v
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace var: subscribed
lparen
var: v
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace truewhitespace rcurly
semicolon
var: unsubscribe
whitespace colon
whitespace lparen
var: db
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
rparen
whitespace arrow
whitespace lparen
var: n
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lparen
var: u
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
whitespace pipe
whitespace var: nlmem
lparen
var: db
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace var: nlmem
lparen
var: v
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace var: subscribed
lparen
var: v
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace falsewhitespace rcurly
semicolon
var: confirm
whitespace colon
whitespace lparen
var: db
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
rparen
whitespace arrow
whitespace lparen
var: c
whitespace colon
whitespace var: code
rparen
whitespace arrow
whitespace lparen
var: n
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lparen
var: u
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
whitespace pipe
whitespace var: nlmem
lparen
var: db
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace lparen
lparen
var: c
whitespace equalopwhitespace var: Cs
whitespace implieswhitespace var: subscribed
lparen
var: v
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace truerparen
whitespace conjwhitespace lparen
var: c
whitespace equalopwhitespace var: Cu
whitespace implieswhitespace var: subscribed
lparen
var: v
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace falserparen
rparen
whitespace rcurly
semicolon
whitespace var: read
whitespace colon
whitespace lparen
var: db
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
rparen
whitespace arrow
whitespace lparen
var: n
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lparen
var: u
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace lbrace
var: string
rbrace
whitespace pipe
whitespace var: nlmem
lparen
var: db
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace var: subscribed
lparen
var: v
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace var: v
whitespace equalopwhitespace var: articles
lparen
var: v
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace rcurly
semicolon
whitespace var: remove
whitespace colon
whitespace lparen
var: db
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
rparen
whitespace arrow
whitespace lparen
var: n
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lparen
var: u
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
whitespace pipe
whitespace var: nlmem
lparen
var: v
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace falsercurly
semicolon
var: goal
whitespace colon
whitespace lparen
var: sr
whitespace colon
whitespace lbrace
var: srpair
rbrace
rparen
whitespace arrow
whitespace whitespace lparen
var: dtable
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace whitespace lparen
var: d
whitespace colon
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace truercurly
rparen
whitespace arrow
whitespace whitespace lparen
var: x
whitespace colon
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace truercurly
rparen
whitespace arrow
whitespace whitespace lcurly
var: v
whitespace colon
whitespace lparen

  EXPLORED Args.parser output 
 EXPLORED learningOn  true
 EXPLORED bidirectionality  true
 EXPLORED effect-filter  false
 EXPLORED specfile :: ./prudent_tests/hegel/Cobalt+/FWInvert.spec
 EXPLORED goal Number :: 0
 EXPLORED Max path length :: 2
 EXPLORED Nested If :: 1typewhitespace var: fwstate
semicolon
typewhitespace var: srpair
semicolon
typewhitespace var: nlrecord
semicolon
typewhitespace var: user
semicolon
typewhitespace var: code
semicolon
stexcwhitespace var: device
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: int
whitespace colon
whitespace var: bool
semicolon
stexcwhitespace var: dsize
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: lmem
whitespace colon
whitespace lbrace
var: a
rbrace
whitespace colon
whitespace var: a
whitespace colon
whitespace var: bool
semicolon
stexcwhitespace var: lhd
whitespace colon
whitespace lbrace
var: a
rbrace
whitespace colon
whitespace var: a
semicolon
stexcwhitespace var: fst
whitespace colon
whitespace var: fwstate
whitespace colon
whitespace lbrace
var: srpair
rbrace
whitespace semicolon
stexcwhitespace var: snd
whitespace colon
whitespace var: fwstate
whitespace colon
whitespace lbrace
var: int
rbrace
semicolon
stexcwhitespace var: central
whitespace colon
whitespace lbrace
var: srpair
rbrace
whitespace colon
whitespace var: int
whitespace colon
whitespace var: bool
semicolon
stexcwhitespace var: cansend
whitespace colon
whitespace lbrace
var: srpair
rbrace
whitespace colon
whitespace var: int
whitespace colon
whitespace var: int
whitespace colon
whitespace var: bool
semicolon
stexcwhitespace var: is_central
whitespace colon
whitespace var: int
whitespace colon
whitespace var: bool
semicolon
stexcwhitespace var: nlmem
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
whitespace colon
whitespace var: string
whitespace colon
whitespace var: string
whitespace colon
whitespace var: bool
semicolon
stexcwhitespace var: ns
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
whitespace colon
whitespace var: string
whitespace colon
whitespace var: string
whitespace colon
whitespace var: nlrecord
semicolon
stexcwhitespace var: subscribed
whitespace colon
whitespace var: nlrecord
whitespace colon
whitespace var: bool
semicolon
stexcwhitespace var: nletter
whitespace colon
whitespace var: nlrecord
whitespace colon
whitespace var: string
semicolon
stexcwhitespace var: code
whitespace colon
whitespace var: nlrecord
whitespace colon
whitespace var: code
semicolon
stexcwhitespace var: articles
whitespace colon
whitespace var: nlrecord
whitespace colon
whitespace lbrace
var: string
rbrace
semicolon
stexcwhitespace var: email
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
whitespace colon
whitespace var: user
whitespace colon
whitespace var: bool
semicolon
stexcwhitespace var: promotions
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
whitespace colon
whitespace var: user
whitespace colon
whitespace var: bool
semicolon
var: add_device
whitespace colon
whitespace lparen
var: dtable
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace whitespace lparen
var: cstab
whitespace colon
whitespace lbrace
var: srpair
rbrace
rparen
whitespace arrow
whitespace whitespace lparen
var: d
whitespace colon
whitespace lcurly
var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace var: device
whitespace lparen
var: dtable
comma
whitespace var: v
rparen
whitespace equalopwhitespace falsercurly
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace var: fwstate
whitespace pipe
lambdalparen
var: s
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
dotwhitespace var: fst
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: cstab
whitespace conjwhitespace lparen
var: s
whitespace equalopwhitespace var: snd
whitespace lparen
var: v
rparen
whitespace implieswhitespace whitespace var: device
lparen
var: s
comma
whitespace var: d
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace var: dsize
lparen
var: s
rparen
whitespace equalopwhitespace var: dsize
lparen
var: dtable
rparen
whitespace pluswhitespace int: 1
rparen
whitespace rcurly
semicolon
var: diff_device
whitespace colon
whitespace lparen
var: sr
whitespace colon
whitespace lbrace
var: srpair
rbrace
rparen
whitespace arrow
whitespace lparen
var: dtable
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lparen
var: d
whitespace colon
whitespace lcurly
var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace truercurly
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace var: device
lparen
var: dtable
comma
whitespace var: v
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace notwhitespace lbrace
var: v
equalopvar: d
rbrace
whitespace rcurly
semicolon
var: add_connection
whitespace colon
whitespace lparen
var: sr
whitespace colon
whitespace lbrace
var: srpair
rbrace
rparen
whitespace arrow
whitespace lparen
var: dtable
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lparen
var: s
whitespace colon
whitespace lcurly
var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace var: device
lparen
var: dtable
comma
whitespace var: v
rparen
whitespace equalopwhitespace truercurly
rparen
whitespace arrow
whitespace lparen
var: r
whitespace colon
whitespace lcurly
var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace var: device
lparen
var: dtable
comma
whitespace var: v
rparen
whitespace equalopwhitespace truercurly
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace var: fwstate
whitespace pipe
whitespace lambdalparen
var: f
whitespace colon
whitespace lbrace
var: srpair
rbrace
rparen
dotwhitespace var: snd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: dtable
whitespace conjwhitespace lparen
var: f
whitespace equalopwhitespace var: fst
whitespace lparen
var: v
rparen
whitespace implieswhitespace var: cansend
lparen
var: f
comma
whitespace var: s
comma
whitespace var: r
rparen
whitespace equalopwhitespace truerparen
whitespace rcurly
semicolon
var: make_central
whitespace colon
whitespace lparen
var: sr
whitespace colon
whitespace lbrace
var: srpair
rbrace
rparen
whitespace arrow
whitespace lparen
var: dtable
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lparen
var: d
whitespace colon
whitespace lcurly
var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace var: device
lparen
var: dtable
comma
whitespace var: v
rparen
whitespace equalopwhitespace truercurly
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace var: fwstate
whitespace pipe
lambdalparen
var: f
whitespace colon
whitespace lbrace
var: srpair
rbrace
rparen
dotwhitespace var: snd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: dtable
whitespace conjwhitespace lparen
var: f
whitespace equalopwhitespace var: fst
whitespace lparen
var: v
rparen
whitespace implieswhitespace var: central
lparen
var: f
comma
whitespace var: d
rparen
whitespace equalopwhitespace truerparen
whitespace rcurly
semicolon
var: delete_device
whitespace colon
whitespace lparen
var: sr
whitespace colon
whitespace lbrace
var: srpair
rbrace
rparen
whitespace arrow
whitespace lparen
var: dtable
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lparen
var: d
whitespace colon
whitespace lcurly
var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace truercurly
rparen
whitespace arrow
whitespace lparen
var: y
whitespace colon
whitespace lcurly
var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace notwhitespace lbrace
var: v
whitespace equalopwhitespace var: d
rbrace
whitespace conjwhitespace var: device
lparen
var: dtable
comma
whitespace var: v
rparen
whitespace equalopwhitespace truewhitespace whitespace conjwhitespace var: central
lparen
var: sr
comma
whitespace var: v
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace whitespace var: device
lparen
var: dtable
comma
whitespace var: d
rparen
equalopwhitespace truercurly
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace var: fwstate
whitespace pipe
lambdalparen
var: f
whitespace colon
whitespace lbrace
var: srpair
rbrace
rparen
comma
whitespace lparen
var: s
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
dotwhitespace lparen
var: f
whitespace equalopwhitespace var: fst
whitespace lparen
var: v
rparen
whitespace conjwhitespace var: s
whitespace equalopwhitespace var: snd
whitespace lparen
var: v
rparen
rparen
whitespace implieswhitespace whitespace lparen
var: device
lparen
var: s
comma
whitespace var: d
rparen
whitespace equalopwhitespace falsewhitespace conjwhitespace var: central
lparen
var: f
comma
whitespace var: y
rparen
whitespace equalopwhitespace truewhitespace rparen
rcurly
semicolon
var: select
whitespace colon
whitespace lparen
var: db
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
rparen
whitespace arrow
whitespace lparen
var: n
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lparen
var: u
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace var: nlrecord
whitespace pipe
whitespace var: nlmem
lparen
var: db
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace var: nletter
lparen
var: v
rparen
whitespace equalopwhitespace var: n
whitespace conjwhitespace var: user
lparen
var: v
rparen
whitespace equalopwhitespace var: u
whitespace rcurly
semicolon
var: nlmem
whitespace colon
whitespace lparen
var: db
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
rparen
whitespace arrow
whitespace lparen
var: n
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lparen
var: u
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace var: bool
whitespace pipe
whitespace lparen
var: v
whitespace equalopwhitespace truewhitespace iffwhitespace var: nlmem
lparen
var: db
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace truerparen
whitespace conjwhitespace lparen
var: v
whitespace equalopwhitespace falsewhitespace iffwhitespace var: nlmem
lparen
var: db
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace falserparen
whitespace rcurly
semicolon
var: subscribe
whitespace colon
whitespace lparen
var: db
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
rparen
whitespace arrow
whitespace lparen
var: n
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lparen
var: u
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
whitespace pipe
whitespace var: nlmem
lparen
var: db
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace falsewhitespace conjwhitespace var: nlmem
lparen
var: v
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace var: subscribed
lparen
var: v
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace truewhitespace rcurly
semicolon
var: unsubscribe
whitespace colon
whitespace lparen
var: db
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
rparen
whitespace arrow
whitespace lparen
var: n
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lparen
var: u
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
whitespace pipe
whitespace var: nlmem
lparen
var: db
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace var: nlmem
lparen
var: v
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace var: subscribed
lparen
var: v
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace falsewhitespace rcurly
semicolon
var: confirm
whitespace colon
whitespace lparen
var: db
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
rparen
whitespace arrow
whitespace lparen
var: c
whitespace colon
whitespace var: code
rparen
whitespace arrow
whitespace lparen
var: n
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lparen
var: u
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
whitespace pipe
whitespace var: nlmem
lparen
var: db
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace lparen
lparen
var: c
whitespace equalopwhitespace var: Cs
whitespace implieswhitespace var: subscribed
lparen
var: v
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace truerparen
whitespace conjwhitespace lparen
var: c
whitespace equalopwhitespace var: Cu
whitespace implieswhitespace var: subscribed
lparen
var: v
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace falserparen
rparen
whitespace rcurly
semicolon
whitespace var: read
whitespace colon
whitespace lparen
var: db
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
rparen
whitespace arrow
whitespace lparen
var: n
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lparen
var: u
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace lbrace
var: string
rbrace
whitespace pipe
whitespace var: nlmem
lparen
var: db
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace var: subscribed
lparen
var: v
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace var: v
whitespace equalopwhitespace var: articles
lparen
var: v
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace rcurly
semicolon
whitespace var: remove
whitespace colon
whitespace lparen
var: db
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
rparen
whitespace arrow
whitespace lparen
var: n
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lparen
var: u
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
whitespace pipe
whitespace var: nlmem
lparen
var: v
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace falsercurly
semicolon
var: goal
colon
whitespace whitespace lparen
var: sr
whitespace colon
whitespace lbrace
var: srpair
rbrace
rparen
whitespace arrow
whitespace whitespace lparen
var: dtable
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace whitespace lcurly
var: v
whitespace colon
whitespace lparen

  EXPLORED Args.parser output 
 EXPLORED learningOn  true
 EXPLORED bidirectionality  true
 EXPLORED effect-filter  false
 EXPLORED specfile :: ./prudent_tests/hegel/Cobalt+/NLInsert.spec
 EXPLORED goal Number :: 0
 EXPLORED Max path length :: 2
 EXPLORED Nested If :: 1typewhitespace var: fwstate
semicolon
typewhitespace var: srpair
semicolon
typewhitespace var: nlrecord
semicolon
typewhitespace var: user
semicolon
typewhitespace var: code
semicolon
stexcwhitespace var: device
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: int
whitespace colon
whitespace var: bool
semicolon
stexcwhitespace var: dsize
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: lmem
whitespace colon
whitespace lbrace
var: a
rbrace
whitespace colon
whitespace var: a
whitespace colon
whitespace var: bool
semicolon
stexcwhitespace var: lhd
whitespace colon
whitespace lbrace
var: a
rbrace
whitespace colon
whitespace var: a
semicolon
stexcwhitespace var: fst
whitespace colon
whitespace var: fwstate
whitespace colon
whitespace lbrace
var: srpair
rbrace
whitespace semicolon
stexcwhitespace var: snd
whitespace colon
whitespace var: fwstate
whitespace colon
whitespace lbrace
var: int
rbrace
semicolon
stexcwhitespace var: central
whitespace colon
whitespace lbrace
var: srpair
rbrace
whitespace colon
whitespace var: int
whitespace colon
whitespace var: bool
semicolon
stexcwhitespace var: cansend
whitespace colon
whitespace lbrace
var: srpair
rbrace
whitespace colon
whitespace var: int
whitespace colon
whitespace var: int
whitespace colon
whitespace var: bool
semicolon
stexcwhitespace var: is_central
whitespace colon
whitespace var: int
whitespace colon
whitespace var: bool
semicolon
stexcwhitespace var: nlmem
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
whitespace colon
whitespace var: string
whitespace colon
whitespace var: string
whitespace colon
whitespace var: bool
semicolon
stexcwhitespace var: ns
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
whitespace colon
whitespace var: string
whitespace colon
whitespace var: string
whitespace colon
whitespace var: nlrecord
semicolon
stexcwhitespace var: subscribed
whitespace colon
whitespace var: nlrecord
whitespace colon
whitespace var: bool
semicolon
stexcwhitespace var: nletter
whitespace colon
whitespace var: nlrecord
whitespace colon
whitespace var: string
semicolon
stexcwhitespace var: code
whitespace colon
whitespace var: nlrecord
whitespace colon
whitespace var: code
semicolon
stexcwhitespace var: articles
whitespace colon
whitespace var: nlrecord
whitespace colon
whitespace lbrace
var: string
rbrace
semicolon
stexcwhitespace var: email
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
whitespace colon
whitespace var: user
whitespace colon
whitespace var: bool
semicolon
stexcwhitespace var: promotions
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
whitespace colon
whitespace var: user
whitespace colon
whitespace var: bool
semicolon
var: add_device
whitespace colon
whitespace lparen
var: dtable
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace whitespace lparen
var: cstab
whitespace colon
whitespace lbrace
var: srpair
rbrace
rparen
whitespace arrow
whitespace whitespace lparen
var: d
whitespace colon
whitespace lcurly
var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace var: device
whitespace lparen
var: dtable
comma
whitespace var: v
rparen
whitespace equalopwhitespace falsercurly
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace var: fwstate
whitespace pipe
lambdalparen
var: s
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
dotwhitespace var: fst
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: cstab
whitespace conjwhitespace lparen
var: s
whitespace equalopwhitespace var: snd
whitespace lparen
var: v
rparen
whitespace implieswhitespace whitespace var: device
lparen
var: s
comma
whitespace var: d
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace var: dsize
lparen
var: s
rparen
whitespace equalopwhitespace var: dsize
lparen
var: dtable
rparen
whitespace pluswhitespace int: 1
rparen
whitespace rcurly
semicolon
var: diff_device
whitespace colon
whitespace lparen
var: sr
whitespace colon
whitespace lbrace
var: srpair
rbrace
rparen
whitespace arrow
whitespace lparen
var: dtable
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lparen
var: d
whitespace colon
whitespace lcurly
var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace truercurly
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace var: device
lparen
var: dtable
comma
whitespace var: v
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace notwhitespace lbrace
var: v
equalopvar: d
rbrace
whitespace rcurly
semicolon
var: add_connection
whitespace colon
whitespace lparen
var: sr
whitespace colon
whitespace lbrace
var: srpair
rbrace
rparen
whitespace arrow
whitespace lparen
var: dtable
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lparen
var: s
whitespace colon
whitespace lcurly
var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace var: device
lparen
var: dtable
comma
whitespace var: v
rparen
whitespace equalopwhitespace truercurly
rparen
whitespace arrow
whitespace lparen
var: r
whitespace colon
whitespace lcurly
var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace var: device
lparen
var: dtable
comma
whitespace var: v
rparen
whitespace equalopwhitespace truercurly
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace var: fwstate
whitespace pipe
whitespace lambdalparen
var: f
whitespace colon
whitespace lbrace
var: srpair
rbrace
rparen
dotwhitespace var: snd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: dtable
whitespace conjwhitespace lparen
var: f
whitespace equalopwhitespace var: fst
whitespace lparen
var: v
rparen
whitespace implieswhitespace var: cansend
lparen
var: f
comma
whitespace var: s
comma
whitespace var: r
rparen
whitespace equalopwhitespace truerparen
whitespace rcurly
semicolon
var: make_central
whitespace colon
whitespace lparen
var: sr
whitespace colon
whitespace lbrace
var: srpair
rbrace
rparen
whitespace arrow
whitespace lparen
var: dtable
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lparen
var: d
whitespace colon
whitespace lcurly
var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace var: device
lparen
var: dtable
comma
whitespace var: v
rparen
whitespace equalopwhitespace truercurly
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace var: fwstate
whitespace pipe
lambdalparen
var: f
whitespace colon
whitespace lbrace
var: srpair
rbrace
rparen
dotwhitespace var: snd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: dtable
whitespace conjwhitespace lparen
var: f
whitespace equalopwhitespace var: fst
whitespace lparen
var: v
rparen
whitespace implieswhitespace var: central
lparen
var: f
comma
whitespace var: d
rparen
whitespace equalopwhitespace truerparen
whitespace rcurly
semicolon
var: delete_device
whitespace colon
whitespace lparen
var: sr
whitespace colon
whitespace lbrace
var: srpair
rbrace
rparen
whitespace arrow
whitespace lparen
var: dtable
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lparen
var: d
whitespace colon
whitespace lcurly
var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace truercurly
rparen
whitespace arrow
whitespace lparen
var: y
whitespace colon
whitespace lcurly
var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace notwhitespace lbrace
var: v
whitespace equalopwhitespace var: d
rbrace
whitespace conjwhitespace var: device
lparen
var: dtable
comma
whitespace var: v
rparen
whitespace equalopwhitespace truewhitespace whitespace conjwhitespace var: central
lparen
var: sr
comma
whitespace var: v
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace whitespace var: device
lparen
var: dtable
comma
whitespace var: d
rparen
equalopwhitespace truercurly
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace var: fwstate
whitespace pipe
lambdalparen
var: f
whitespace colon
whitespace lbrace
var: srpair
rbrace
rparen
comma
whitespace lparen
var: s
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
dotwhitespace lparen
var: f
whitespace equalopwhitespace var: fst
whitespace lparen
var: v
rparen
whitespace conjwhitespace var: s
whitespace equalopwhitespace var: snd
whitespace lparen
var: v
rparen
rparen
whitespace implieswhitespace whitespace lparen
var: device
lparen
var: s
comma
whitespace var: d
rparen
whitespace equalopwhitespace falsewhitespace conjwhitespace var: central
lparen
var: f
comma
whitespace var: y
rparen
whitespace equalopwhitespace truewhitespace rparen
rcurly
semicolon
var: select
whitespace colon
whitespace lparen
var: db
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
rparen
whitespace arrow
whitespace lparen
var: n
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lparen
var: u
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace var: nlrecord
whitespace pipe
whitespace var: nlmem
lparen
var: db
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace var: nletter
lparen
var: v
rparen
whitespace equalopwhitespace var: n
whitespace conjwhitespace var: user
lparen
var: v
rparen
whitespace equalopwhitespace var: u
whitespace rcurly
semicolon
var: nlmem
whitespace colon
whitespace lparen
var: db
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
rparen
whitespace arrow
whitespace lparen
var: n
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lparen
var: u
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace var: bool
whitespace pipe
whitespace lparen
var: v
whitespace equalopwhitespace truewhitespace iffwhitespace var: nlmem
lparen
var: db
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace truerparen
whitespace conjwhitespace lparen
var: v
whitespace equalopwhitespace falsewhitespace iffwhitespace var: nlmem
lparen
var: db
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace falserparen
whitespace rcurly
semicolon
var: subscribe
whitespace colon
whitespace lparen
var: db
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
rparen
whitespace arrow
whitespace lparen
var: n
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lparen
var: u
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
whitespace pipe
whitespace var: nlmem
lparen
var: db
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace falsewhitespace conjwhitespace var: nlmem
lparen
var: v
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace var: subscribed
lparen
var: v
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace truewhitespace rcurly
semicolon
var: unsubscribe
whitespace colon
whitespace lparen
var: db
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
rparen
whitespace arrow
whitespace lparen
var: n
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lparen
var: u
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
whitespace pipe
whitespace var: nlmem
lparen
var: db
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace var: nlmem
lparen
var: v
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace var: subscribed
lparen
var: v
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace falsewhitespace rcurly
semicolon
var: confirm
whitespace colon
whitespace lparen
var: db
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
rparen
whitespace arrow
whitespace lparen
var: c
whitespace colon
whitespace var: code
rparen
whitespace arrow
whitespace lparen
var: n
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lparen
var: u
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
whitespace pipe
whitespace var: nlmem
lparen
var: db
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace lparen
lparen
var: c
whitespace equalopwhitespace var: Cs
whitespace implieswhitespace var: subscribed
lparen
var: v
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace truerparen
whitespace conjwhitespace lparen
var: c
whitespace equalopwhitespace var: Cu
whitespace implieswhitespace var: subscribed
lparen
var: v
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace falserparen
rparen
whitespace rcurly
semicolon
whitespace var: read
whitespace colon
whitespace lparen
var: db
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
rparen
whitespace arrow
whitespace lparen
var: n
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lparen
var: u
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace lbrace
var: string
rbrace
whitespace pipe
whitespace var: nlmem
lparen
var: db
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace var: subscribed
lparen
var: v
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace var: v
whitespace equalopwhitespace var: articles
lparen
var: v
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace rcurly
semicolon
whitespace var: remove
whitespace colon
whitespace lparen
var: db
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
rparen
whitespace arrow
whitespace lparen
var: n
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lparen
var: u
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
whitespace pipe
whitespace var: nlmem
lparen
var: v
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace falsercurly
semicolon
var: goal
whitespace colon
whitespace lparen
var: n
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace whitespace lparen
var: u
whitespace colon
whitespace var: user
rparen
whitespace arrow
whitespace whitespace lparen
var: d
whitespace colon
whitespace lcurly
var: v
colon
whitespace lbrace
var: nlrecord
rbrace
whitespace pipe
whitespace truercurly
rparen
whitespace arrow
whitespace whitespace lcurly
var: v
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
whitespace pipe
whitespace var: subscribed
whitespace lparen
var: v
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace truewhitespace whitespace conjwhitespace var: promotions
whitespace lparen
var: v
comma
whitespace var: u
rparen
whitespace equalopwhitespace truewhitespace implieswhitespace lparen
var: email
whitespace lparen
var: v
comma
whitespace var: u
rparen
whitespace equalopwhitespace truerparen
rcurly
semicolon
whitespace RelSpec {  SRs ;  PRs ;  TSs  
 Assume false
 name add_device : 
 params :
 Type  Arrow ( ( dtable : {var_v0:Ty_list int | true} ) ->  Arrow ( ( cstab : {var_v1:Ty_list int srpair | true} ) ->  Arrow ( ( d : {v:int | (device)( , dtable, v ) = (false)} ) -> {v:int fwstate | Forall 
 	 
 Key =s Value = Ty_list int{ 
 	 Conj <c (fst)(v) = (cstab)
 	 , 
 	 Impl < (s) = (snd)(v)
 	 
 	 Conj <c (device)( , s, d ) = (true)
 	 , (dsize)(s) = ((dsize)(dtable) + (1)) >c  > >c  }} 
 Assume false
 name diff_device : 
 params :
 Type  Arrow ( ( sr : {var_v2:Ty_list int srpair | true} ) ->  Arrow ( ( dtable : {var_v3:Ty_list int | true} ) ->  Arrow ( ( d : {v:int | true} ) -> {v:int | 
 	 Conj <c (device)( , dtable, v ) = (true)
 	 , Negation v = d >c } 
 Assume false
 name add_connection : 
 params :
 Type  Arrow ( ( sr : {var_v4:Ty_list int srpair | true} ) ->  Arrow ( ( dtable : {var_v5:Ty_list int | true} ) ->  Arrow ( ( s : {v:int | (device)( , dtable, v ) = (true)} ) ->  Arrow ( ( r : {v:int | (device)( , dtable, v ) = (true)} ) -> {v:int fwstate | Forall 
 	 
 Key =f Value = Ty_list int srpair{ 
 	 Conj <c (snd)(v) = (dtable)
 	 , 
 	 Impl < (f) = (fst)(v)
 	 (cansend)( , f, s, r ) = (true) > >c  }} 
 Assume false
 name make_central : 
 params :
 Type  Arrow ( ( sr : {var_v6:Ty_list int srpair | true} ) ->  Arrow ( ( dtable : {var_v7:Ty_list int | true} ) ->  Arrow ( ( d : {v:int | (device)( , dtable, v ) = (true)} ) -> {v:int fwstate | Forall 
 	 
 Key =f Value = Ty_list int srpair{ 
 	 Conj <c (snd)(v) = (dtable)
 	 , 
 	 Impl < (f) = (fst)(v)
 	 (central)( , f, d ) = (true) > >c  }} 
 Assume false
 name delete_device : 
 params :
 Type  Arrow ( ( sr : {var_v8:Ty_list int srpair | true} ) ->  Arrow ( ( dtable : {var_v9:Ty_list int | true} ) ->  Arrow ( ( d : {v:int | true} ) ->  Arrow ( ( y : {v:int | 
 	 Conj <c Negation v = d
 	 , 
 	 Conj <c (device)( , dtable, v ) = (true)
 	 , 
 	 Conj <c (central)( , sr, v ) = (true)
 	 , (device)( , dtable, d ) = (true) >c  >c  >c } ) -> {v:int fwstate | Forall 
 	 
 Key =f Value = Ty_list int srpair
 Key =s Value = Ty_list int{ 
 	 Impl < 
 	 Conj <c (f) = (fst)(v)
 	 , (s) = (snd)(v) >c 
 	 
 	 Conj <c (device)( , s, d ) = (false)
 	 , (central)( , f, y ) = (true) >c  > }} 
 Assume false
 name select : 
 params :
 Type  Arrow ( ( db : {var_v10:Ty_list int nlrecord | true} ) ->  Arrow ( ( n : {var_v11:Ty_string | true} ) ->  Arrow ( ( u : {var_v12:Ty_string | true} ) -> {v:int nlrecord | 
 	 Conj <c (nlmem)( , db, n, u ) = (true)
 	 , 
 	 Conj <c (nletter)(v) = (n)
 	 , (user)(v) = (u) >c  >c } 
 Assume false
 name nlmem : 
 params :
 Type  Arrow ( ( db : {var_v13:Ty_list int nlrecord | true} ) ->  Arrow ( ( n : {var_v14:Ty_string | true} ) ->  Arrow ( ( u : {var_v15:Ty_string | true} ) -> {v:Ty_bool | 
 	 Conj <c DoubleImpl 
 (v) = (true)
  (nlmem)( , db, n, u ) = (true)
 	 , DoubleImpl 
 (v) = (false)
  (nlmem)( , db, n, u ) = (false) >c } 
 Assume false
 name subscribe : 
 params :
 Type  Arrow ( ( db : {var_v16:Ty_list int nlrecord | true} ) ->  Arrow ( ( n : {var_v17:Ty_string | true} ) ->  Arrow ( ( u : {var_v18:Ty_string | true} ) -> {v:Ty_list int nlrecord | 
 	 Conj <c (nlmem)( , db, n, u ) = (false)
 	 , 
 	 Conj <c (nlmem)( , v, n, u ) = (true)
 	 , (subscribed)( , v, n, u ) = (true) >c  >c } 
 Assume false
 name unsubscribe : 
 params :
 Type  Arrow ( ( db : {var_v19:Ty_list int nlrecord | true} ) ->  Arrow ( ( n : {var_v20:Ty_string | true} ) ->  Arrow ( ( u : {var_v21:Ty_string | true} ) -> {v:Ty_list int nlrecord | 
 	 Conj <c (nlmem)( , db, n, u ) = (true)
 	 , 
 	 Conj <c (nlmem)( , v, n, u ) = (true)
 	 , (subscribed)( , v, n, u ) = (false) >c  >c } 
 Assume false
 name confirm : 
 params :
 Type  Arrow ( ( db : {var_v22:Ty_list int nlrecord | true} ) ->  Arrow ( ( c : {var_v23:int code | true} ) ->  Arrow ( ( n : {var_v24:Ty_string | true} ) ->  Arrow ( ( u : {var_v25:Ty_string | true} ) -> {v:Ty_list int nlrecord | 
 	 Conj <c (nlmem)( , db, n, u ) = (true)
 	 , 
 	 Conj <c 
 	 Impl < (c) = (Cs)
 	 (subscribed)( , v, n, u ) = (true) >
 	 , 
 	 Impl < (c) = (Cu)
 	 (subscribed)( , v, n, u ) = (false) > >c  >c } 
 Assume false
 name read : 
 params :
 Type  Arrow ( ( db : {var_v26:Ty_list int nlrecord | true} ) ->  Arrow ( ( n : {var_v27:Ty_string | true} ) ->  Arrow ( ( u : {var_v28:Ty_string | true} ) -> {v:Ty_list Ty_string | 
 	 Conj <c (nlmem)( , db, n, u ) = (true)
 	 , 
 	 Conj <c (subscribed)( , v, n, u ) = (true)
 	 , (v) = (articles)( , v, n, u ) >c  >c } 
 Assume false
 name remove : 
 params :
 Type  Arrow ( ( db : {var_v29:Ty_list int nlrecord | true} ) ->  Arrow ( ( n : {var_v30:Ty_string | true} ) ->  Arrow ( ( u : {var_v31:Ty_string | true} ) -> {v:Ty_list int nlrecord | (nlmem)( , v, n, u ) = (false)} 
 Assume false
 name goal : 
 params :
 Type  Arrow ( ( n : {var_v32:Ty_string | true} ) ->  Arrow ( ( u : {var_v33:int user | true} ) ->  Arrow ( ( d : {v:Ty_list int nlrecord | true} ) -> {v:Ty_list int nlrecord | 
 	 Conj <c (subscribed)( , v, n, u ) = (true)
 	 , 
 	 Impl < (promotions)( , v, u ) = (true)
 	 (email)( , v, u ) = (true) > >c };  Formulas  }
 INITIAL GAMMA 
 
 goal :  Arrow ( ( n : {var_v32:Ty_string | true} ) ->  Arrow ( ( u : {var_v33:int user | true} ) ->  Arrow ( ( d : {v:Ty_list int nlrecord | true} ) -> {v:Ty_list int nlrecord | 
 	 Conj <c (subscribed)( , v, n, u ) = (true)
 	 , 
 	 Impl < (promotions)( , v, u ) = (true)
 	 (email)( , v, u ) = (true) > >c }
 remove :  Arrow ( ( db : {var_v29:Ty_list int nlrecord | true} ) ->  Arrow ( ( n : {var_v30:Ty_string | true} ) ->  Arrow ( ( u : {var_v31:Ty_string | true} ) -> {v:Ty_list int nlrecord | (nlmem)( , v, n, u ) = (false)}
 read :  Arrow ( ( db : {var_v26:Ty_list int nlrecord | true} ) ->  Arrow ( ( n : {var_v27:Ty_string | true} ) ->  Arrow ( ( u : {var_v28:Ty_string | true} ) -> {v:Ty_list Ty_string | 
 	 Conj <c (nlmem)( , db, n, u ) = (true)
 	 , 
 	 Conj <c (subscribed)( , v, n, u ) = (true)
 	 , (v) = (articles)( , v, n, u ) >c  >c }
 confirm :  Arrow ( ( db : {var_v22:Ty_list int nlrecord | true} ) ->  Arrow ( ( c : {var_v23:int code | true} ) ->  Arrow ( ( n : {var_v24:Ty_string | true} ) ->  Arrow ( ( u : {var_v25:Ty_string | true} ) -> {v:Ty_list int nlrecord | 
 	 Conj <c (nlmem)( , db, n, u ) = (true)
 	 , 
 	 Conj <c 
 	 Impl < (c) = (Cs)
 	 (subscribed)( , v, n, u ) = (true) >
 	 , 
 	 Impl < (c) = (Cu)
 	 (subscribed)( , v, n, u ) = (false) > >c  >c }
 unsubscribe :  Arrow ( ( db : {var_v19:Ty_list int nlrecord | true} ) ->  Arrow ( ( n : {var_v20:Ty_string | true} ) ->  Arrow ( ( u : {var_v21:Ty_string | true} ) -> {v:Ty_list int nlrecord | 
 	 Conj <c (nlmem)( , db, n, u ) = (true)
 	 , 
 	 Conj <c (nlmem)( , v, n, u ) = (true)
 	 , (subscribed)( , v, n, u ) = (false) >c  >c }
 subscribe :  Arrow ( ( db : {var_v16:Ty_list int nlrecord | true} ) ->  Arrow ( ( n : {var_v17:Ty_string | true} ) ->  Arrow ( ( u : {var_v18:Ty_string | true} ) -> {v:Ty_list int nlrecord | 
 	 Conj <c (nlmem)( , db, n, u ) = (false)
 	 , 
 	 Conj <c (nlmem)( , v, n, u ) = (true)
 	 , (subscribed)( , v, n, u ) = (true) >c  >c }
 nlmem :  Arrow ( ( db : {var_v13:Ty_list int nlrecord | true} ) ->  Arrow ( ( n : {var_v14:Ty_string | true} ) ->  Arrow ( ( u : {var_v15:Ty_string | true} ) -> {v:Ty_bool | 
 	 Conj <c DoubleImpl 
 (v) = (true)
  (nlmem)( , db, n, u ) = (true)
 	 , DoubleImpl 
 (v) = (false)
  (nlmem)( , db, n, u ) = (false) >c }
 select :  Arrow ( ( db : {var_v10:Ty_list int nlrecord | true} ) ->  Arrow ( ( n : {var_v11:Ty_string | true} ) ->  Arrow ( ( u : {var_v12:Ty_string | true} ) -> {v:int nlrecord | 
 	 Conj <c (nlmem)( , db, n, u ) = (true)
 	 , 
 	 Conj <c (nletter)(v) = (n)
 	 , (user)(v) = (u) >c  >c }
 delete_device :  Arrow ( ( sr : {var_v8:Ty_list int srpair | true} ) ->  Arrow ( ( dtable : {var_v9:Ty_list int | true} ) ->  Arrow ( ( d : {v:int | true} ) ->  Arrow ( ( y : {v:int | 
 	 Conj <c Negation v = d
 	 , 
 	 Conj <c (device)( , dtable, v ) = (true)
 	 , 
 	 Conj <c (central)( , sr, v ) = (true)
 	 , (device)( , dtable, d ) = (true) >c  >c  >c } ) -> {v:int fwstate | Forall 
 	 
 Key =f Value = Ty_list int srpair
 Key =s Value = Ty_list int{ 
 	 Impl < 
 	 Conj <c (f) = (fst)(v)
 	 , (s) = (snd)(v) >c 
 	 
 	 Conj <c (device)( , s, d ) = (false)
 	 , (central)( , f, y ) = (true) >c  > }}
 make_central :  Arrow ( ( sr : {var_v6:Ty_list int srpair | true} ) ->  Arrow ( ( dtable : {var_v7:Ty_list int | true} ) ->  Arrow ( ( d : {v:int | (device)( , dtable, v ) = (true)} ) -> {v:int fwstate | Forall 
 	 
 Key =f Value = Ty_list int srpair{ 
 	 Conj <c (snd)(v) = (dtable)
 	 , 
 	 Impl < (f) = (fst)(v)
 	 (central)( , f, d ) = (true) > >c  }}
 add_connection :  Arrow ( ( sr : {var_v4:Ty_list int srpair | true} ) ->  Arrow ( ( dtable : {var_v5:Ty_list int | true} ) ->  Arrow ( ( s : {v:int | (device)( , dtable, v ) = (true)} ) ->  Arrow ( ( r : {v:int | (device)( , dtable, v ) = (true)} ) -> {v:int fwstate | Forall 
 	 
 Key =f Value = Ty_list int srpair{ 
 	 Conj <c (snd)(v) = (dtable)
 	 , 
 	 Impl < (f) = (fst)(v)
 	 (cansend)( , f, s, r ) = (true) > >c  }}
 diff_device :  Arrow ( ( sr : {var_v2:Ty_list int srpair | true} ) ->  Arrow ( ( dtable : {var_v3:Ty_list int | true} ) ->  Arrow ( ( d : {v:int | true} ) -> {v:int | 
 	 Conj <c (device)( , dtable, v ) = (true)
 	 , Negation v = d >c }
 add_device :  Arrow ( ( dtable : {var_v0:Ty_list int | true} ) ->  Arrow ( ( cstab : {var_v1:Ty_list int srpair | true} ) ->  Arrow ( ( d : {v:int | (device)( , dtable, v ) = (false)} ) -> {v:int fwstate | Forall 
 	 
 Key =s Value = Ty_list int{ 
 	 Conj <c (fst)(v) = (cstab)
 	 , 
 	 Impl < (s) = (snd)(v)
 	 
 	 Conj <c (device)( , s, d ) = (true)
 	 , (dsize)(s) = ((dsize)(dtable) + (1)) >c  > >c  }}
 INITIAL SIGMA 
 
 TypeNames 
 
 code
 user
 nlrecord
 srpair
 fwstate
 Qualifiers 
 
 Qual device :  :-> Ty_list int :-> int :-> Ty_bool
 Qual dsize :  :-> Ty_list int :-> int
 Qual lmem :  :-> Ty_list int a :-> int a :-> Ty_bool
 Qual lhd :  :-> Ty_list int a :-> int a
 Qual fst :  :-> int fwstate :-> Ty_list int srpair
 Qual snd :  :-> int fwstate :-> Ty_list int
 Qual central :  :-> Ty_list int srpair :-> int :-> Ty_bool
 Qual cansend :  :-> Ty_list int srpair :-> int :-> int :-> Ty_bool
 Qual is_central :  :-> int :-> Ty_bool
 Qual nlmem :  :-> Ty_list int nlrecord :-> Ty_string :-> Ty_string :-> Ty_bool
 Qual ns :  :-> Ty_list int nlrecord :-> Ty_string :-> Ty_string :-> int nlrecord
 Qual subscribed :  :-> int nlrecord :-> Ty_bool
 Qual nletter :  :-> int nlrecord :-> Ty_string
 Qual code :  :-> int nlrecord :-> int code
 Qual articles :  :-> int nlrecord :-> Ty_list Ty_string
 Qual email :  :-> Ty_list int nlrecord :-> int user :-> Ty_bool
 Qual promotions :  :-> Ty_list int nlrecord :-> int user :-> Ty_bool
 Show ***********Calling S-FUNC synthesize***************
 Show Uncurried , n:{var_v32:Ty_string | true}, u:{var_v33:int user | true}, d:{v:Ty_list int nlrecord | true} -> {v:Ty_list int nlrecord | 
 	 Conj <c (subscribed)( , v, n, u ) = (true)
 	 , 
 	 Impl < (promotions)( , v, u ) = (true)
 	 (email)( , v, u ) = (true) > >c }
 Decreasing Measure n
 Decreasing Type {var_v32:Ty_string | true}
 Show Trying :: Top-level Match
 Show :: Synthesize Match {v:Ty_list int nlrecord | 
 	 Conj <c (subscribed)( , v, n, u ) = (true)
 	 , 
 	 Impl < (promotions)( , v, u ) = (true)
 	 (email)( , v, u ) = (true) > >c }
 Show :: List Ty_string
 Show :: Non List Case
 Match-case failed :: Try Top-level If-then-else 
 **********************************************
 iSynthesize If-THEN-ELSE {v:Ty_list int nlrecord | 
 	 Conj <c (subscribed)( , v, n, u ) = (true)
 	 , 
 	 Impl < (promotions)( , v, u ) = (true)
 	 (email)( , v, u ) = (true) > >c }
 **********************************************
  *********************Synthesizing the Guard*******************
 iSynthesize Boolean Guard {var_v34:Ty_bool | true}
  *********************Synthesizing the Guard*******************
 esynthesizeScalar for {var_v34:Ty_bool | true}
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
  *********************Guard Synthesized*******************
 iSynthesize Following Boolean Guards Found 
  ********************Guard Synthesized*******************
  If then else Failed :: Try without subdivision
 
  Entering Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  , 
 goal, 
 remove, 
 confirm, 
 unsubscribe, 
 subscribe
 ############################################################
  Synthesizing the Function application Pure Component goal
  *************** Trying Arrow Component ************goal :  Arrow ( ( n : {var_v32:Ty_string | true} ) ->  Arrow ( ( u : {var_v33:int user | true} ) ->  Arrow ( ( d : {v:Ty_list int nlrecord | true} ) -> {v:Ty_list int nlrecord | 
 	 Conj <c (subscribed)( , v, n, u ) = (true)
 	 , 
 	 Impl < (promotions)( , v, u ) = (true)
 	 (email)( , v, u ) = (true) > >c }
  *************** Synthesizing Args ei : ti for ************goal
 ##################################################################################
  Synthesizing the 1th argument for Function goal
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v32:Ty_string | true}
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v32:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls goal
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 Found Constructors with required return type
  
 ********************** HERE BEFORE 
 Show No more choices for ConsApp
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  
  DEPTH vs MAX  0 vs 2
 ##################################################################################
  Synthesizing the 2th argument for Function goal
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v33:int user | true}
 
 Enumerating a Scalar Term u
 
 Type of the Scalar Term {var_v33:int user | true}
 ################################################
 Skipping Variable u As this a  Formal Parameter to the current function Call
 Outer Function calls goal
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 Found Constructors with required return type
  
 ********************** HERE BEFORE 
 Show No more choices for ConsApp
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  
  DEPTH vs MAX  0 vs 2
 ##################################################################################
  Synthesizing the 3th argument for Function goal
  Trying Arguments in Scalars 
 esynthesizeScalar for {v:Ty_list int nlrecord | true}
 
 Enumerating a Scalar Term d
 
 Type of the Scalar Term {v:Ty_list int nlrecord | true}
 ################################################
 Skipping Variable d As this a  Formal Parameter to the current function Call
 Outer Function calls goal
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  , 
 goal, 
 remove, 
 confirm, 
 unsubscribe, 
 subscribe
 ############################################################
  Synthesizing the Function application Pure Component goal
 ################################################
 Skipping Variable goal As Outer Function Call is goal
 ################################################
 ############################################################
  Synthesizing the Function application Pure Component remove
  *************** Trying Arrow Component ************remove :  Arrow ( ( db : {var_v29:Ty_list int nlrecord | true} ) ->  Arrow ( ( n : {var_v30:Ty_string | true} ) ->  Arrow ( ( u : {var_v31:Ty_string | true} ) -> {v:Ty_list int nlrecord | (nlmem)( , v, n, u ) = (false)}
  *************** Synthesizing Args ei : ti for ************remove
 ##################################################################################
  Synthesizing the 1th argument for Function remove
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v29:Ty_list int nlrecord | true}
 
 Enumerating a Scalar Term d
 
 Type of the Scalar Term {v:Ty_list int nlrecord | true}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 1th Args option for remove : d
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 2th argument for Function remove
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v30:Ty_string | true}
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v32:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls remove
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 3th argument for Function remove
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v31:Ty_string | true}
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v30:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls remove
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  *************** Synthesizing Args ei : Failed for some  arg
 ############################################################
  Synthesizing the Function application Pure Component confirm
  *************** Trying Arrow Component ************confirm :  Arrow ( ( db : {var_v22:Ty_list int nlrecord | true} ) ->  Arrow ( ( c : {var_v23:int code | true} ) ->  Arrow ( ( n : {var_v24:Ty_string | true} ) ->  Arrow ( ( u : {var_v25:Ty_string | true} ) -> {v:Ty_list int nlrecord | 
 	 Conj <c (nlmem)( , db, n, u ) = (true)
 	 , 
 	 Conj <c 
 	 Impl < (c) = (Cs)
 	 (subscribed)( , v, n, u ) = (true) >
 	 , 
 	 Impl < (c) = (Cu)
 	 (subscribed)( , v, n, u ) = (false) > >c  >c }
  *************** Synthesizing Args ei : ti for ************confirm
 ##################################################################################
  Synthesizing the 1th argument for Function confirm
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v22:Ty_list int nlrecord | true}
 
 Enumerating a Scalar Term d
 
 Type of the Scalar Term {v:Ty_list int nlrecord | true}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term db
 
 Type of the Scalar Term {var_v29:Ty_list int nlrecord | true}
 ################################################
 Skipping Variable db As this a  Formal Parameter to the current function Call
 Outer Function calls confirm
 ################################################
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 1th Args option for confirm : d
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 2th argument for Function confirm
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v23:int code | true}
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 3th argument for Function confirm
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v24:Ty_string | true}
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v30:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls confirm
 ################################################
 
 Enumerating a Scalar Term u
 
 Type of the Scalar Term {var_v31:Ty_string | true}
 ################################################
 Skipping Variable u As this a  Formal Parameter to the current function Call
 Outer Function calls confirm
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 4th argument for Function confirm
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v25:Ty_string | true}
 
 Enumerating a Scalar Term u
 
 Type of the Scalar Term {var_v31:Ty_string | true}
 ################################################
 Skipping Variable u As this a  Formal Parameter to the current function Call
 Outer Function calls confirm
 ################################################
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v24:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls confirm
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  *************** Synthesizing Args ei : Failed for some  arg
 ############################################################
  Synthesizing the Function application Pure Component unsubscribe
  *************** Trying Arrow Component ************unsubscribe :  Arrow ( ( db : {var_v19:Ty_list int nlrecord | true} ) ->  Arrow ( ( n : {var_v20:Ty_string | true} ) ->  Arrow ( ( u : {var_v21:Ty_string | true} ) -> {v:Ty_list int nlrecord | 
 	 Conj <c (nlmem)( , db, n, u ) = (true)
 	 , 
 	 Conj <c (nlmem)( , v, n, u ) = (true)
 	 , (subscribed)( , v, n, u ) = (false) >c  >c }
  *************** Synthesizing Args ei : ti for ************unsubscribe
 ##################################################################################
  Synthesizing the 1th argument for Function unsubscribe
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v19:Ty_list int nlrecord | true}
 
 Enumerating a Scalar Term d
 
 Type of the Scalar Term {v:Ty_list int nlrecord | true}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term db
 
 Type of the Scalar Term {var_v22:Ty_list int nlrecord | true}
 ################################################
 Skipping Variable db As this a  Formal Parameter to the current function Call
 Outer Function calls unsubscribe
 ################################################
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 1th Args option for unsubscribe : d
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 2th argument for Function unsubscribe
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v20:Ty_string | true}
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v24:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls unsubscribe
 ################################################
 
 Enumerating a Scalar Term u
 
 Type of the Scalar Term {var_v25:Ty_string | true}
 ################################################
 Skipping Variable u As this a  Formal Parameter to the current function Call
 Outer Function calls unsubscribe
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 3th argument for Function unsubscribe
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v21:Ty_string | true}
 
 Enumerating a Scalar Term u
 
 Type of the Scalar Term {var_v25:Ty_string | true}
 ################################################
 Skipping Variable u As this a  Formal Parameter to the current function Call
 Outer Function calls unsubscribe
 ################################################
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v20:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls unsubscribe
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  *************** Synthesizing Args ei : Failed for some  arg
 ############################################################
  Synthesizing the Function application Pure Component subscribe
  *************** Trying Arrow Component ************subscribe :  Arrow ( ( db : {var_v16:Ty_list int nlrecord | true} ) ->  Arrow ( ( n : {var_v17:Ty_string | true} ) ->  Arrow ( ( u : {var_v18:Ty_string | true} ) -> {v:Ty_list int nlrecord | 
 	 Conj <c (nlmem)( , db, n, u ) = (false)
 	 , 
 	 Conj <c (nlmem)( , v, n, u ) = (true)
 	 , (subscribed)( , v, n, u ) = (true) >c  >c }
  *************** Synthesizing Args ei : ti for ************subscribe
 ##################################################################################
  Synthesizing the 1th argument for Function subscribe
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v16:Ty_list int nlrecord | true}
 
 Enumerating a Scalar Term d
 
 Type of the Scalar Term {v:Ty_list int nlrecord | true}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term db
 
 Type of the Scalar Term {var_v19:Ty_list int nlrecord | true}
 ################################################
 Skipping Variable db As this a  Formal Parameter to the current function Call
 Outer Function calls subscribe
 ################################################
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 1th Args option for subscribe : d
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 2th argument for Function subscribe
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v17:Ty_string | true}
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v20:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls subscribe
 ################################################
 
 Enumerating a Scalar Term u
 
 Type of the Scalar Term {var_v21:Ty_string | true}
 ################################################
 Skipping Variable u As this a  Formal Parameter to the current function Call
 Outer Function calls subscribe
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 3th argument for Function subscribe
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v18:Ty_string | true}
 
 Enumerating a Scalar Term u
 
 Type of the Scalar Term {var_v21:Ty_string | true}
 ################################################
 Skipping Variable u As this a  Formal Parameter to the current function Call
 Outer Function calls subscribe
 ################################################
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v17:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls subscribe
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  *************** Synthesizing Args ei : Failed for some  arg
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 Found Constructors with required return type
  
 ********************** HERE BEFORE 
 Show No more choices for ConsApp
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  , 
 goal, 
 remove, 
 confirm, 
 unsubscribe, 
 subscribe
 ############################################################
  Synthesizing the Function application Pure Component goal
 ################################################
 Skipping Variable goal As Outer Function Call is goal
 ################################################
 ############################################################
  Synthesizing the Function application Pure Component remove
  *************** Trying Arrow Component ************remove :  Arrow ( ( db : {var_v29:Ty_list int nlrecord | true} ) ->  Arrow ( ( n : {var_v30:Ty_string | true} ) ->  Arrow ( ( u : {var_v31:Ty_string | true} ) -> {v:Ty_list int nlrecord | (nlmem)( , v, n, u ) = (false)}
  *************** Synthesizing Args ei : ti for ************remove
 ##################################################################################
  Synthesizing the 1th argument for Function remove
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v29:Ty_list int nlrecord | true}
 
 Enumerating a Scalar Term d
 
 Type of the Scalar Term {v:Ty_list int nlrecord | true}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term db
 
 Type of the Scalar Term {var_v16:Ty_list int nlrecord | true}
 ################################################
 Skipping Variable db As this a  Formal Parameter to the current function Call
 Outer Function calls remove
 ################################################
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 1th Args option for remove : d
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 2th argument for Function remove
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v30:Ty_string | true}
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v17:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls remove
 ################################################
 
 Enumerating a Scalar Term u
 
 Type of the Scalar Term {var_v18:Ty_string | true}
 ################################################
 Skipping Variable u As this a  Formal Parameter to the current function Call
 Outer Function calls remove
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 3th argument for Function remove
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v31:Ty_string | true}
 
 Enumerating a Scalar Term u
 
 Type of the Scalar Term {var_v18:Ty_string | true}
 ################################################
 Skipping Variable u As this a  Formal Parameter to the current function Call
 Outer Function calls remove
 ################################################
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v30:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls remove
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  *************** Synthesizing Args ei : Failed for some  arg
 ############################################################
  Synthesizing the Function application Pure Component confirm
  *************** Trying Arrow Component ************confirm :  Arrow ( ( db : {var_v22:Ty_list int nlrecord | true} ) ->  Arrow ( ( c : {var_v23:int code | true} ) ->  Arrow ( ( n : {var_v24:Ty_string | true} ) ->  Arrow ( ( u : {var_v25:Ty_string | true} ) -> {v:Ty_list int nlrecord | 
 	 Conj <c (nlmem)( , db, n, u ) = (true)
 	 , 
 	 Conj <c 
 	 Impl < (c) = (Cs)
 	 (subscribed)( , v, n, u ) = (true) >
 	 , 
 	 Impl < (c) = (Cu)
 	 (subscribed)( , v, n, u ) = (false) > >c  >c }
  *************** Synthesizing Args ei : ti for ************confirm
 ##################################################################################
  Synthesizing the 1th argument for Function confirm
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v22:Ty_list int nlrecord | true}
 
 Enumerating a Scalar Term d
 
 Type of the Scalar Term {v:Ty_list int nlrecord | true}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term db
 
 Type of the Scalar Term {var_v29:Ty_list int nlrecord | true}
 ################################################
 Skipping Variable db As this a  Formal Parameter to the current function Call
 Outer Function calls confirm
 ################################################
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 1th Args option for confirm : d
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 2th argument for Function confirm
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v23:int code | true}
 
 Enumerating a Scalar Term c
 
 Type of the Scalar Term {var_v23:int code | true}
 ################################################
 Skipping Variable c As this a  Formal Parameter to the current function Call
 Outer Function calls confirm
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 3th argument for Function confirm
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v24:Ty_string | true}
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v30:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls confirm
 ################################################
 
 Enumerating a Scalar Term u
 
 Type of the Scalar Term {var_v31:Ty_string | true}
 ################################################
 Skipping Variable u As this a  Formal Parameter to the current function Call
 Outer Function calls confirm
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 4th argument for Function confirm
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v25:Ty_string | true}
 
 Enumerating a Scalar Term u
 
 Type of the Scalar Term {var_v31:Ty_string | true}
 ################################################
 Skipping Variable u As this a  Formal Parameter to the current function Call
 Outer Function calls confirm
 ################################################
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v24:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls confirm
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  *************** Synthesizing Args ei : Failed for some  arg
 ############################################################
  Synthesizing the Function application Pure Component unsubscribe
  *************** Trying Arrow Component ************unsubscribe :  Arrow ( ( db : {var_v19:Ty_list int nlrecord | true} ) ->  Arrow ( ( n : {var_v20:Ty_string | true} ) ->  Arrow ( ( u : {var_v21:Ty_string | true} ) -> {v:Ty_list int nlrecord | 
 	 Conj <c (nlmem)( , db, n, u ) = (true)
 	 , 
 	 Conj <c (nlmem)( , v, n, u ) = (true)
 	 , (subscribed)( , v, n, u ) = (false) >c  >c }
  *************** Synthesizing Args ei : ti for ************unsubscribe
 ##################################################################################
  Synthesizing the 1th argument for Function unsubscribe
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v19:Ty_list int nlrecord | true}
 
 Enumerating a Scalar Term d
 
 Type of the Scalar Term {v:Ty_list int nlrecord | true}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term db
 
 Type of the Scalar Term {var_v22:Ty_list int nlrecord | true}
 ################################################
 Skipping Variable db As this a  Formal Parameter to the current function Call
 Outer Function calls unsubscribe
 ################################################
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 1th Args option for unsubscribe : d
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 2th argument for Function unsubscribe
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v20:Ty_string | true}
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v24:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls unsubscribe
 ################################################
 
 Enumerating a Scalar Term u
 
 Type of the Scalar Term {var_v25:Ty_string | true}
 ################################################
 Skipping Variable u As this a  Formal Parameter to the current function Call
 Outer Function calls unsubscribe
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 3th argument for Function unsubscribe
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v21:Ty_string | true}
 
 Enumerating a Scalar Term u
 
 Type of the Scalar Term {var_v25:Ty_string | true}
 ################################################
 Skipping Variable u As this a  Formal Parameter to the current function Call
 Outer Function calls unsubscribe
 ################################################
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v20:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls unsubscribe
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  *************** Synthesizing Args ei : Failed for some  arg
 ############################################################
  Synthesizing the Function application Pure Component subscribe
  *************** Trying Arrow Component ************subscribe :  Arrow ( ( db : {var_v16:Ty_list int nlrecord | true} ) ->  Arrow ( ( n : {var_v17:Ty_string | true} ) ->  Arrow ( ( u : {var_v18:Ty_string | true} ) -> {v:Ty_list int nlrecord | 
 	 Conj <c (nlmem)( , db, n, u ) = (false)
 	 , 
 	 Conj <c (nlmem)( , v, n, u ) = (true)
 	 , (subscribed)( , v, n, u ) = (true) >c  >c }
  *************** Synthesizing Args ei : ti for ************subscribe
 ##################################################################################
  Synthesizing the 1th argument for Function subscribe
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v16:Ty_list int nlrecord | true}
 
 Enumerating a Scalar Term d
 
 Type of the Scalar Term {v:Ty_list int nlrecord | true}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term db
 
 Type of the Scalar Term {var_v19:Ty_list int nlrecord | true}
 ################################################
 Skipping Variable db As this a  Formal Parameter to the current function Call
 Outer Function calls subscribe
 ################################################
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 1th Args option for subscribe : d
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 2th argument for Function subscribe
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v17:Ty_string | true}
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v20:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls subscribe
 ################################################
 
 Enumerating a Scalar Term u
 
 Type of the Scalar Term {var_v21:Ty_string | true}
 ################################################
 Skipping Variable u As this a  Formal Parameter to the current function Call
 Outer Function calls subscribe
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 3th argument for Function subscribe
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v18:Ty_string | true}
 
 Enumerating a Scalar Term u
 
 Type of the Scalar Term {var_v21:Ty_string | true}
 ################################################
 Skipping Variable u As this a  Formal Parameter to the current function Call
 Outer Function calls subscribe
 ################################################
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v17:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls subscribe
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  *************** Synthesizing Args ei : Failed for some  arg
  DEPTH vs MAX  0 vs 2
 ##################################################################################
  *************** Synthesizing Args ei : Failed for some  arg
 ############################################################
  Synthesizing the Function application Pure Component remove
  *************** Trying Arrow Component ************remove :  Arrow ( ( db : {var_v29:Ty_list int nlrecord | true} ) ->  Arrow ( ( n : {var_v30:Ty_string | true} ) ->  Arrow ( ( u : {var_v31:Ty_string | true} ) -> {v:Ty_list int nlrecord | (nlmem)( , v, n, u ) = (false)}
  *************** Synthesizing Args ei : ti for ************remove
 ##################################################################################
  Synthesizing the 1th argument for Function remove
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v29:Ty_list int nlrecord | true}
 
 Enumerating a Scalar Term db
 
 Type of the Scalar Term {var_v16:Ty_list int nlrecord | true}
 ################################################
 Skipping Variable db As this a  Formal Parameter to the current function Call
 Outer Function calls remove
 ################################################
 
 Enumerating a Scalar Term d
 
 Type of the Scalar Term {v:Ty_list int nlrecord | true}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  , 
 goal, 
 remove, 
 confirm, 
 unsubscribe, 
 subscribe
 ############################################################
  Synthesizing the Function application Pure Component goal
  *************** Trying Arrow Component ************goal :  Arrow ( ( n : {var_v32:Ty_string | true} ) ->  Arrow ( ( u : {var_v33:int user | true} ) ->  Arrow ( ( d : {v:Ty_list int nlrecord | true} ) -> {v:Ty_list int nlrecord | 
 	 Conj <c (subscribed)( , v, n, u ) = (true)
 	 , 
 	 Impl < (promotions)( , v, u ) = (true)
 	 (email)( , v, u ) = (true) > >c }
  *************** Synthesizing Args ei : ti for ************goal
 ##################################################################################
  Synthesizing the 1th argument for Function goal
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v32:Ty_string | true}
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v17:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls goal
 ################################################
 
 Enumerating a Scalar Term u
 
 Type of the Scalar Term {var_v18:Ty_string | true}
 ################################################
 Skipping Variable u As this a  Formal Parameter to the current function Call
 Outer Function calls goal
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 2th argument for Function goal
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v33:int user | true}
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 3th argument for Function goal
  Trying Arguments in Scalars 
 esynthesizeScalar for {v:Ty_list int nlrecord | true}
 
 Enumerating a Scalar Term db
 
 Type of the Scalar Term {var_v16:Ty_list int nlrecord | true}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term d
 
 Type of the Scalar Term {v:Ty_list int nlrecord | true}
 ################################################
 Skipping Variable d As this a  Formal Parameter to the current function Call
 Outer Function calls goal
 ################################################
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 3th Args option for goal : db
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  *************** Synthesizing Args ei : Failed for some  arg
 ############################################################
  Synthesizing the Function application Pure Component remove
  *************** Trying Arrow Component ************remove :  Arrow ( ( db : {var_v29:Ty_list int nlrecord | true} ) ->  Arrow ( ( n : {var_v30:Ty_string | true} ) ->  Arrow ( ( u : {var_v31:Ty_string | true} ) -> {v:Ty_list int nlrecord | (nlmem)( , v, n, u ) = (false)}
  *************** Synthesizing Args ei : ti for ************remove
 ##################################################################################
  Synthesizing the 1th argument for Function remove
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v29:Ty_list int nlrecord | true}
 
 Enumerating a Scalar Term db
 
 Type of the Scalar Term {var_v16:Ty_list int nlrecord | true}
 ################################################
 Skipping Variable db As this a  Formal Parameter to the current function Call
 Outer Function calls remove
 ################################################
 
 Enumerating a Scalar Term d
 
 Type of the Scalar Term {v:Ty_list int nlrecord | true}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 1th Args option for remove : d
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 2th argument for Function remove
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v30:Ty_string | true}
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v32:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls remove
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 3th argument for Function remove
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v31:Ty_string | true}
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v30:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls remove
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  *************** Synthesizing Args ei : Failed for some  arg
 ############################################################
  Synthesizing the Function application Pure Component confirm
  *************** Trying Arrow Component ************confirm :  Arrow ( ( db : {var_v22:Ty_list int nlrecord | true} ) ->  Arrow ( ( c : {var_v23:int code | true} ) ->  Arrow ( ( n : {var_v24:Ty_string | true} ) ->  Arrow ( ( u : {var_v25:Ty_string | true} ) -> {v:Ty_list int nlrecord | 
 	 Conj <c (nlmem)( , db, n, u ) = (true)
 	 , 
 	 Conj <c 
 	 Impl < (c) = (Cs)
 	 (subscribed)( , v, n, u ) = (true) >
 	 , 
 	 Impl < (c) = (Cu)
 	 (subscribed)( , v, n, u ) = (false) > >c  >c }
  *************** Synthesizing Args ei : ti for ************confirm
 ##################################################################################
  Synthesizing the 1th argument for Function confirm
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v22:Ty_list int nlrecord | true}
 
 Enumerating a Scalar Term d
 
 Type of the Scalar Term {v:Ty_list int nlrecord | true}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term db
 
 Type of the Scalar Term {var_v29:Ty_list int nlrecord | true}
 ################################################
 Skipping Variable db As this a  Formal Parameter to the current function Call
 Outer Function calls confirm
 ################################################
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 1th Args option for confirm : d
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 2th argument for Function confirm
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v23:int code | true}
 
 Enumerating a Scalar Term c
 
 Type of the Scalar Term {var_v23:int code | true}
 ################################################
 Skipping Variable c As this a  Formal Parameter to the current function Call
 Outer Function calls confirm
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 3th argument for Function confirm
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v24:Ty_string | true}
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v30:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls confirm
 ################################################
 
 Enumerating a Scalar Term u
 
 Type of the Scalar Term {var_v31:Ty_string | true}
 ################################################
 Skipping Variable u As this a  Formal Parameter to the current function Call
 Outer Function calls confirm
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 4th argument for Function confirm
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v25:Ty_string | true}
 
 Enumerating a Scalar Term u
 
 Type of the Scalar Term {var_v31:Ty_string | true}
 ################################################
 Skipping Variable u As this a  Formal Parameter to the current function Call
 Outer Function calls confirm
 ################################################
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v24:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls confirm
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  *************** Synthesizing Args ei : Failed for some  arg
 ############################################################
  Synthesizing the Function application Pure Component unsubscribe
  *************** Trying Arrow Component ************unsubscribe :  Arrow ( ( db : {var_v19:Ty_list int nlrecord | true} ) ->  Arrow ( ( n : {var_v20:Ty_string | true} ) ->  Arrow ( ( u : {var_v21:Ty_string | true} ) -> {v:Ty_list int nlrecord | 
 	 Conj <c (nlmem)( , db, n, u ) = (true)
 	 , 
 	 Conj <c (nlmem)( , v, n, u ) = (true)
 	 , (subscribed)( , v, n, u ) = (false) >c  >c }
  *************** Synthesizing Args ei : ti for ************unsubscribe
 ##################################################################################
  Synthesizing the 1th argument for Function unsubscribe
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v19:Ty_list int nlrecord | true}
 
 Enumerating a Scalar Term d
 
 Type of the Scalar Term {v:Ty_list int nlrecord | true}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term db
 
 Type of the Scalar Term {var_v22:Ty_list int nlrecord | true}
 ################################################
 Skipping Variable db As this a  Formal Parameter to the current function Call
 Outer Function calls unsubscribe
 ################################################
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 1th Args option for unsubscribe : d
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 2th argument for Function unsubscribe
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v20:Ty_string | true}
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v24:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls unsubscribe
 ################################################
 
 Enumerating a Scalar Term u
 
 Type of the Scalar Term {var_v25:Ty_string | true}
 ################################################
 Skipping Variable u As this a  Formal Parameter to the current function Call
 Outer Function calls unsubscribe
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 3th argument for Function unsubscribe
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v21:Ty_string | true}
 
 Enumerating a Scalar Term u
 
 Type of the Scalar Term {var_v25:Ty_string | true}
 ################################################
 Skipping Variable u As this a  Formal Parameter to the current function Call
 Outer Function calls unsubscribe
 ################################################
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v20:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls unsubscribe
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  *************** Synthesizing Args ei : Failed for some  arg
 ############################################################
  Synthesizing the Function application Pure Component subscribe
  *************** Trying Arrow Component ************subscribe :  Arrow ( ( db : {var_v16:Ty_list int nlrecord | true} ) ->  Arrow ( ( n : {var_v17:Ty_string | true} ) ->  Arrow ( ( u : {var_v18:Ty_string | true} ) -> {v:Ty_list int nlrecord | 
 	 Conj <c (nlmem)( , db, n, u ) = (false)
 	 , 
 	 Conj <c (nlmem)( , v, n, u ) = (true)
 	 , (subscribed)( , v, n, u ) = (true) >c  >c }
  *************** Synthesizing Args ei : ti for ************subscribe
 ##################################################################################
  Synthesizing the 1th argument for Function subscribe
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v16:Ty_list int nlrecord | true}
 
 Enumerating a Scalar Term d
 
 Type of the Scalar Term {v:Ty_list int nlrecord | true}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term db
 
 Type of the Scalar Term {var_v19:Ty_list int nlrecord | true}
 ################################################
 Skipping Variable db As this a  Formal Parameter to the current function Call
 Outer Function calls subscribe
 ################################################
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 1th Args option for subscribe : d
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 2th argument for Function subscribe
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v17:Ty_string | true}
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v20:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls subscribe
 ################################################
 
 Enumerating a Scalar Term u
 
 Type of the Scalar Term {var_v21:Ty_string | true}
 ################################################
 Skipping Variable u As this a  Formal Parameter to the current function Call
 Outer Function calls subscribe
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 3th argument for Function subscribe
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v18:Ty_string | true}
 
 Enumerating a Scalar Term u
 
 Type of the Scalar Term {var_v21:Ty_string | true}
 ################################################
 Skipping Variable u As this a  Formal Parameter to the current function Call
 Outer Function calls subscribe
 ################################################
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v17:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls subscribe
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  *************** Synthesizing Args ei : Failed for some  arg
 >>>>>>>>>>>>>>>>>>> 1th Args option for remove : d
  DEPTH vs MAX  0 vs 2
 ##################################################################################
  Synthesizing the 2th argument for Function remove
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v30:Ty_string | true}
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v17:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls remove
 ################################################
 
 Enumerating a Scalar Term u
 
 Type of the Scalar Term {var_v18:Ty_string | true}
 ################################################
 Skipping Variable u As this a  Formal Parameter to the current function Call
 Outer Function calls remove
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 Found Constructors with required return type
  
 ********************** HERE BEFORE 
 Show No more choices for ConsApp
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  
  DEPTH vs MAX  0 vs 2
 ##################################################################################
  Synthesizing the 3th argument for Function remove
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v31:Ty_string | true}
 
 Enumerating a Scalar Term u
 
 Type of the Scalar Term {var_v18:Ty_string | true}
 ################################################
 Skipping Variable u As this a  Formal Parameter to the current function Call
 Outer Function calls remove
 ################################################
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v30:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls remove
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 Found Constructors with required return type
  
 ********************** HERE BEFORE 
 Show No more choices for ConsApp
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  
  DEPTH vs MAX  0 vs 2
 ##################################################################################
  *************** Synthesizing Args ei : Failed for some  arg
 ############################################################
  Synthesizing the Function application Pure Component confirm
  *************** Trying Arrow Component ************confirm :  Arrow ( ( db : {var_v22:Ty_list int nlrecord | true} ) ->  Arrow ( ( c : {var_v23:int code | true} ) ->  Arrow ( ( n : {var_v24:Ty_string | true} ) ->  Arrow ( ( u : {var_v25:Ty_string | true} ) -> {v:Ty_list int nlrecord | 
 	 Conj <c (nlmem)( , db, n, u ) = (true)
 	 , 
 	 Conj <c 
 	 Impl < (c) = (Cs)
 	 (subscribed)( , v, n, u ) = (true) >
 	 , 
 	 Impl < (c) = (Cu)
 	 (subscribed)( , v, n, u ) = (false) > >c  >c }
  *************** Synthesizing Args ei : ti for ************confirm
 ##################################################################################
  Synthesizing the 1th argument for Function confirm
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v22:Ty_list int nlrecord | true}
 
 Enumerating a Scalar Term d
 
 Type of the Scalar Term {v:Ty_list int nlrecord | true}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term db
 
 Type of the Scalar Term {var_v29:Ty_list int nlrecord | true}
 ################################################
 Skipping Variable db As this a  Formal Parameter to the current function Call
 Outer Function calls confirm
 ################################################
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  , 
 goal, 
 remove, 
 confirm, 
 unsubscribe, 
 subscribe
 ############################################################
  Synthesizing the Function application Pure Component goal
  *************** Trying Arrow Component ************goal :  Arrow ( ( n : {var_v32:Ty_string | true} ) ->  Arrow ( ( u : {var_v33:int user | true} ) ->  Arrow ( ( d : {v:Ty_list int nlrecord | true} ) -> {v:Ty_list int nlrecord | 
 	 Conj <c (subscribed)( , v, n, u ) = (true)
 	 , 
 	 Impl < (promotions)( , v, u ) = (true)
 	 (email)( , v, u ) = (true) > >c }
  *************** Synthesizing Args ei : ti for ************goal
 ##################################################################################
  Synthesizing the 1th argument for Function goal
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v32:Ty_string | true}
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v30:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls goal
 ################################################
 
 Enumerating a Scalar Term u
 
 Type of the Scalar Term {var_v31:Ty_string | true}
 ################################################
 Skipping Variable u As this a  Formal Parameter to the current function Call
 Outer Function calls goal
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 2th argument for Function goal
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v33:int user | true}
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 3th argument for Function goal
  Trying Arguments in Scalars 
 esynthesizeScalar for {v:Ty_list int nlrecord | true}
 
 Enumerating a Scalar Term d
 
 Type of the Scalar Term {v:Ty_list int nlrecord | true}
 ################################################
 Skipping Variable d As this a  Formal Parameter to the current function Call
 Outer Function calls goal
 ################################################
 
 Enumerating a Scalar Term db
 
 Type of the Scalar Term {var_v29:Ty_list int nlrecord | true}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 3th Args option for goal : db
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  *************** Synthesizing Args ei : Failed for some  arg
 ############################################################
  Synthesizing the Function application Pure Component remove
  *************** Trying Arrow Component ************remove :  Arrow ( ( db : {var_v29:Ty_list int nlrecord | true} ) ->  Arrow ( ( n : {var_v30:Ty_string | true} ) ->  Arrow ( ( u : {var_v31:Ty_string | true} ) -> {v:Ty_list int nlrecord | (nlmem)( , v, n, u ) = (false)}
  *************** Synthesizing Args ei : ti for ************remove
 ##################################################################################
  Synthesizing the 1th argument for Function remove
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v29:Ty_list int nlrecord | true}
 
 Enumerating a Scalar Term db
 
 Type of the Scalar Term {var_v29:Ty_list int nlrecord | true}
 ################################################
 Skipping Variable db As this a  Formal Parameter to the current function Call
 Outer Function calls remove
 ################################################
 
 Enumerating a Scalar Term d
 
 Type of the Scalar Term {v:Ty_list int nlrecord | true}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 1th Args option for remove : d
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 2th argument for Function remove
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v30:Ty_string | true}
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v32:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls remove
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 3th argument for Function remove
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v31:Ty_string | true}
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v30:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls remove
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  *************** Synthesizing Args ei : Failed for some  arg
 ############################################################
  Synthesizing the Function application Pure Component confirm
  *************** Trying Arrow Component ************confirm :  Arrow ( ( db : {var_v22:Ty_list int nlrecord | true} ) ->  Arrow ( ( c : {var_v23:int code | true} ) ->  Arrow ( ( n : {var_v24:Ty_string | true} ) ->  Arrow ( ( u : {var_v25:Ty_string | true} ) -> {v:Ty_list int nlrecord | 
 	 Conj <c (nlmem)( , db, n, u ) = (true)
 	 , 
 	 Conj <c 
 	 Impl < (c) = (Cs)
 	 (subscribed)( , v, n, u ) = (true) >
 	 , 
 	 Impl < (c) = (Cu)
 	 (subscribed)( , v, n, u ) = (false) > >c  >c }
  *************** Synthesizing Args ei : ti for ************confirm
 ##################################################################################
  Synthesizing the 1th argument for Function confirm
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v22:Ty_list int nlrecord | true}
 
 Enumerating a Scalar Term d
 
 Type of the Scalar Term {v:Ty_list int nlrecord | true}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term db
 
 Type of the Scalar Term {var_v29:Ty_list int nlrecord | true}
 ################################################
 Skipping Variable db As this a  Formal Parameter to the current function Call
 Outer Function calls confirm
 ################################################
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 1th Args option for confirm : d
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 2th argument for Function confirm
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v23:int code | true}
 
 Enumerating a Scalar Term c
 
 Type of the Scalar Term {var_v23:int code | true}
 ################################################
 Skipping Variable c As this a  Formal Parameter to the current function Call
 Outer Function calls confirm
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 3th argument for Function confirm
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v24:Ty_string | true}
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v30:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls confirm
 ################################################
 
 Enumerating a Scalar Term u
 
 Type of the Scalar Term {var_v31:Ty_string | true}
 ################################################
 Skipping Variable u As this a  Formal Parameter to the current function Call
 Outer Function calls confirm
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 4th argument for Function confirm
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v25:Ty_string | true}
 
 Enumerating a Scalar Term u
 
 Type of the Scalar Term {var_v31:Ty_string | true}
 ################################################
 Skipping Variable u As this a  Formal Parameter to the current function Call
 Outer Function calls confirm
 ################################################
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v24:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls confirm
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  *************** Synthesizing Args ei : Failed for some  arg
 ############################################################
  Synthesizing the Function application Pure Component unsubscribe
  *************** Trying Arrow Component ************unsubscribe :  Arrow ( ( db : {var_v19:Ty_list int nlrecord | true} ) ->  Arrow ( ( n : {var_v20:Ty_string | true} ) ->  Arrow ( ( u : {var_v21:Ty_string | true} ) -> {v:Ty_list int nlrecord | 
 	 Conj <c (nlmem)( , db, n, u ) = (true)
 	 , 
 	 Conj <c (nlmem)( , v, n, u ) = (true)
 	 , (subscribed)( , v, n, u ) = (false) >c  >c }
  *************** Synthesizing Args ei : ti for ************unsubscribe
 ##################################################################################
  Synthesizing the 1th argument for Function unsubscribe
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v19:Ty_list int nlrecord | true}
 
 Enumerating a Scalar Term d
 
 Type of the Scalar Term {v:Ty_list int nlrecord | true}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term db
 
 Type of the Scalar Term {var_v22:Ty_list int nlrecord | true}
 ################################################
 Skipping Variable db As this a  Formal Parameter to the current function Call
 Outer Function calls unsubscribe
 ################################################
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 1th Args option for unsubscribe : d
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 2th argument for Function unsubscribe
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v20:Ty_string | true}
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v24:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls unsubscribe
 ################################################
 
 Enumerating a Scalar Term u
 
 Type of the Scalar Term {var_v25:Ty_string | true}
 ################################################
 Skipping Variable u As this a  Formal Parameter to the current function Call
 Outer Function calls unsubscribe
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 3th argument for Function unsubscribe
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v21:Ty_string | true}
 
 Enumerating a Scalar Term u
 
 Type of the Scalar Term {var_v25:Ty_string | true}
 ################################################
 Skipping Variable u As this a  Formal Parameter to the current function Call
 Outer Function calls unsubscribe
 ################################################
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v20:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls unsubscribe
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  *************** Synthesizing Args ei : Failed for some  arg
 ############################################################
  Synthesizing the Function application Pure Component subscribe
  *************** Trying Arrow Component ************subscribe :  Arrow ( ( db : {var_v16:Ty_list int nlrecord | true} ) ->  Arrow ( ( n : {var_v17:Ty_string | true} ) ->  Arrow ( ( u : {var_v18:Ty_string | true} ) -> {v:Ty_list int nlrecord | 
 	 Conj <c (nlmem)( , db, n, u ) = (false)
 	 , 
 	 Conj <c (nlmem)( , v, n, u ) = (true)
 	 , (subscribed)( , v, n, u ) = (true) >c  >c }
  *************** Synthesizing Args ei : ti for ************subscribe
 ##################################################################################
  Synthesizing the 1th argument for Function subscribe
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v16:Ty_list int nlrecord | true}
 
 Enumerating a Scalar Term d
 
 Type of the Scalar Term {v:Ty_list int nlrecord | true}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term db
 
 Type of the Scalar Term {var_v19:Ty_list int nlrecord | true}
 ################################################
 Skipping Variable db As this a  Formal Parameter to the current function Call
 Outer Function calls subscribe
 ################################################
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 1th Args option for subscribe : d
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 2th argument for Function subscribe
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v17:Ty_string | true}
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v20:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls subscribe
 ################################################
 
 Enumerating a Scalar Term u
 
 Type of the Scalar Term {var_v21:Ty_string | true}
 ################################################
 Skipping Variable u As this a  Formal Parameter to the current function Call
 Outer Function calls subscribe
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 3th argument for Function subscribe
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v18:Ty_string | true}
 
 Enumerating a Scalar Term u
 
 Type of the Scalar Term {var_v21:Ty_string | true}
 ################################################
 Skipping Variable u As this a  Formal Parameter to the current function Call
 Outer Function calls subscribe
 ################################################
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v17:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls subscribe
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  *************** Synthesizing Args ei : Failed for some  arg
 >>>>>>>>>>>>>>>>>>> 1th Args option for confirm : d
  DEPTH vs MAX  0 vs 2
 ##################################################################################
  Synthesizing the 2th argument for Function confirm
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v23:int code | true}
 
 Enumerating a Scalar Term c
 
 Type of the Scalar Term {var_v23:int code | true}
 ################################################
 Skipping Variable c As this a  Formal Parameter to the current function Call
 Outer Function calls confirm
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 Found Constructors with required return type
  
 ********************** HERE BEFORE 
 Show No more choices for ConsApp
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  
  DEPTH vs MAX  0 vs 2
 ##################################################################################
  Synthesizing the 3th argument for Function confirm
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v24:Ty_string | true}
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v17:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls confirm
 ################################################
 
 Enumerating a Scalar Term u
 
 Type of the Scalar Term {var_v18:Ty_string | true}
 ################################################
 Skipping Variable u As this a  Formal Parameter to the current function Call
 Outer Function calls confirm
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 Found Constructors with required return type
  
 ********************** HERE BEFORE 
 Show No more choices for ConsApp
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  
  DEPTH vs MAX  0 vs 2
 ##################################################################################
  Synthesizing the 4th argument for Function confirm
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v25:Ty_string | true}
 
 Enumerating a Scalar Term u
 
 Type of the Scalar Term {var_v18:Ty_string | true}
 ################################################
 Skipping Variable u As this a  Formal Parameter to the current function Call
 Outer Function calls confirm
 ################################################
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v24:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls confirm
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 Found Constructors with required return type
  
 ********************** HERE BEFORE 
 Show No more choices for ConsApp
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  
  DEPTH vs MAX  0 vs 2
 ##################################################################################
  *************** Synthesizing Args ei : Failed for some  arg
 ############################################################
  Synthesizing the Function application Pure Component unsubscribe
  *************** Trying Arrow Component ************unsubscribe :  Arrow ( ( db : {var_v19:Ty_list int nlrecord | true} ) ->  Arrow ( ( n : {var_v20:Ty_string | true} ) ->  Arrow ( ( u : {var_v21:Ty_string | true} ) -> {v:Ty_list int nlrecord | 
 	 Conj <c (nlmem)( , db, n, u ) = (true)
 	 , 
 	 Conj <c (nlmem)( , v, n, u ) = (true)
 	 , (subscribed)( , v, n, u ) = (false) >c  >c }
  *************** Synthesizing Args ei : ti for ************unsubscribe
 ##################################################################################
  Synthesizing the 1th argument for Function unsubscribe
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v19:Ty_list int nlrecord | true}
 
 Enumerating a Scalar Term d
 
 Type of the Scalar Term {v:Ty_list int nlrecord | true}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term db
 
 Type of the Scalar Term {var_v22:Ty_list int nlrecord | true}
 ################################################
 Skipping Variable db As this a  Formal Parameter to the current function Call
 Outer Function calls unsubscribe
 ################################################
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  , 
 goal, 
 remove, 
 confirm, 
 unsubscribe, 
 subscribe
 ############################################################
  Synthesizing the Function application Pure Component goal
  *************** Trying Arrow Component ************goal :  Arrow ( ( n : {var_v32:Ty_string | true} ) ->  Arrow ( ( u : {var_v33:int user | true} ) ->  Arrow ( ( d : {v:Ty_list int nlrecord | true} ) -> {v:Ty_list int nlrecord | 
 	 Conj <c (subscribed)( , v, n, u ) = (true)
 	 , 
 	 Impl < (promotions)( , v, u ) = (true)
 	 (email)( , v, u ) = (true) > >c }
  *************** Synthesizing Args ei : ti for ************goal
 ##################################################################################
  Synthesizing the 1th argument for Function goal
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v32:Ty_string | true}
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v24:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls goal
 ################################################
 
 Enumerating a Scalar Term u
 
 Type of the Scalar Term {var_v25:Ty_string | true}
 ################################################
 Skipping Variable u As this a  Formal Parameter to the current function Call
 Outer Function calls goal
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 2th argument for Function goal
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v33:int user | true}
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 3th argument for Function goal
  Trying Arguments in Scalars 
 esynthesizeScalar for {v:Ty_list int nlrecord | true}
 
 Enumerating a Scalar Term d
 
 Type of the Scalar Term {v:Ty_list int nlrecord | true}
 ################################################
 Skipping Variable d As this a  Formal Parameter to the current function Call
 Outer Function calls goal
 ################################################
 
 Enumerating a Scalar Term db
 
 Type of the Scalar Term {var_v22:Ty_list int nlrecord | true}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 3th Args option for goal : db
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  *************** Synthesizing Args ei : Failed for some  arg
 ############################################################
  Synthesizing the Function application Pure Component remove
  *************** Trying Arrow Component ************remove :  Arrow ( ( db : {var_v29:Ty_list int nlrecord | true} ) ->  Arrow ( ( n : {var_v30:Ty_string | true} ) ->  Arrow ( ( u : {var_v31:Ty_string | true} ) -> {v:Ty_list int nlrecord | (nlmem)( , v, n, u ) = (false)}
  *************** Synthesizing Args ei : ti for ************remove
 ##################################################################################
  Synthesizing the 1th argument for Function remove
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v29:Ty_list int nlrecord | true}
 
 Enumerating a Scalar Term db
 
 Type of the Scalar Term {var_v22:Ty_list int nlrecord | true}
 ################################################
 Skipping Variable db As this a  Formal Parameter to the current function Call
 Outer Function calls remove
 ################################################
 
 Enumerating a Scalar Term d
 
 Type of the Scalar Term {v:Ty_list int nlrecord | true}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 1th Args option for remove : d
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 2th argument for Function remove
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v30:Ty_string | true}
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v32:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls remove
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 3th argument for Function remove
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v31:Ty_string | true}
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v30:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls remove
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  *************** Synthesizing Args ei : Failed for some  arg
 ############################################################
  Synthesizing the Function application Pure Component confirm
  *************** Trying Arrow Component ************confirm :  Arrow ( ( db : {var_v22:Ty_list int nlrecord | true} ) ->  Arrow ( ( c : {var_v23:int code | true} ) ->  Arrow ( ( n : {var_v24:Ty_string | true} ) ->  Arrow ( ( u : {var_v25:Ty_string | true} ) -> {v:Ty_list int nlrecord | 
 	 Conj <c (nlmem)( , db, n, u ) = (true)
 	 , 
 	 Conj <c 
 	 Impl < (c) = (Cs)
 	 (subscribed)( , v, n, u ) = (true) >
 	 , 
 	 Impl < (c) = (Cu)
 	 (subscribed)( , v, n, u ) = (false) > >c  >c }
  *************** Synthesizing Args ei : ti for ************confirm
 ##################################################################################
  Synthesizing the 1th argument for Function confirm
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v22:Ty_list int nlrecord | true}
 
 Enumerating a Scalar Term d
 
 Type of the Scalar Term {v:Ty_list int nlrecord | true}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term db
 
 Type of the Scalar Term {var_v29:Ty_list int nlrecord | true}
 ################################################
 Skipping Variable db As this a  Formal Parameter to the current function Call
 Outer Function calls confirm
 ################################################
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 1th Args option for confirm : d
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 2th argument for Function confirm
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v23:int code | true}
 
 Enumerating a Scalar Term c
 
 Type of the Scalar Term {var_v23:int code | true}
 ################################################
 Skipping Variable c As this a  Formal Parameter to the current function Call
 Outer Function calls confirm
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 3th argument for Function confirm
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v24:Ty_string | true}
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v30:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls confirm
 ################################################
 
 Enumerating a Scalar Term u
 
 Type of the Scalar Term {var_v31:Ty_string | true}
 ################################################
 Skipping Variable u As this a  Formal Parameter to the current function Call
 Outer Function calls confirm
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 4th argument for Function confirm
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v25:Ty_string | true}
 
 Enumerating a Scalar Term u
 
 Type of the Scalar Term {var_v31:Ty_string | true}
 ################################################
 Skipping Variable u As this a  Formal Parameter to the current function Call
 Outer Function calls confirm
 ################################################
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v24:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls confirm
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  *************** Synthesizing Args ei : Failed for some  arg
 ############################################################
  Synthesizing the Function application Pure Component unsubscribe
  *************** Trying Arrow Component ************unsubscribe :  Arrow ( ( db : {var_v19:Ty_list int nlrecord | true} ) ->  Arrow ( ( n : {var_v20:Ty_string | true} ) ->  Arrow ( ( u : {var_v21:Ty_string | true} ) -> {v:Ty_list int nlrecord | 
 	 Conj <c (nlmem)( , db, n, u ) = (true)
 	 , 
 	 Conj <c (nlmem)( , v, n, u ) = (true)
 	 , (subscribed)( , v, n, u ) = (false) >c  >c }
  *************** Synthesizing Args ei : ti for ************unsubscribe
 ##################################################################################
  Synthesizing the 1th argument for Function unsubscribe
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v19:Ty_list int nlrecord | true}
 
 Enumerating a Scalar Term d
 
 Type of the Scalar Term {v:Ty_list int nlrecord | true}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term db
 
 Type of the Scalar Term {var_v22:Ty_list int nlrecord | true}
 ################################################
 Skipping Variable db As this a  Formal Parameter to the current function Call
 Outer Function calls unsubscribe
 ################################################
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 1th Args option for unsubscribe : d
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 2th argument for Function unsubscribe
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v20:Ty_string | true}
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v24:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls unsubscribe
 ################################################
 
 Enumerating a Scalar Term u
 
 Type of the Scalar Term {var_v25:Ty_string | true}
 ################################################
 Skipping Variable u As this a  Formal Parameter to the current function Call
 Outer Function calls unsubscribe
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 3th argument for Function unsubscribe
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v21:Ty_string | true}
 
 Enumerating a Scalar Term u
 
 Type of the Scalar Term {var_v25:Ty_string | true}
 ################################################
 Skipping Variable u As this a  Formal Parameter to the current function Call
 Outer Function calls unsubscribe
 ################################################
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v20:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls unsubscribe
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  *************** Synthesizing Args ei : Failed for some  arg
 ############################################################
  Synthesizing the Function application Pure Component subscribe
  *************** Trying Arrow Component ************subscribe :  Arrow ( ( db : {var_v16:Ty_list int nlrecord | true} ) ->  Arrow ( ( n : {var_v17:Ty_string | true} ) ->  Arrow ( ( u : {var_v18:Ty_string | true} ) -> {v:Ty_list int nlrecord | 
 	 Conj <c (nlmem)( , db, n, u ) = (false)
 	 , 
 	 Conj <c (nlmem)( , v, n, u ) = (true)
 	 , (subscribed)( , v, n, u ) = (true) >c  >c }
  *************** Synthesizing Args ei : ti for ************subscribe
 ##################################################################################
  Synthesizing the 1th argument for Function subscribe
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v16:Ty_list int nlrecord | true}
 
 Enumerating a Scalar Term d
 
 Type of the Scalar Term {v:Ty_list int nlrecord | true}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term db
 
 Type of the Scalar Term {var_v19:Ty_list int nlrecord | true}
 ################################################
 Skipping Variable db As this a  Formal Parameter to the current function Call
 Outer Function calls subscribe
 ################################################
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 1th Args option for subscribe : d
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 2th argument for Function subscribe
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v17:Ty_string | true}
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v20:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls subscribe
 ################################################
 
 Enumerating a Scalar Term u
 
 Type of the Scalar Term {var_v21:Ty_string | true}
 ################################################
 Skipping Variable u As this a  Formal Parameter to the current function Call
 Outer Function calls subscribe
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 3th argument for Function subscribe
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v18:Ty_string | true}
 
 Enumerating a Scalar Term u
 
 Type of the Scalar Term {var_v21:Ty_string | true}
 ################################################
 Skipping Variable u As this a  Formal Parameter to the current function Call
 Outer Function calls subscribe
 ################################################
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v17:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls subscribe
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  *************** Synthesizing Args ei : Failed for some  arg
 >>>>>>>>>>>>>>>>>>> 1th Args option for unsubscribe : d
  DEPTH vs MAX  0 vs 2
 ##################################################################################
  Synthesizing the 2th argument for Function unsubscribe
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v20:Ty_string | true}
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v17:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls unsubscribe
 ################################################
 
 Enumerating a Scalar Term u
 
 Type of the Scalar Term {var_v18:Ty_string | true}
 ################################################
 Skipping Variable u As this a  Formal Parameter to the current function Call
 Outer Function calls unsubscribe
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 Found Constructors with required return type
  
 ********************** HERE BEFORE 
 Show No more choices for ConsApp
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  
  DEPTH vs MAX  0 vs 2
 ##################################################################################
  Synthesizing the 3th argument for Function unsubscribe
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v21:Ty_string | true}
 
 Enumerating a Scalar Term u
 
 Type of the Scalar Term {var_v18:Ty_string | true}
 ################################################
 Skipping Variable u As this a  Formal Parameter to the current function Call
 Outer Function calls unsubscribe
 ################################################
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v20:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls unsubscribe
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 Found Constructors with required return type
  
 ********************** HERE BEFORE 
 Show No more choices for ConsApp
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  
  DEPTH vs MAX  0 vs 2
 ##################################################################################
  *************** Synthesizing Args ei : Failed for some  arg
 ############################################################
  Synthesizing the Function application Pure Component subscribe
  *************** Trying Arrow Component ************subscribe :  Arrow ( ( db : {var_v16:Ty_list int nlrecord | true} ) ->  Arrow ( ( n : {var_v17:Ty_string | true} ) ->  Arrow ( ( u : {var_v18:Ty_string | true} ) -> {v:Ty_list int nlrecord | 
 	 Conj <c (nlmem)( , db, n, u ) = (false)
 	 , 
 	 Conj <c (nlmem)( , v, n, u ) = (true)
 	 , (subscribed)( , v, n, u ) = (true) >c  >c }
  *************** Synthesizing Args ei : ti for ************subscribe
 ##################################################################################
  Synthesizing the 1th argument for Function subscribe
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v16:Ty_list int nlrecord | true}
 
 Enumerating a Scalar Term d
 
 Type of the Scalar Term {v:Ty_list int nlrecord | true}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term db
 
 Type of the Scalar Term {var_v19:Ty_list int nlrecord | true}
 ################################################
 Skipping Variable db As this a  Formal Parameter to the current function Call
 Outer Function calls subscribe
 ################################################
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  , 
 goal, 
 remove, 
 confirm, 
 unsubscribe, 
 subscribe
 ############################################################
  Synthesizing the Function application Pure Component goal
  *************** Trying Arrow Component ************goal :  Arrow ( ( n : {var_v32:Ty_string | true} ) ->  Arrow ( ( u : {var_v33:int user | true} ) ->  Arrow ( ( d : {v:Ty_list int nlrecord | true} ) -> {v:Ty_list int nlrecord | 
 	 Conj <c (subscribed)( , v, n, u ) = (true)
 	 , 
 	 Impl < (promotions)( , v, u ) = (true)
 	 (email)( , v, u ) = (true) > >c }
  *************** Synthesizing Args ei : ti for ************goal
 ##################################################################################
  Synthesizing the 1th argument for Function goal
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v32:Ty_string | true}
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v20:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls goal
 ################################################
 
 Enumerating a Scalar Term u
 
 Type of the Scalar Term {var_v21:Ty_string | true}
 ################################################
 Skipping Variable u As this a  Formal Parameter to the current function Call
 Outer Function calls goal
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 2th argument for Function goal
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v33:int user | true}
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 3th argument for Function goal
  Trying Arguments in Scalars 
 esynthesizeScalar for {v:Ty_list int nlrecord | true}
 
 Enumerating a Scalar Term d
 
 Type of the Scalar Term {v:Ty_list int nlrecord | true}
 ################################################
 Skipping Variable d As this a  Formal Parameter to the current function Call
 Outer Function calls goal
 ################################################
 
 Enumerating a Scalar Term db
 
 Type of the Scalar Term {var_v19:Ty_list int nlrecord | true}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 3th Args option for goal : db
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  *************** Synthesizing Args ei : Failed for some  arg
 ############################################################
  Synthesizing the Function application Pure Component remove
  *************** Trying Arrow Component ************remove :  Arrow ( ( db : {var_v29:Ty_list int nlrecord | true} ) ->  Arrow ( ( n : {var_v30:Ty_string | true} ) ->  Arrow ( ( u : {var_v31:Ty_string | true} ) -> {v:Ty_list int nlrecord | (nlmem)( , v, n, u ) = (false)}
  *************** Synthesizing Args ei : ti for ************remove
 ##################################################################################
  Synthesizing the 1th argument for Function remove
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v29:Ty_list int nlrecord | true}
 
 Enumerating a Scalar Term db
 
 Type of the Scalar Term {var_v19:Ty_list int nlrecord | true}
 ################################################
 Skipping Variable db As this a  Formal Parameter to the current function Call
 Outer Function calls remove
 ################################################
 
 Enumerating a Scalar Term d
 
 Type of the Scalar Term {v:Ty_list int nlrecord | true}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 1th Args option for remove : d
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 2th argument for Function remove
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v30:Ty_string | true}
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v32:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls remove
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 3th argument for Function remove
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v31:Ty_string | true}
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v30:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls remove
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  *************** Synthesizing Args ei : Failed for some  arg
 ############################################################
  Synthesizing the Function application Pure Component confirm
  *************** Trying Arrow Component ************confirm :  Arrow ( ( db : {var_v22:Ty_list int nlrecord | true} ) ->  Arrow ( ( c : {var_v23:int code | true} ) ->  Arrow ( ( n : {var_v24:Ty_string | true} ) ->  Arrow ( ( u : {var_v25:Ty_string | true} ) -> {v:Ty_list int nlrecord | 
 	 Conj <c (nlmem)( , db, n, u ) = (true)
 	 , 
 	 Conj <c 
 	 Impl < (c) = (Cs)
 	 (subscribed)( , v, n, u ) = (true) >
 	 , 
 	 Impl < (c) = (Cu)
 	 (subscribed)( , v, n, u ) = (false) > >c  >c }
  *************** Synthesizing Args ei : ti for ************confirm
 ##################################################################################
  Synthesizing the 1th argument for Function confirm
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v22:Ty_list int nlrecord | true}
 
 Enumerating a Scalar Term d
 
 Type of the Scalar Term {v:Ty_list int nlrecord | true}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term db
 
 Type of the Scalar Term {var_v29:Ty_list int nlrecord | true}
 ################################################
 Skipping Variable db As this a  Formal Parameter to the current function Call
 Outer Function calls confirm
 ################################################
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 1th Args option for confirm : d
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 2th argument for Function confirm
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v23:int code | true}
 
 Enumerating a Scalar Term c
 
 Type of the Scalar Term {var_v23:int code | true}
 ################################################
 Skipping Variable c As this a  Formal Parameter to the current function Call
 Outer Function calls confirm
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 3th argument for Function confirm
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v24:Ty_string | true}
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v30:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls confirm
 ################################################
 
 Enumerating a Scalar Term u
 
 Type of the Scalar Term {var_v31:Ty_string | true}
 ################################################
 Skipping Variable u As this a  Formal Parameter to the current function Call
 Outer Function calls confirm
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 4th argument for Function confirm
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v25:Ty_string | true}
 
 Enumerating a Scalar Term u
 
 Type of the Scalar Term {var_v31:Ty_string | true}
 ################################################
 Skipping Variable u As this a  Formal Parameter to the current function Call
 Outer Function calls confirm
 ################################################
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v24:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls confirm
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  *************** Synthesizing Args ei : Failed for some  arg
 ############################################################
  Synthesizing the Function application Pure Component unsubscribe
  *************** Trying Arrow Component ************unsubscribe :  Arrow ( ( db : {var_v19:Ty_list int nlrecord | true} ) ->  Arrow ( ( n : {var_v20:Ty_string | true} ) ->  Arrow ( ( u : {var_v21:Ty_string | true} ) -> {v:Ty_list int nlrecord | 
 	 Conj <c (nlmem)( , db, n, u ) = (true)
 	 , 
 	 Conj <c (nlmem)( , v, n, u ) = (true)
 	 , (subscribed)( , v, n, u ) = (false) >c  >c }
  *************** Synthesizing Args ei : ti for ************unsubscribe
 ##################################################################################
  Synthesizing the 1th argument for Function unsubscribe
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v19:Ty_list int nlrecord | true}
 
 Enumerating a Scalar Term d
 
 Type of the Scalar Term {v:Ty_list int nlrecord | true}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term db
 
 Type of the Scalar Term {var_v22:Ty_list int nlrecord | true}
 ################################################
 Skipping Variable db As this a  Formal Parameter to the current function Call
 Outer Function calls unsubscribe
 ################################################
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 1th Args option for unsubscribe : d
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 2th argument for Function unsubscribe
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v20:Ty_string | true}
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v24:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls unsubscribe
 ################################################
 
 Enumerating a Scalar Term u
 
 Type of the Scalar Term {var_v25:Ty_string | true}
 ################################################
 Skipping Variable u As this a  Formal Parameter to the current function Call
 Outer Function calls unsubscribe
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 3th argument for Function unsubscribe
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v21:Ty_string | true}
 
 Enumerating a Scalar Term u
 
 Type of the Scalar Term {var_v25:Ty_string | true}
 ################################################
 Skipping Variable u As this a  Formal Parameter to the current function Call
 Outer Function calls unsubscribe
 ################################################
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v20:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls unsubscribe
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  *************** Synthesizing Args ei : Failed for some  arg
 ############################################################
  Synthesizing the Function application Pure Component subscribe
  *************** Trying Arrow Component ************subscribe :  Arrow ( ( db : {var_v16:Ty_list int nlrecord | true} ) ->  Arrow ( ( n : {var_v17:Ty_string | true} ) ->  Arrow ( ( u : {var_v18:Ty_string | true} ) -> {v:Ty_list int nlrecord | 
 	 Conj <c (nlmem)( , db, n, u ) = (false)
 	 , 
 	 Conj <c (nlmem)( , v, n, u ) = (true)
 	 , (subscribed)( , v, n, u ) = (true) >c  >c }
  *************** Synthesizing Args ei : ti for ************subscribe
 ##################################################################################
  Synthesizing the 1th argument for Function subscribe
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v16:Ty_list int nlrecord | true}
 
 Enumerating a Scalar Term d
 
 Type of the Scalar Term {v:Ty_list int nlrecord | true}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term db
 
 Type of the Scalar Term {var_v19:Ty_list int nlrecord | true}
 ################################################
 Skipping Variable db As this a  Formal Parameter to the current function Call
 Outer Function calls subscribe
 ################################################
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 1th Args option for subscribe : d
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 2th argument for Function subscribe
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v17:Ty_string | true}
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v20:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls subscribe
 ################################################
 
 Enumerating a Scalar Term u
 
 Type of the Scalar Term {var_v21:Ty_string | true}
 ################################################
 Skipping Variable u As this a  Formal Parameter to the current function Call
 Outer Function calls subscribe
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 3th argument for Function subscribe
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v18:Ty_string | true}
 
 Enumerating a Scalar Term u
 
 Type of the Scalar Term {var_v21:Ty_string | true}
 ################################################
 Skipping Variable u As this a  Formal Parameter to the current function Call
 Outer Function calls subscribe
 ################################################
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v17:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls subscribe
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  *************** Synthesizing Args ei : Failed for some  arg
 >>>>>>>>>>>>>>>>>>> 1th Args option for subscribe : d
  DEPTH vs MAX  0 vs 2
 ##################################################################################
  Synthesizing the 2th argument for Function subscribe
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v17:Ty_string | true}
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v17:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls subscribe
 ################################################
 
 Enumerating a Scalar Term u
 
 Type of the Scalar Term {var_v18:Ty_string | true}
 ################################################
 Skipping Variable u As this a  Formal Parameter to the current function Call
 Outer Function calls subscribe
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 Found Constructors with required return type
  
 ********************** HERE BEFORE 
 Show No more choices for ConsApp
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  
  DEPTH vs MAX  0 vs 2
 ##################################################################################
  Synthesizing the 3th argument for Function subscribe
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v18:Ty_string | true}
 
 Enumerating a Scalar Term u
 
 Type of the Scalar Term {var_v18:Ty_string | true}
 ################################################
 Skipping Variable u As this a  Formal Parameter to the current function Call
 Outer Function calls subscribe
 ################################################
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v17:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls subscribe
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 Found Constructors with required return type
  
 ********************** HERE BEFORE 
 Show No more choices for ConsApp
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  
  DEPTH vs MAX  0 vs 2
 ##################################################################################
  *************** Synthesizing Args ei : Failed for some  arg
  EXPLORED Args.parser output 
 EXPLORED learningOn  true
 EXPLORED bidirectionality  true
 EXPLORED effect-filter  false
 EXPLORED specfile :: ./prudent_tests/hegel/Cobalt+/FWMkCentral.spec
 EXPLORED goal Number :: 0
 EXPLORED Max path length :: 2
 EXPLORED Nested If :: 1typewhitespace var: fwstate
semicolon
typewhitespace var: srpair
semicolon
typewhitespace var: nlrecord
semicolon
typewhitespace var: user
semicolon
typewhitespace var: code
semicolon
stexcwhitespace var: device
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: int
whitespace colon
whitespace var: bool
semicolon
stexcwhitespace var: dsize
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: lmem
whitespace colon
whitespace lbrace
var: a
rbrace
whitespace colon
whitespace var: a
whitespace colon
whitespace var: bool
semicolon
stexcwhitespace var: lhd
whitespace colon
whitespace lbrace
var: a
rbrace
whitespace colon
whitespace var: a
semicolon
stexcwhitespace var: fst
whitespace colon
whitespace var: fwstate
whitespace colon
whitespace lbrace
var: srpair
rbrace
whitespace semicolon
stexcwhitespace var: snd
whitespace colon
whitespace var: fwstate
whitespace colon
whitespace lbrace
var: int
rbrace
semicolon
stexcwhitespace var: central
whitespace colon
whitespace lbrace
var: srpair
rbrace
whitespace colon
whitespace var: int
whitespace colon
whitespace var: bool
semicolon
stexcwhitespace var: cansend
whitespace colon
whitespace lbrace
var: srpair
rbrace
whitespace colon
whitespace var: int
whitespace colon
whitespace var: int
whitespace colon
whitespace var: bool
semicolon
stexcwhitespace var: is_central
whitespace colon
whitespace var: int
whitespace colon
whitespace var: bool
semicolon
stexcwhitespace var: nlmem
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
whitespace colon
whitespace var: string
whitespace colon
whitespace var: string
whitespace colon
whitespace var: bool
semicolon
stexcwhitespace var: ns
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
whitespace colon
whitespace var: string
whitespace colon
whitespace var: string
whitespace colon
whitespace var: nlrecord
semicolon
stexcwhitespace var: subscribed
whitespace colon
whitespace var: nlrecord
whitespace colon
whitespace var: bool
semicolon
stexcwhitespace var: nletter
whitespace colon
whitespace var: nlrecord
whitespace colon
whitespace var: string
semicolon
stexcwhitespace var: code
whitespace colon
whitespace var: nlrecord
whitespace colon
whitespace var: code
semicolon
stexcwhitespace var: articles
whitespace colon
whitespace var: nlrecord
whitespace colon
whitespace lbrace
var: string
rbrace
semicolon
stexcwhitespace var: email
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
whitespace colon
whitespace var: user
whitespace colon
whitespace var: bool
semicolon
stexcwhitespace var: promotions
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
whitespace colon
whitespace var: user
whitespace colon
whitespace var: bool
semicolon
var: add_device
whitespace colon
whitespace lparen
var: dtable
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace whitespace lparen
var: cstab
whitespace colon
whitespace lbrace
var: srpair
rbrace
rparen
whitespace arrow
whitespace whitespace lparen
var: d
whitespace colon
whitespace lcurly
var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace var: device
whitespace lparen
var: dtable
comma
whitespace var: v
rparen
whitespace equalopwhitespace falsercurly
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace var: fwstate
whitespace pipe
lambdalparen
var: s
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
dotwhitespace var: fst
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: cstab
whitespace conjwhitespace lparen
var: s
whitespace equalopwhitespace var: snd
whitespace lparen
var: v
rparen
whitespace implieswhitespace whitespace var: device
lparen
var: s
comma
whitespace var: d
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace var: dsize
lparen
var: s
rparen
whitespace equalopwhitespace var: dsize
lparen
var: dtable
rparen
whitespace pluswhitespace int: 1
rparen
whitespace rcurly
semicolon
var: diff_device
whitespace colon
whitespace lparen
var: sr
whitespace colon
whitespace lbrace
var: srpair
rbrace
rparen
whitespace arrow
whitespace lparen
var: dtable
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lparen
var: d
whitespace colon
whitespace lcurly
var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace truercurly
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace var: device
lparen
var: dtable
comma
whitespace var: v
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace notwhitespace lbrace
var: v
equalopvar: d
rbrace
whitespace rcurly
semicolon
var: add_connection
whitespace colon
whitespace lparen
var: sr
whitespace colon
whitespace lbrace
var: srpair
rbrace
rparen
whitespace arrow
whitespace lparen
var: dtable
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lparen
var: s
whitespace colon
whitespace lcurly
var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace var: device
lparen
var: dtable
comma
whitespace var: v
rparen
whitespace equalopwhitespace truercurly
rparen
whitespace arrow
whitespace lparen
var: r
whitespace colon
whitespace lcurly
var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace var: device
lparen
var: dtable
comma
whitespace var: v
rparen
whitespace equalopwhitespace truercurly
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace var: fwstate
whitespace pipe
whitespace lambdalparen
var: f
whitespace colon
whitespace lbrace
var: srpair
rbrace
rparen
dotwhitespace var: snd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: dtable
whitespace conjwhitespace lparen
var: f
whitespace equalopwhitespace var: fst
whitespace lparen
var: v
rparen
whitespace implieswhitespace var: cansend
lparen
var: f
comma
whitespace var: s
comma
whitespace var: r
rparen
whitespace equalopwhitespace truerparen
whitespace rcurly
semicolon
var: make_central
whitespace colon
whitespace lparen
var: sr
whitespace colon
whitespace lbrace
var: srpair
rbrace
rparen
whitespace arrow
whitespace lparen
var: dtable
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lparen
var: d
whitespace colon
whitespace lcurly
var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace var: device
lparen
var: dtable
comma
whitespace var: v
rparen
whitespace equalopwhitespace truercurly
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace var: fwstate
whitespace pipe
lambdalparen
var: f
whitespace colon
whitespace lbrace
var: srpair
rbrace
rparen
dotwhitespace var: snd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: dtable
whitespace conjwhitespace lparen
var: f
whitespace equalopwhitespace var: fst
whitespace lparen
var: v
rparen
whitespace implieswhitespace var: central
lparen
var: f
comma
whitespace var: d
rparen
whitespace equalopwhitespace truerparen
whitespace rcurly
semicolon
var: delete_device
whitespace colon
whitespace lparen
var: sr
whitespace colon
whitespace lbrace
var: srpair
rbrace
rparen
whitespace arrow
whitespace lparen
var: dtable
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lparen
var: d
whitespace colon
whitespace lcurly
var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace truercurly
rparen
whitespace arrow
whitespace lparen
var: y
whitespace colon
whitespace lcurly
var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace notwhitespace lbrace
var: v
whitespace equalopwhitespace var: d
rbrace
whitespace conjwhitespace var: device
lparen
var: dtable
comma
whitespace var: v
rparen
whitespace equalopwhitespace truewhitespace whitespace conjwhitespace var: central
lparen
var: sr
comma
whitespace var: v
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace whitespace var: device
lparen
var: dtable
comma
whitespace var: d
rparen
equalopwhitespace truercurly
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace var: fwstate
whitespace pipe
lambdalparen
var: f
whitespace colon
whitespace lbrace
var: srpair
rbrace
rparen
comma
whitespace lparen
var: s
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
dotwhitespace lparen
var: f
whitespace equalopwhitespace var: fst
whitespace lparen
var: v
rparen
whitespace conjwhitespace var: s
whitespace equalopwhitespace var: snd
whitespace lparen
var: v
rparen
rparen
whitespace implieswhitespace whitespace lparen
var: device
lparen
var: s
comma
whitespace var: d
rparen
whitespace equalopwhitespace falsewhitespace conjwhitespace var: central
lparen
var: f
comma
whitespace var: y
rparen
whitespace equalopwhitespace truewhitespace rparen
rcurly
semicolon
var: select
whitespace colon
whitespace lparen
var: db
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
rparen
whitespace arrow
whitespace lparen
var: n
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lparen
var: u
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace var: nlrecord
whitespace pipe
whitespace var: nlmem
lparen
var: db
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace var: nletter
lparen
var: v
rparen
whitespace equalopwhitespace var: n
whitespace conjwhitespace var: user
lparen
var: v
rparen
whitespace equalopwhitespace var: u
whitespace rcurly
semicolon
var: nlmem
whitespace colon
whitespace lparen
var: db
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
rparen
whitespace arrow
whitespace lparen
var: n
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lparen
var: u
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace var: bool
whitespace pipe
whitespace lparen
var: v
whitespace equalopwhitespace truewhitespace iffwhitespace var: nlmem
lparen
var: db
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace truerparen
whitespace conjwhitespace lparen
var: v
whitespace equalopwhitespace falsewhitespace iffwhitespace var: nlmem
lparen
var: db
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace falserparen
whitespace rcurly
semicolon
var: subscribe
whitespace colon
whitespace lparen
var: db
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
rparen
whitespace arrow
whitespace lparen
var: n
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lparen
var: u
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
whitespace pipe
whitespace var: nlmem
lparen
var: db
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace falsewhitespace conjwhitespace var: nlmem
lparen
var: v
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace var: subscribed
lparen
var: v
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace truewhitespace rcurly
semicolon
var: unsubscribe
whitespace colon
whitespace lparen
var: db
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
rparen
whitespace arrow
whitespace lparen
var: n
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lparen
var: u
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
whitespace pipe
whitespace var: nlmem
lparen
var: db
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace var: nlmem
lparen
var: v
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace var: subscribed
lparen
var: v
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace falsewhitespace rcurly
semicolon
var: confirm
whitespace colon
whitespace lparen
var: db
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
rparen
whitespace arrow
whitespace lparen
var: c
whitespace colon
whitespace var: code
rparen
whitespace arrow
whitespace lparen
var: n
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lparen
var: u
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
whitespace pipe
whitespace var: nlmem
lparen
var: db
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace lparen
lparen
var: c
whitespace equalopwhitespace var: Cs
whitespace implieswhitespace var: subscribed
lparen
var: v
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace truerparen
whitespace conjwhitespace lparen
var: c
whitespace equalopwhitespace var: Cu
whitespace implieswhitespace var: subscribed
lparen
var: v
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace falserparen
rparen
whitespace rcurly
semicolon
whitespace var: read
whitespace colon
whitespace lparen
var: db
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
rparen
whitespace arrow
whitespace lparen
var: n
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lparen
var: u
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace lbrace
var: string
rbrace
whitespace pipe
whitespace var: nlmem
lparen
var: db
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace var: subscribed
lparen
var: v
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace var: v
whitespace equalopwhitespace var: articles
lparen
var: v
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace rcurly
semicolon
whitespace var: remove
whitespace colon
whitespace lparen
var: db
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
rparen
whitespace arrow
whitespace lparen
var: n
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lparen
var: u
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
whitespace pipe
whitespace var: nlmem
lparen
var: v
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace falsercurly
semicolon
var: goal
colon
whitespace whitespace lparen
var: sr
whitespace colon
whitespace lbrace
var: srpair
rbrace
rparen
whitespace arrow
whitespace whitespace lparen
var: dtable
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace whitespace lparen
var: d
whitespace colon
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace truercurly
rparen
whitespace arrow
whitespace whitespace lparen
var: x
whitespace colon
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace truewhitespace rcurly
rparen
whitespace arrow
whitespace whitespace lcurly
var: v
whitespace colon
whitespace lparen

  EXPLORED Args.parser output 
 EXPLORED learningOn  true
 EXPLORED bidirectionality  true
 EXPLORED effect-filter  false
 EXPLORED specfile :: ./prudent_tests/hegel/Cobalt+/NLInv.spec
 EXPLORED goal Number :: 0
 EXPLORED Max path length :: 2
 EXPLORED Nested If :: 1typewhitespace var: fwstate
semicolon
typewhitespace var: srpair
semicolon
typewhitespace var: nlrecord
semicolon
typewhitespace var: user
semicolon
typewhitespace var: code
semicolon
stexcwhitespace var: device
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: int
whitespace colon
whitespace var: bool
semicolon
stexcwhitespace var: dsize
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: lmem
whitespace colon
whitespace lbrace
var: a
rbrace
whitespace colon
whitespace var: a
whitespace colon
whitespace var: bool
semicolon
stexcwhitespace var: lhd
whitespace colon
whitespace lbrace
var: a
rbrace
whitespace colon
whitespace var: a
semicolon
stexcwhitespace var: fst
whitespace colon
whitespace var: fwstate
whitespace colon
whitespace lbrace
var: srpair
rbrace
whitespace semicolon
stexcwhitespace var: snd
whitespace colon
whitespace var: fwstate
whitespace colon
whitespace lbrace
var: int
rbrace
semicolon
stexcwhitespace var: central
whitespace colon
whitespace lbrace
var: srpair
rbrace
whitespace colon
whitespace var: int
whitespace colon
whitespace var: bool
semicolon
stexcwhitespace var: cansend
whitespace colon
whitespace lbrace
var: srpair
rbrace
whitespace colon
whitespace var: int
whitespace colon
whitespace var: int
whitespace colon
whitespace var: bool
semicolon
stexcwhitespace var: is_central
whitespace colon
whitespace var: int
whitespace colon
whitespace var: bool
semicolon
stexcwhitespace var: nlmem
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
whitespace colon
whitespace var: string
whitespace colon
whitespace var: string
whitespace colon
whitespace var: bool
semicolon
stexcwhitespace var: ns
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
whitespace colon
whitespace var: string
whitespace colon
whitespace var: string
whitespace colon
whitespace var: nlrecord
semicolon
stexcwhitespace var: subscribed
whitespace colon
whitespace var: nlrecord
whitespace colon
whitespace var: bool
semicolon
stexcwhitespace var: nletter
whitespace colon
whitespace var: nlrecord
whitespace colon
whitespace var: string
semicolon
stexcwhitespace var: code
whitespace colon
whitespace var: nlrecord
whitespace colon
whitespace var: code
semicolon
stexcwhitespace var: articles
whitespace colon
whitespace var: nlrecord
whitespace colon
whitespace lbrace
var: string
rbrace
semicolon
stexcwhitespace var: email
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
whitespace colon
whitespace var: user
whitespace colon
whitespace var: bool
semicolon
stexcwhitespace var: promotions
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
whitespace colon
whitespace var: user
whitespace colon
whitespace var: bool
semicolon
var: add_device
whitespace colon
whitespace lparen
var: dtable
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace whitespace lparen
var: cstab
whitespace colon
whitespace lbrace
var: srpair
rbrace
rparen
whitespace arrow
whitespace whitespace lparen
var: d
whitespace colon
whitespace lcurly
var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace var: device
whitespace lparen
var: dtable
comma
whitespace var: v
rparen
whitespace equalopwhitespace falsercurly
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace var: fwstate
whitespace pipe
lambdalparen
var: s
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
dotwhitespace var: fst
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: cstab
whitespace conjwhitespace lparen
var: s
whitespace equalopwhitespace var: snd
whitespace lparen
var: v
rparen
whitespace implieswhitespace whitespace var: device
lparen
var: s
comma
whitespace var: d
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace var: dsize
lparen
var: s
rparen
whitespace equalopwhitespace var: dsize
lparen
var: dtable
rparen
whitespace pluswhitespace int: 1
rparen
whitespace rcurly
semicolon
var: diff_device
whitespace colon
whitespace lparen
var: sr
whitespace colon
whitespace lbrace
var: srpair
rbrace
rparen
whitespace arrow
whitespace lparen
var: dtable
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lparen
var: d
whitespace colon
whitespace lcurly
var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace truercurly
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace var: device
lparen
var: dtable
comma
whitespace var: v
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace notwhitespace lbrace
var: v
equalopvar: d
rbrace
whitespace rcurly
semicolon
var: add_connection
whitespace colon
whitespace lparen
var: sr
whitespace colon
whitespace lbrace
var: srpair
rbrace
rparen
whitespace arrow
whitespace lparen
var: dtable
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lparen
var: s
whitespace colon
whitespace lcurly
var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace var: device
lparen
var: dtable
comma
whitespace var: v
rparen
whitespace equalopwhitespace truercurly
rparen
whitespace arrow
whitespace lparen
var: r
whitespace colon
whitespace lcurly
var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace var: device
lparen
var: dtable
comma
whitespace var: v
rparen
whitespace equalopwhitespace truercurly
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace var: fwstate
whitespace pipe
whitespace lambdalparen
var: f
whitespace colon
whitespace lbrace
var: srpair
rbrace
rparen
dotwhitespace var: snd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: dtable
whitespace conjwhitespace lparen
var: f
whitespace equalopwhitespace var: fst
whitespace lparen
var: v
rparen
whitespace implieswhitespace var: cansend
lparen
var: f
comma
whitespace var: s
comma
whitespace var: r
rparen
whitespace equalopwhitespace truerparen
whitespace rcurly
semicolon
var: make_central
whitespace colon
whitespace lparen
var: sr
whitespace colon
whitespace lbrace
var: srpair
rbrace
rparen
whitespace arrow
whitespace lparen
var: dtable
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lparen
var: d
whitespace colon
whitespace lcurly
var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace var: device
lparen
var: dtable
comma
whitespace var: v
rparen
whitespace equalopwhitespace truercurly
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace var: fwstate
whitespace pipe
lambdalparen
var: f
whitespace colon
whitespace lbrace
var: srpair
rbrace
rparen
dotwhitespace var: snd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: dtable
whitespace conjwhitespace lparen
var: f
whitespace equalopwhitespace var: fst
whitespace lparen
var: v
rparen
whitespace implieswhitespace var: central
lparen
var: f
comma
whitespace var: d
rparen
whitespace equalopwhitespace truerparen
whitespace rcurly
semicolon
var: delete_device
whitespace colon
whitespace lparen
var: sr
whitespace colon
whitespace lbrace
var: srpair
rbrace
rparen
whitespace arrow
whitespace lparen
var: dtable
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lparen
var: d
whitespace colon
whitespace lcurly
var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace truercurly
rparen
whitespace arrow
whitespace lparen
var: y
whitespace colon
whitespace lcurly
var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace notwhitespace lbrace
var: v
whitespace equalopwhitespace var: d
rbrace
whitespace conjwhitespace var: device
lparen
var: dtable
comma
whitespace var: v
rparen
whitespace equalopwhitespace truewhitespace whitespace conjwhitespace var: central
lparen
var: sr
comma
whitespace var: v
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace whitespace var: device
lparen
var: dtable
comma
whitespace var: d
rparen
equalopwhitespace truercurly
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace var: fwstate
whitespace pipe
lambdalparen
var: f
whitespace colon
whitespace lbrace
var: srpair
rbrace
rparen
comma
whitespace lparen
var: s
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
dotwhitespace lparen
var: f
whitespace equalopwhitespace var: fst
whitespace lparen
var: v
rparen
whitespace conjwhitespace var: s
whitespace equalopwhitespace var: snd
whitespace lparen
var: v
rparen
rparen
whitespace implieswhitespace whitespace lparen
var: device
lparen
var: s
comma
whitespace var: d
rparen
whitespace equalopwhitespace falsewhitespace conjwhitespace var: central
lparen
var: f
comma
whitespace var: y
rparen
whitespace equalopwhitespace truewhitespace rparen
rcurly
semicolon
var: select
whitespace colon
whitespace lparen
var: db
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
rparen
whitespace arrow
whitespace lparen
var: n
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lparen
var: u
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace var: nlrecord
whitespace pipe
whitespace var: nlmem
lparen
var: db
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace var: nletter
lparen
var: v
rparen
whitespace equalopwhitespace var: n
whitespace conjwhitespace var: user
lparen
var: v
rparen
whitespace equalopwhitespace var: u
whitespace rcurly
semicolon
var: nlmem
whitespace colon
whitespace lparen
var: db
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
rparen
whitespace arrow
whitespace lparen
var: n
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lparen
var: u
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace var: bool
whitespace pipe
whitespace lparen
var: v
whitespace equalopwhitespace truewhitespace iffwhitespace var: nlmem
lparen
var: db
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace truerparen
whitespace conjwhitespace lparen
var: v
whitespace equalopwhitespace falsewhitespace iffwhitespace var: nlmem
lparen
var: db
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace falserparen
whitespace rcurly
semicolon
var: subscribe
whitespace colon
whitespace lparen
var: db
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
rparen
whitespace arrow
whitespace lparen
var: n
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lparen
var: u
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
whitespace pipe
whitespace var: nlmem
lparen
var: db
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace falsewhitespace conjwhitespace var: nlmem
lparen
var: v
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace var: subscribed
lparen
var: v
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace truewhitespace rcurly
semicolon
var: unsubscribe
whitespace colon
whitespace lparen
var: db
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
rparen
whitespace arrow
whitespace lparen
var: n
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lparen
var: u
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
whitespace pipe
whitespace var: nlmem
lparen
var: db
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace var: nlmem
lparen
var: v
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace var: subscribed
lparen
var: v
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace falsewhitespace rcurly
semicolon
var: confirm
whitespace colon
whitespace lparen
var: db
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
rparen
whitespace arrow
whitespace lparen
var: c
whitespace colon
whitespace var: code
rparen
whitespace arrow
whitespace lparen
var: n
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lparen
var: u
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
whitespace pipe
whitespace var: nlmem
lparen
var: db
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace lparen
lparen
var: c
whitespace equalopwhitespace var: Cs
whitespace implieswhitespace var: subscribed
lparen
var: v
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace truerparen
whitespace conjwhitespace lparen
var: c
whitespace equalopwhitespace var: Cu
whitespace implieswhitespace var: subscribed
lparen
var: v
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace falserparen
rparen
whitespace rcurly
semicolon
whitespace var: read
whitespace colon
whitespace lparen
var: db
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
rparen
whitespace arrow
whitespace lparen
var: n
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lparen
var: u
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace lbrace
var: string
rbrace
whitespace pipe
whitespace var: nlmem
lparen
var: db
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace var: subscribed
lparen
var: v
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace var: v
whitespace equalopwhitespace var: articles
lparen
var: v
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace rcurly
semicolon
whitespace var: remove
whitespace colon
whitespace lparen
var: db
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
rparen
whitespace arrow
whitespace lparen
var: n
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lparen
var: u
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
whitespace pipe
whitespace var: nlmem
lparen
var: v
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace falsercurly
semicolon
comment begin

  EXPLORED Args.parser output 
 EXPLORED learningOn  true
 EXPLORED bidirectionality  true
 EXPLORED effect-filter  false
 EXPLORED specfile :: ./prudent_tests/hegel/Cobalt+/NLRemove.spec
 EXPLORED goal Number :: 0
 EXPLORED Max path length :: 2
 EXPLORED Nested If :: 1typewhitespace var: fwstate
semicolon
typewhitespace var: srpair
semicolon
typewhitespace var: nlrecord
semicolon
typewhitespace var: user
semicolon
typewhitespace var: code
semicolon
stexcwhitespace var: device
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: int
whitespace colon
whitespace var: bool
semicolon
stexcwhitespace var: dsize
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: lmem
whitespace colon
whitespace lbrace
var: a
rbrace
whitespace colon
whitespace var: a
whitespace colon
whitespace var: bool
semicolon
stexcwhitespace var: lhd
whitespace colon
whitespace lbrace
var: a
rbrace
whitespace colon
whitespace var: a
semicolon
stexcwhitespace var: fst
whitespace colon
whitespace var: fwstate
whitespace colon
whitespace lbrace
var: srpair
rbrace
whitespace semicolon
stexcwhitespace var: snd
whitespace colon
whitespace var: fwstate
whitespace colon
whitespace lbrace
var: int
rbrace
semicolon
stexcwhitespace var: central
whitespace colon
whitespace lbrace
var: srpair
rbrace
whitespace colon
whitespace var: int
whitespace colon
whitespace var: bool
semicolon
stexcwhitespace var: cansend
whitespace colon
whitespace lbrace
var: srpair
rbrace
whitespace colon
whitespace var: int
whitespace colon
whitespace var: int
whitespace colon
whitespace var: bool
semicolon
stexcwhitespace var: is_central
whitespace colon
whitespace var: int
whitespace colon
whitespace var: bool
semicolon
stexcwhitespace var: nlmem
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
whitespace colon
whitespace var: string
whitespace colon
whitespace var: string
whitespace colon
whitespace var: bool
semicolon
stexcwhitespace var: ns
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
whitespace colon
whitespace var: string
whitespace colon
whitespace var: string
whitespace colon
whitespace var: nlrecord
semicolon
stexcwhitespace var: subscribed
whitespace colon
whitespace var: nlrecord
whitespace colon
whitespace var: bool
semicolon
stexcwhitespace var: nletter
whitespace colon
whitespace var: nlrecord
whitespace colon
whitespace var: string
semicolon
stexcwhitespace var: code
whitespace colon
whitespace var: nlrecord
whitespace colon
whitespace var: code
semicolon
stexcwhitespace var: articles
whitespace colon
whitespace var: nlrecord
whitespace colon
whitespace lbrace
var: string
rbrace
semicolon
stexcwhitespace var: email
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
whitespace colon
whitespace var: user
whitespace colon
whitespace var: bool
semicolon
stexcwhitespace var: promotions
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
whitespace colon
whitespace var: user
whitespace colon
whitespace var: bool
semicolon
var: add_device
whitespace colon
whitespace lparen
var: dtable
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace whitespace lparen
var: cstab
whitespace colon
whitespace lbrace
var: srpair
rbrace
rparen
whitespace arrow
whitespace whitespace lparen
var: d
whitespace colon
whitespace lcurly
var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace var: device
whitespace lparen
var: dtable
comma
whitespace var: v
rparen
whitespace equalopwhitespace falsercurly
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace var: fwstate
whitespace pipe
lambdalparen
var: s
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
dotwhitespace var: fst
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: cstab
whitespace conjwhitespace lparen
var: s
whitespace equalopwhitespace var: snd
whitespace lparen
var: v
rparen
whitespace implieswhitespace whitespace var: device
lparen
var: s
comma
whitespace var: d
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace var: dsize
lparen
var: s
rparen
whitespace equalopwhitespace var: dsize
lparen
var: dtable
rparen
whitespace pluswhitespace int: 1
rparen
whitespace rcurly
semicolon
var: diff_device
whitespace colon
whitespace lparen
var: sr
whitespace colon
whitespace lbrace
var: srpair
rbrace
rparen
whitespace arrow
whitespace lparen
var: dtable
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lparen
var: d
whitespace colon
whitespace lcurly
var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace truercurly
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace var: device
lparen
var: dtable
comma
whitespace var: v
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace notwhitespace lbrace
var: v
equalopvar: d
rbrace
whitespace rcurly
semicolon
var: add_connection
whitespace colon
whitespace lparen
var: sr
whitespace colon
whitespace lbrace
var: srpair
rbrace
rparen
whitespace arrow
whitespace lparen
var: dtable
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lparen
var: s
whitespace colon
whitespace lcurly
var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace var: device
lparen
var: dtable
comma
whitespace var: v
rparen
whitespace equalopwhitespace truercurly
rparen
whitespace arrow
whitespace lparen
var: r
whitespace colon
whitespace lcurly
var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace var: device
lparen
var: dtable
comma
whitespace var: v
rparen
whitespace equalopwhitespace truercurly
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace var: fwstate
whitespace pipe
whitespace lambdalparen
var: f
whitespace colon
whitespace lbrace
var: srpair
rbrace
rparen
dotwhitespace var: snd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: dtable
whitespace conjwhitespace lparen
var: f
whitespace equalopwhitespace var: fst
whitespace lparen
var: v
rparen
whitespace implieswhitespace var: cansend
lparen
var: f
comma
whitespace var: s
comma
whitespace var: r
rparen
whitespace equalopwhitespace truerparen
whitespace rcurly
semicolon
var: make_central
whitespace colon
whitespace lparen
var: sr
whitespace colon
whitespace lbrace
var: srpair
rbrace
rparen
whitespace arrow
whitespace lparen
var: dtable
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lparen
var: d
whitespace colon
whitespace lcurly
var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace var: device
lparen
var: dtable
comma
whitespace var: v
rparen
whitespace equalopwhitespace truercurly
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace var: fwstate
whitespace pipe
lambdalparen
var: f
whitespace colon
whitespace lbrace
var: srpair
rbrace
rparen
dotwhitespace var: snd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: dtable
whitespace conjwhitespace lparen
var: f
whitespace equalopwhitespace var: fst
whitespace lparen
var: v
rparen
whitespace implieswhitespace var: central
lparen
var: f
comma
whitespace var: d
rparen
whitespace equalopwhitespace truerparen
whitespace rcurly
semicolon
var: delete_device
whitespace colon
whitespace lparen
var: sr
whitespace colon
whitespace lbrace
var: srpair
rbrace
rparen
whitespace arrow
whitespace lparen
var: dtable
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lparen
var: d
whitespace colon
whitespace lcurly
var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace truercurly
rparen
whitespace arrow
whitespace lparen
var: y
whitespace colon
whitespace lcurly
var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace notwhitespace lbrace
var: v
whitespace equalopwhitespace var: d
rbrace
whitespace conjwhitespace var: device
lparen
var: dtable
comma
whitespace var: v
rparen
whitespace equalopwhitespace truewhitespace whitespace conjwhitespace var: central
lparen
var: sr
comma
whitespace var: v
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace whitespace var: device
lparen
var: dtable
comma
whitespace var: d
rparen
equalopwhitespace truercurly
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace var: fwstate
whitespace pipe
lambdalparen
var: f
whitespace colon
whitespace lbrace
var: srpair
rbrace
rparen
comma
whitespace lparen
var: s
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
dotwhitespace lparen
var: f
whitespace equalopwhitespace var: fst
whitespace lparen
var: v
rparen
whitespace conjwhitespace var: s
whitespace equalopwhitespace var: snd
whitespace lparen
var: v
rparen
rparen
whitespace implieswhitespace whitespace lparen
var: device
lparen
var: s
comma
whitespace var: d
rparen
whitespace equalopwhitespace falsewhitespace conjwhitespace var: central
lparen
var: f
comma
whitespace var: y
rparen
whitespace equalopwhitespace truewhitespace rparen
rcurly
semicolon
var: select
whitespace colon
whitespace lparen
var: db
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
rparen
whitespace arrow
whitespace lparen
var: n
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lparen
var: u
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace var: nlrecord
whitespace pipe
whitespace var: nlmem
lparen
var: db
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace var: nletter
lparen
var: v
rparen
whitespace equalopwhitespace var: n
whitespace conjwhitespace var: user
lparen
var: v
rparen
whitespace equalopwhitespace var: u
whitespace rcurly
semicolon
var: nlmem
whitespace colon
whitespace lparen
var: db
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
rparen
whitespace arrow
whitespace lparen
var: n
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lparen
var: u
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace var: bool
whitespace pipe
whitespace lparen
var: v
whitespace equalopwhitespace truewhitespace iffwhitespace var: nlmem
lparen
var: db
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace truerparen
whitespace conjwhitespace lparen
var: v
whitespace equalopwhitespace falsewhitespace iffwhitespace var: nlmem
lparen
var: db
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace falserparen
whitespace rcurly
semicolon
var: subscribe
whitespace colon
whitespace lparen
var: db
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
rparen
whitespace arrow
whitespace lparen
var: n
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lparen
var: u
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
whitespace pipe
whitespace var: nlmem
lparen
var: db
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace falsewhitespace conjwhitespace var: nlmem
lparen
var: v
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace var: subscribed
lparen
var: v
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace truewhitespace rcurly
semicolon
var: unsubscribe
whitespace colon
whitespace lparen
var: db
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
rparen
whitespace arrow
whitespace lparen
var: n
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lparen
var: u
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
whitespace pipe
whitespace var: nlmem
lparen
var: db
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace var: nlmem
lparen
var: v
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace var: subscribed
lparen
var: v
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace falsewhitespace rcurly
semicolon
var: confirm
whitespace colon
whitespace lparen
var: db
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
rparen
whitespace arrow
whitespace lparen
var: c
whitespace colon
whitespace var: code
rparen
whitespace arrow
whitespace lparen
var: n
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lparen
var: u
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
whitespace pipe
whitespace var: nlmem
lparen
var: db
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace lparen
lparen
var: c
whitespace equalopwhitespace var: Cs
whitespace implieswhitespace var: subscribed
lparen
var: v
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace truerparen
whitespace conjwhitespace lparen
var: c
whitespace equalopwhitespace var: Cu
whitespace implieswhitespace var: subscribed
lparen
var: v
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace falserparen
rparen
whitespace rcurly
semicolon
whitespace var: read
whitespace colon
whitespace lparen
var: db
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
rparen
whitespace arrow
whitespace lparen
var: n
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lparen
var: u
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace lbrace
var: string
rbrace
whitespace pipe
whitespace var: nlmem
lparen
var: db
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace var: subscribed
lparen
var: v
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace var: v
whitespace equalopwhitespace var: articles
lparen
var: v
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace rcurly
semicolon
whitespace var: remove
whitespace colon
whitespace lparen
var: db
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
rparen
whitespace arrow
whitespace lparen
var: n
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lparen
var: u
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
whitespace pipe
whitespace var: nlmem
lparen
var: v
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace falsercurly
semicolon
var: goal
whitespace colon
whitespace whitespace lparen
var: n
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lparen
var: u
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace whitespace lparen
var: d
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
rparen
whitespace arrow
whitespace whitespace lcurly
var: v
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
whitespace pipe
whitespace var: subscribed
whitespace lparen
var: v
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace falsewhitespace conjwhitespace var: nlmem
whitespace lparen
var: v
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace falsewhitespace conjwhitespace var: promotions
whitespace lparen
var: v
comma
whitespace var: u
rparen
whitespace equalopwhitespace truewhitespace implieswhitespace lparen
var: email
whitespace lparen
var: v
comma
whitespace var: u
rparen
whitespace equalopwhitespace truerparen
rcurly
semicolon
RelSpec {  SRs ;  PRs ;  TSs  
 Assume false
 name add_device : 
 params :
 Type  Arrow ( ( dtable : {var_v0:Ty_list int | true} ) ->  Arrow ( ( cstab : {var_v1:Ty_list int srpair | true} ) ->  Arrow ( ( d : {v:int | (device)( , dtable, v ) = (false)} ) -> {v:int fwstate | Forall 
 	 
 Key =s Value = Ty_list int{ 
 	 Conj <c (fst)(v) = (cstab)
 	 , 
 	 Impl < (s) = (snd)(v)
 	 
 	 Conj <c (device)( , s, d ) = (true)
 	 , (dsize)(s) = ((dsize)(dtable) + (1)) >c  > >c  }} 
 Assume false
 name diff_device : 
 params :
 Type  Arrow ( ( sr : {var_v2:Ty_list int srpair | true} ) ->  Arrow ( ( dtable : {var_v3:Ty_list int | true} ) ->  Arrow ( ( d : {v:int | true} ) -> {v:int | 
 	 Conj <c (device)( , dtable, v ) = (true)
 	 , Negation v = d >c } 
 Assume false
 name add_connection : 
 params :
 Type  Arrow ( ( sr : {var_v4:Ty_list int srpair | true} ) ->  Arrow ( ( dtable : {var_v5:Ty_list int | true} ) ->  Arrow ( ( s : {v:int | (device)( , dtable, v ) = (true)} ) ->  Arrow ( ( r : {v:int | (device)( , dtable, v ) = (true)} ) -> {v:int fwstate | Forall 
 	 
 Key =f Value = Ty_list int srpair{ 
 	 Conj <c (snd)(v) = (dtable)
 	 , 
 	 Impl < (f) = (fst)(v)
 	 (cansend)( , f, s, r ) = (true) > >c  }} 
 Assume false
 name make_central : 
 params :
 Type  Arrow ( ( sr : {var_v6:Ty_list int srpair | true} ) ->  Arrow ( ( dtable : {var_v7:Ty_list int | true} ) ->  Arrow ( ( d : {v:int | (device)( , dtable, v ) = (true)} ) -> {v:int fwstate | Forall 
 	 
 Key =f Value = Ty_list int srpair{ 
 	 Conj <c (snd)(v) = (dtable)
 	 , 
 	 Impl < (f) = (fst)(v)
 	 (central)( , f, d ) = (true) > >c  }} 
 Assume false
 name delete_device : 
 params :
 Type  Arrow ( ( sr : {var_v8:Ty_list int srpair | true} ) ->  Arrow ( ( dtable : {var_v9:Ty_list int | true} ) ->  Arrow ( ( d : {v:int | true} ) ->  Arrow ( ( y : {v:int | 
 	 Conj <c Negation v = d
 	 , 
 	 Conj <c (device)( , dtable, v ) = (true)
 	 , 
 	 Conj <c (central)( , sr, v ) = (true)
 	 , (device)( , dtable, d ) = (true) >c  >c  >c } ) -> {v:int fwstate | Forall 
 	 
 Key =f Value = Ty_list int srpair
 Key =s Value = Ty_list int{ 
 	 Impl < 
 	 Conj <c (f) = (fst)(v)
 	 , (s) = (snd)(v) >c 
 	 
 	 Conj <c (device)( , s, d ) = (false)
 	 , (central)( , f, y ) = (true) >c  > }} 
 Assume false
 name select : 
 params :
 Type  Arrow ( ( db : {var_v10:Ty_list int nlrecord | true} ) ->  Arrow ( ( n : {var_v11:Ty_string | true} ) ->  Arrow ( ( u : {var_v12:Ty_string | true} ) -> {v:int nlrecord | 
 	 Conj <c (nlmem)( , db, n, u ) = (true)
 	 , 
 	 Conj <c (nletter)(v) = (n)
 	 , (user)(v) = (u) >c  >c } 
 Assume false
 name nlmem : 
 params :
 Type  Arrow ( ( db : {var_v13:Ty_list int nlrecord | true} ) ->  Arrow ( ( n : {var_v14:Ty_string | true} ) ->  Arrow ( ( u : {var_v15:Ty_string | true} ) -> {v:Ty_bool | 
 	 Conj <c DoubleImpl 
 (v) = (true)
  (nlmem)( , db, n, u ) = (true)
 	 , DoubleImpl 
 (v) = (false)
  (nlmem)( , db, n, u ) = (false) >c } 
 Assume false
 name subscribe : 
 params :
 Type  Arrow ( ( db : {var_v16:Ty_list int nlrecord | true} ) ->  Arrow ( ( n : {var_v17:Ty_string | true} ) ->  Arrow ( ( u : {var_v18:Ty_string | true} ) -> {v:Ty_list int nlrecord | 
 	 Conj <c (nlmem)( , db, n, u ) = (false)
 	 , 
 	 Conj <c (nlmem)( , v, n, u ) = (true)
 	 , (subscribed)( , v, n, u ) = (true) >c  >c } 
 Assume false
 name unsubscribe : 
 params :
 Type  Arrow ( ( db : {var_v19:Ty_list int nlrecord | true} ) ->  Arrow ( ( n : {var_v20:Ty_string | true} ) ->  Arrow ( ( u : {var_v21:Ty_string | true} ) -> {v:Ty_list int nlrecord | 
 	 Conj <c (nlmem)( , db, n, u ) = (true)
 	 , 
 	 Conj <c (nlmem)( , v, n, u ) = (true)
 	 , (subscribed)( , v, n, u ) = (false) >c  >c } 
 Assume false
 name confirm : 
 params :
 Type  Arrow ( ( db : {var_v22:Ty_list int nlrecord | true} ) ->  Arrow ( ( c : {var_v23:int code | true} ) ->  Arrow ( ( n : {var_v24:Ty_string | true} ) ->  Arrow ( ( u : {var_v25:Ty_string | true} ) -> {v:Ty_list int nlrecord | 
 	 Conj <c (nlmem)( , db, n, u ) = (true)
 	 , 
 	 Conj <c 
 	 Impl < (c) = (Cs)
 	 (subscribed)( , v, n, u ) = (true) >
 	 , 
 	 Impl < (c) = (Cu)
 	 (subscribed)( , v, n, u ) = (false) > >c  >c } 
 Assume false
 name read : 
 params :
 Type  Arrow ( ( db : {var_v26:Ty_list int nlrecord | true} ) ->  Arrow ( ( n : {var_v27:Ty_string | true} ) ->  Arrow ( ( u : {var_v28:Ty_string | true} ) -> {v:Ty_list Ty_string | 
 	 Conj <c (nlmem)( , db, n, u ) = (true)
 	 , 
 	 Conj <c (subscribed)( , v, n, u ) = (true)
 	 , (v) = (articles)( , v, n, u ) >c  >c } 
 Assume false
 name remove : 
 params :
 Type  Arrow ( ( db : {var_v29:Ty_list int nlrecord | true} ) ->  Arrow ( ( n : {var_v30:Ty_string | true} ) ->  Arrow ( ( u : {var_v31:Ty_string | true} ) -> {v:Ty_list int nlrecord | (nlmem)( , v, n, u ) = (false)} 
 Assume false
 name goal : 
 params :
 Type  Arrow ( ( n : {var_v32:Ty_string | true} ) ->  Arrow ( ( u : {var_v33:Ty_string | true} ) ->  Arrow ( ( d : {var_v34:Ty_list int nlrecord | true} ) -> {v:Ty_list int nlrecord | 
 	 Conj <c (subscribed)( , v, n, u ) = (false)
 	 , 
 	 Conj <c (nlmem)( , v, n, u ) = (false)
 	 , 
 	 Impl < (promotions)( , v, u ) = (true)
 	 (email)( , v, u ) = (true) > >c  >c };  Formulas  }
 INITIAL GAMMA 
 
 goal :  Arrow ( ( n : {var_v32:Ty_string | true} ) ->  Arrow ( ( u : {var_v33:Ty_string | true} ) ->  Arrow ( ( d : {var_v34:Ty_list int nlrecord | true} ) -> {v:Ty_list int nlrecord | 
 	 Conj <c (subscribed)( , v, n, u ) = (false)
 	 , 
 	 Conj <c (nlmem)( , v, n, u ) = (false)
 	 , 
 	 Impl < (promotions)( , v, u ) = (true)
 	 (email)( , v, u ) = (true) > >c  >c }
 remove :  Arrow ( ( db : {var_v29:Ty_list int nlrecord | true} ) ->  Arrow ( ( n : {var_v30:Ty_string | true} ) ->  Arrow ( ( u : {var_v31:Ty_string | true} ) -> {v:Ty_list int nlrecord | (nlmem)( , v, n, u ) = (false)}
 read :  Arrow ( ( db : {var_v26:Ty_list int nlrecord | true} ) ->  Arrow ( ( n : {var_v27:Ty_string | true} ) ->  Arrow ( ( u : {var_v28:Ty_string | true} ) -> {v:Ty_list Ty_string | 
 	 Conj <c (nlmem)( , db, n, u ) = (true)
 	 , 
 	 Conj <c (subscribed)( , v, n, u ) = (true)
 	 , (v) = (articles)( , v, n, u ) >c  >c }
 confirm :  Arrow ( ( db : {var_v22:Ty_list int nlrecord | true} ) ->  Arrow ( ( c : {var_v23:int code | true} ) ->  Arrow ( ( n : {var_v24:Ty_string | true} ) ->  Arrow ( ( u : {var_v25:Ty_string | true} ) -> {v:Ty_list int nlrecord | 
 	 Conj <c (nlmem)( , db, n, u ) = (true)
 	 , 
 	 Conj <c 
 	 Impl < (c) = (Cs)
 	 (subscribed)( , v, n, u ) = (true) >
 	 , 
 	 Impl < (c) = (Cu)
 	 (subscribed)( , v, n, u ) = (false) > >c  >c }
 unsubscribe :  Arrow ( ( db : {var_v19:Ty_list int nlrecord | true} ) ->  Arrow ( ( n : {var_v20:Ty_string | true} ) ->  Arrow ( ( u : {var_v21:Ty_string | true} ) -> {v:Ty_list int nlrecord | 
 	 Conj <c (nlmem)( , db, n, u ) = (true)
 	 , 
 	 Conj <c (nlmem)( , v, n, u ) = (true)
 	 , (subscribed)( , v, n, u ) = (false) >c  >c }
 subscribe :  Arrow ( ( db : {var_v16:Ty_list int nlrecord | true} ) ->  Arrow ( ( n : {var_v17:Ty_string | true} ) ->  Arrow ( ( u : {var_v18:Ty_string | true} ) -> {v:Ty_list int nlrecord | 
 	 Conj <c (nlmem)( , db, n, u ) = (false)
 	 , 
 	 Conj <c (nlmem)( , v, n, u ) = (true)
 	 , (subscribed)( , v, n, u ) = (true) >c  >c }
 nlmem :  Arrow ( ( db : {var_v13:Ty_list int nlrecord | true} ) ->  Arrow ( ( n : {var_v14:Ty_string | true} ) ->  Arrow ( ( u : {var_v15:Ty_string | true} ) -> {v:Ty_bool | 
 	 Conj <c DoubleImpl 
 (v) = (true)
  (nlmem)( , db, n, u ) = (true)
 	 , DoubleImpl 
 (v) = (false)
  (nlmem)( , db, n, u ) = (false) >c }
 select :  Arrow ( ( db : {var_v10:Ty_list int nlrecord | true} ) ->  Arrow ( ( n : {var_v11:Ty_string | true} ) ->  Arrow ( ( u : {var_v12:Ty_string | true} ) -> {v:int nlrecord | 
 	 Conj <c (nlmem)( , db, n, u ) = (true)
 	 , 
 	 Conj <c (nletter)(v) = (n)
 	 , (user)(v) = (u) >c  >c }
 delete_device :  Arrow ( ( sr : {var_v8:Ty_list int srpair | true} ) ->  Arrow ( ( dtable : {var_v9:Ty_list int | true} ) ->  Arrow ( ( d : {v:int | true} ) ->  Arrow ( ( y : {v:int | 
 	 Conj <c Negation v = d
 	 , 
 	 Conj <c (device)( , dtable, v ) = (true)
 	 , 
 	 Conj <c (central)( , sr, v ) = (true)
 	 , (device)( , dtable, d ) = (true) >c  >c  >c } ) -> {v:int fwstate | Forall 
 	 
 Key =f Value = Ty_list int srpair
 Key =s Value = Ty_list int{ 
 	 Impl < 
 	 Conj <c (f) = (fst)(v)
 	 , (s) = (snd)(v) >c 
 	 
 	 Conj <c (device)( , s, d ) = (false)
 	 , (central)( , f, y ) = (true) >c  > }}
 make_central :  Arrow ( ( sr : {var_v6:Ty_list int srpair | true} ) ->  Arrow ( ( dtable : {var_v7:Ty_list int | true} ) ->  Arrow ( ( d : {v:int | (device)( , dtable, v ) = (true)} ) -> {v:int fwstate | Forall 
 	 
 Key =f Value = Ty_list int srpair{ 
 	 Conj <c (snd)(v) = (dtable)
 	 , 
 	 Impl < (f) = (fst)(v)
 	 (central)( , f, d ) = (true) > >c  }}
 add_connection :  Arrow ( ( sr : {var_v4:Ty_list int srpair | true} ) ->  Arrow ( ( dtable : {var_v5:Ty_list int | true} ) ->  Arrow ( ( s : {v:int | (device)( , dtable, v ) = (true)} ) ->  Arrow ( ( r : {v:int | (device)( , dtable, v ) = (true)} ) -> {v:int fwstate | Forall 
 	 
 Key =f Value = Ty_list int srpair{ 
 	 Conj <c (snd)(v) = (dtable)
 	 , 
 	 Impl < (f) = (fst)(v)
 	 (cansend)( , f, s, r ) = (true) > >c  }}
 diff_device :  Arrow ( ( sr : {var_v2:Ty_list int srpair | true} ) ->  Arrow ( ( dtable : {var_v3:Ty_list int | true} ) ->  Arrow ( ( d : {v:int | true} ) -> {v:int | 
 	 Conj <c (device)( , dtable, v ) = (true)
 	 , Negation v = d >c }
 add_device :  Arrow ( ( dtable : {var_v0:Ty_list int | true} ) ->  Arrow ( ( cstab : {var_v1:Ty_list int srpair | true} ) ->  Arrow ( ( d : {v:int | (device)( , dtable, v ) = (false)} ) -> {v:int fwstate | Forall 
 	 
 Key =s Value = Ty_list int{ 
 	 Conj <c (fst)(v) = (cstab)
 	 , 
 	 Impl < (s) = (snd)(v)
 	 
 	 Conj <c (device)( , s, d ) = (true)
 	 , (dsize)(s) = ((dsize)(dtable) + (1)) >c  > >c  }}
 INITIAL SIGMA 
 
 TypeNames 
 
 code
 user
 nlrecord
 srpair
 fwstate
 Qualifiers 
 
 Qual device :  :-> Ty_list int :-> int :-> Ty_bool
 Qual dsize :  :-> Ty_list int :-> int
 Qual lmem :  :-> Ty_list int a :-> int a :-> Ty_bool
 Qual lhd :  :-> Ty_list int a :-> int a
 Qual fst :  :-> int fwstate :-> Ty_list int srpair
 Qual snd :  :-> int fwstate :-> Ty_list int
 Qual central :  :-> Ty_list int srpair :-> int :-> Ty_bool
 Qual cansend :  :-> Ty_list int srpair :-> int :-> int :-> Ty_bool
 Qual is_central :  :-> int :-> Ty_bool
 Qual nlmem :  :-> Ty_list int nlrecord :-> Ty_string :-> Ty_string :-> Ty_bool
 Qual ns :  :-> Ty_list int nlrecord :-> Ty_string :-> Ty_string :-> int nlrecord
 Qual subscribed :  :-> int nlrecord :-> Ty_bool
 Qual nletter :  :-> int nlrecord :-> Ty_string
 Qual code :  :-> int nlrecord :-> int code
 Qual articles :  :-> int nlrecord :-> Ty_list Ty_string
 Qual email :  :-> Ty_list int nlrecord :-> int user :-> Ty_bool
 Qual promotions :  :-> Ty_list int nlrecord :-> int user :-> Ty_bool
 Show ***********Calling S-FUNC synthesize***************
 Show Uncurried , n:{var_v32:Ty_string | true}, u:{var_v33:Ty_string | true}, d:{var_v34:Ty_list int nlrecord | true} -> {v:Ty_list int nlrecord | 
 	 Conj <c (subscribed)( , v, n, u ) = (false)
 	 , 
 	 Conj <c (nlmem)( , v, n, u ) = (false)
 	 , 
 	 Impl < (promotions)( , v, u ) = (true)
 	 (email)( , v, u ) = (true) > >c  >c }
 Decreasing Measure n
 Decreasing Type {var_v32:Ty_string | true}
 Show Trying :: Top-level Match
 Show :: Synthesize Match {v:Ty_list int nlrecord | 
 	 Conj <c (subscribed)( , v, n, u ) = (false)
 	 , 
 	 Conj <c (nlmem)( , v, n, u ) = (false)
 	 , 
 	 Impl < (promotions)( , v, u ) = (true)
 	 (email)( , v, u ) = (true) > >c  >c }
 Show :: List Ty_string
 Show :: Non List Case
 Match-case failed :: Try Top-level If-then-else 
 **********************************************
 iSynthesize If-THEN-ELSE {v:Ty_list int nlrecord | 
 	 Conj <c (subscribed)( , v, n, u ) = (false)
 	 , 
 	 Conj <c (nlmem)( , v, n, u ) = (false)
 	 , 
 	 Impl < (promotions)( , v, u ) = (true)
 	 (email)( , v, u ) = (true) > >c  >c }
 **********************************************
  *********************Synthesizing the Guard*******************
 iSynthesize Boolean Guard {var_v35:Ty_bool | true}
  *********************Synthesizing the Guard*******************
 esynthesizeScalar for {var_v35:Ty_bool | true}
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
  *********************Guard Synthesized*******************
 iSynthesize Following Boolean Guards Found 
  ********************Guard Synthesized*******************
  If then else Failed :: Try without subdivision
 
  Entering Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  , 
 goal, 
 remove, 
 confirm, 
 unsubscribe, 
 subscribe
 ############################################################
  Synthesizing the Function application Pure Component goal
  *************** Trying Arrow Component ************goal :  Arrow ( ( n : {var_v32:Ty_string | true} ) ->  Arrow ( ( u : {var_v33:Ty_string | true} ) ->  Arrow ( ( d : {var_v34:Ty_list int nlrecord | true} ) -> {v:Ty_list int nlrecord | 
 	 Conj <c (subscribed)( , v, n, u ) = (false)
 	 , 
 	 Conj <c (nlmem)( , v, n, u ) = (false)
 	 , 
 	 Impl < (promotions)( , v, u ) = (true)
 	 (email)( , v, u ) = (true) > >c  >c }
  *************** Synthesizing Args ei : ti for ************goal
 ##################################################################################
  Synthesizing the 1th argument for Function goal
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v32:Ty_string | true}
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v32:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls goal
 ################################################
 
 Enumerating a Scalar Term u
 
 Type of the Scalar Term {var_v33:Ty_string | true}
 ################################################
 Skipping Variable u As this a  Formal Parameter to the current function Call
 Outer Function calls goal
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 Found Constructors with required return type
  
 ********************** HERE BEFORE 
 Show No more choices for ConsApp
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  
  DEPTH vs MAX  0 vs 2
 ##################################################################################
  Synthesizing the 2th argument for Function goal
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v33:Ty_string | true}
 
 Enumerating a Scalar Term u
 
 Type of the Scalar Term {var_v33:Ty_string | true}
 ################################################
 Skipping Variable u As this a  Formal Parameter to the current function Call
 Outer Function calls goal
 ################################################
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v32:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls goal
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 Found Constructors with required return type
  
 ********************** HERE BEFORE 
 Show No more choices for ConsApp
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  
  DEPTH vs MAX  0 vs 2
 ##################################################################################
  Synthesizing the 3th argument for Function goal
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v34:Ty_list int nlrecord | true}
 
 Enumerating a Scalar Term d
 
 Type of the Scalar Term {var_v34:Ty_list int nlrecord | true}
 ################################################
 Skipping Variable d As this a  Formal Parameter to the current function Call
 Outer Function calls goal
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  , 
 goal, 
 remove, 
 confirm, 
 unsubscribe, 
 subscribe
 ############################################################
  Synthesizing the Function application Pure Component goal
 ################################################
 Skipping Variable goal As Outer Function Call is goal
 ################################################
 ############################################################
  Synthesizing the Function application Pure Component remove
  *************** Trying Arrow Component ************remove :  Arrow ( ( db : {var_v29:Ty_list int nlrecord | true} ) ->  Arrow ( ( n : {var_v30:Ty_string | true} ) ->  Arrow ( ( u : {var_v31:Ty_string | true} ) -> {v:Ty_list int nlrecord | (nlmem)( , v, n, u ) = (false)}
  *************** Synthesizing Args ei : ti for ************remove
 ##################################################################################
  Synthesizing the 1th argument for Function remove
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v29:Ty_list int nlrecord | true}
 
 Enumerating a Scalar Term d
 
 Type of the Scalar Term {var_v34:Ty_list int nlrecord | true}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 1th Args option for remove : d
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 2th argument for Function remove
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v30:Ty_string | true}
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v32:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls remove
 ################################################
 
 Enumerating a Scalar Term u
 
 Type of the Scalar Term {var_v33:Ty_string | true}
 ################################################
 Skipping Variable u As this a  Formal Parameter to the current function Call
 Outer Function calls remove
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 3th argument for Function remove
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v31:Ty_string | true}
 
 Enumerating a Scalar Term u
 
 Type of the Scalar Term {var_v33:Ty_string | true}
 ################################################
 Skipping Variable u As this a  Formal Parameter to the current function Call
 Outer Function calls remove
 ################################################
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v30:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls remove
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  *************** Synthesizing Args ei : Failed for some  arg
 ############################################################
  Synthesizing the Function application Pure Component confirm
  *************** Trying Arrow Component ************confirm :  Arrow ( ( db : {var_v22:Ty_list int nlrecord | true} ) ->  Arrow ( ( c : {var_v23:int code | true} ) ->  Arrow ( ( n : {var_v24:Ty_string | true} ) ->  Arrow ( ( u : {var_v25:Ty_string | true} ) -> {v:Ty_list int nlrecord | 
 	 Conj <c (nlmem)( , db, n, u ) = (true)
 	 , 
 	 Conj <c 
 	 Impl < (c) = (Cs)
 	 (subscribed)( , v, n, u ) = (true) >
 	 , 
 	 Impl < (c) = (Cu)
 	 (subscribed)( , v, n, u ) = (false) > >c  >c }
  *************** Synthesizing Args ei : ti for ************confirm
 ##################################################################################
  Synthesizing the 1th argument for Function confirm
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v22:Ty_list int nlrecord | true}
 
 Enumerating a Scalar Term d
 
 Type of the Scalar Term {var_v34:Ty_list int nlrecord | true}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term db
 
 Type of the Scalar Term {var_v29:Ty_list int nlrecord | true}
 ################################################
 Skipping Variable db As this a  Formal Parameter to the current function Call
 Outer Function calls confirm
 ################################################
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 1th Args option for confirm : d
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 2th argument for Function confirm
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v23:int code | true}
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 3th argument for Function confirm
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v24:Ty_string | true}
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v30:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls confirm
 ################################################
 
 Enumerating a Scalar Term u
 
 Type of the Scalar Term {var_v31:Ty_string | true}
 ################################################
 Skipping Variable u As this a  Formal Parameter to the current function Call
 Outer Function calls confirm
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 4th argument for Function confirm
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v25:Ty_string | true}
 
 Enumerating a Scalar Term u
 
 Type of the Scalar Term {var_v31:Ty_string | true}
 ################################################
 Skipping Variable u As this a  Formal Parameter to the current function Call
 Outer Function calls confirm
 ################################################
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v24:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls confirm
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  *************** Synthesizing Args ei : Failed for some  arg
 ############################################################
  Synthesizing the Function application Pure Component unsubscribe
  *************** Trying Arrow Component ************unsubscribe :  Arrow ( ( db : {var_v19:Ty_list int nlrecord | true} ) ->  Arrow ( ( n : {var_v20:Ty_string | true} ) ->  Arrow ( ( u : {var_v21:Ty_string | true} ) -> {v:Ty_list int nlrecord | 
 	 Conj <c (nlmem)( , db, n, u ) = (true)
 	 , 
 	 Conj <c (nlmem)( , v, n, u ) = (true)
 	 , (subscribed)( , v, n, u ) = (false) >c  >c }
  *************** Synthesizing Args ei : ti for ************unsubscribe
 ##################################################################################
  Synthesizing the 1th argument for Function unsubscribe
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v19:Ty_list int nlrecord | true}
 
 Enumerating a Scalar Term d
 
 Type of the Scalar Term {var_v34:Ty_list int nlrecord | true}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term db
 
 Type of the Scalar Term {var_v22:Ty_list int nlrecord | true}
 ################################################
 Skipping Variable db As this a  Formal Parameter to the current function Call
 Outer Function calls unsubscribe
 ################################################
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 1th Args option for unsubscribe : d
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 2th argument for Function unsubscribe
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v20:Ty_string | true}
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v24:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls unsubscribe
 ################################################
 
 Enumerating a Scalar Term u
 
 Type of the Scalar Term {var_v25:Ty_string | true}
 ################################################
 Skipping Variable u As this a  Formal Parameter to the current function Call
 Outer Function calls unsubscribe
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 3th argument for Function unsubscribe
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v21:Ty_string | true}
 
 Enumerating a Scalar Term u
 
 Type of the Scalar Term {var_v25:Ty_string | true}
 ################################################
 Skipping Variable u As this a  Formal Parameter to the current function Call
 Outer Function calls unsubscribe
 ################################################
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v20:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls unsubscribe
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  *************** Synthesizing Args ei : Failed for some  arg
 ############################################################
  Synthesizing the Function application Pure Component subscribe
  *************** Trying Arrow Component ************subscribe :  Arrow ( ( db : {var_v16:Ty_list int nlrecord | true} ) ->  Arrow ( ( n : {var_v17:Ty_string | true} ) ->  Arrow ( ( u : {var_v18:Ty_string | true} ) -> {v:Ty_list int nlrecord | 
 	 Conj <c (nlmem)( , db, n, u ) = (false)
 	 , 
 	 Conj <c (nlmem)( , v, n, u ) = (true)
 	 , (subscribed)( , v, n, u ) = (true) >c  >c }
  *************** Synthesizing Args ei : ti for ************subscribe
 ##################################################################################
  Synthesizing the 1th argument for Function subscribe
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v16:Ty_list int nlrecord | true}
 
 Enumerating a Scalar Term d
 
 Type of the Scalar Term {var_v34:Ty_list int nlrecord | true}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term db
 
 Type of the Scalar Term {var_v19:Ty_list int nlrecord | true}
 ################################################
 Skipping Variable db As this a  Formal Parameter to the current function Call
 Outer Function calls subscribe
 ################################################
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 1th Args option for subscribe : d
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 2th argument for Function subscribe
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v17:Ty_string | true}
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v20:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls subscribe
 ################################################
 
 Enumerating a Scalar Term u
 
 Type of the Scalar Term {var_v21:Ty_string | true}
 ################################################
 Skipping Variable u As this a  Formal Parameter to the current function Call
 Outer Function calls subscribe
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 3th argument for Function subscribe
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v18:Ty_string | true}
 
 Enumerating a Scalar Term u
 
 Type of the Scalar Term {var_v21:Ty_string | true}
 ################################################
 Skipping Variable u As this a  Formal Parameter to the current function Call
 Outer Function calls subscribe
 ################################################
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v17:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls subscribe
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  *************** Synthesizing Args ei : Failed for some  arg
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 Found Constructors with required return type
  
 ********************** HERE BEFORE 
 Show No more choices for ConsApp
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  , 
 goal, 
 remove, 
 confirm, 
 unsubscribe, 
 subscribe
 ############################################################
  Synthesizing the Function application Pure Component goal
 ################################################
 Skipping Variable goal As Outer Function Call is goal
 ################################################
 ############################################################
  Synthesizing the Function application Pure Component remove
  *************** Trying Arrow Component ************remove :  Arrow ( ( db : {var_v29:Ty_list int nlrecord | true} ) ->  Arrow ( ( n : {var_v30:Ty_string | true} ) ->  Arrow ( ( u : {var_v31:Ty_string | true} ) -> {v:Ty_list int nlrecord | (nlmem)( , v, n, u ) = (false)}
  *************** Synthesizing Args ei : ti for ************remove
 ##################################################################################
  Synthesizing the 1th argument for Function remove
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v29:Ty_list int nlrecord | true}
 
 Enumerating a Scalar Term d
 
 Type of the Scalar Term {var_v34:Ty_list int nlrecord | true}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term db
 
 Type of the Scalar Term {var_v16:Ty_list int nlrecord | true}
 ################################################
 Skipping Variable db As this a  Formal Parameter to the current function Call
 Outer Function calls remove
 ################################################
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 1th Args option for remove : d
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 2th argument for Function remove
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v30:Ty_string | true}
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v17:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls remove
 ################################################
 
 Enumerating a Scalar Term u
 
 Type of the Scalar Term {var_v18:Ty_string | true}
 ################################################
 Skipping Variable u As this a  Formal Parameter to the current function Call
 Outer Function calls remove
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 3th argument for Function remove
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v31:Ty_string | true}
 
 Enumerating a Scalar Term u
 
 Type of the Scalar Term {var_v18:Ty_string | true}
 ################################################
 Skipping Variable u As this a  Formal Parameter to the current function Call
 Outer Function calls remove
 ################################################
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v30:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls remove
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  *************** Synthesizing Args ei : Failed for some  arg
 ############################################################
  Synthesizing the Function application Pure Component confirm
  *************** Trying Arrow Component ************confirm :  Arrow ( ( db : {var_v22:Ty_list int nlrecord | true} ) ->  Arrow ( ( c : {var_v23:int code | true} ) ->  Arrow ( ( n : {var_v24:Ty_string | true} ) ->  Arrow ( ( u : {var_v25:Ty_string | true} ) -> {v:Ty_list int nlrecord | 
 	 Conj <c (nlmem)( , db, n, u ) = (true)
 	 , 
 	 Conj <c 
 	 Impl < (c) = (Cs)
 	 (subscribed)( , v, n, u ) = (true) >
 	 , 
 	 Impl < (c) = (Cu)
 	 (subscribed)( , v, n, u ) = (false) > >c  >c }
  *************** Synthesizing Args ei : ti for ************confirm
 ##################################################################################
  Synthesizing the 1th argument for Function confirm
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v22:Ty_list int nlrecord | true}
 
 Enumerating a Scalar Term d
 
 Type of the Scalar Term {var_v34:Ty_list int nlrecord | true}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term db
 
 Type of the Scalar Term {var_v29:Ty_list int nlrecord | true}
 ################################################
 Skipping Variable db As this a  Formal Parameter to the current function Call
 Outer Function calls confirm
 ################################################
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 1th Args option for confirm : d
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 2th argument for Function confirm
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v23:int code | true}
 
 Enumerating a Scalar Term c
 
 Type of the Scalar Term {var_v23:int code | true}
 ################################################
 Skipping Variable c As this a  Formal Parameter to the current function Call
 Outer Function calls confirm
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 3th argument for Function confirm
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v24:Ty_string | true}
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v30:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls confirm
 ################################################
 
 Enumerating a Scalar Term u
 
 Type of the Scalar Term {var_v31:Ty_string | true}
 ################################################
 Skipping Variable u As this a  Formal Parameter to the current function Call
 Outer Function calls confirm
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 4th argument for Function confirm
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v25:Ty_string | true}
 
 Enumerating a Scalar Term u
 
 Type of the Scalar Term {var_v31:Ty_string | true}
 ################################################
 Skipping Variable u As this a  Formal Parameter to the current function Call
 Outer Function calls confirm
 ################################################
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v24:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls confirm
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  *************** Synthesizing Args ei : Failed for some  arg
 ############################################################
  Synthesizing the Function application Pure Component unsubscribe
  *************** Trying Arrow Component ************unsubscribe :  Arrow ( ( db : {var_v19:Ty_list int nlrecord | true} ) ->  Arrow ( ( n : {var_v20:Ty_string | true} ) ->  Arrow ( ( u : {var_v21:Ty_string | true} ) -> {v:Ty_list int nlrecord | 
 	 Conj <c (nlmem)( , db, n, u ) = (true)
 	 , 
 	 Conj <c (nlmem)( , v, n, u ) = (true)
 	 , (subscribed)( , v, n, u ) = (false) >c  >c }
  *************** Synthesizing Args ei : ti for ************unsubscribe
 ##################################################################################
  Synthesizing the 1th argument for Function unsubscribe
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v19:Ty_list int nlrecord | true}
 
 Enumerating a Scalar Term d
 
 Type of the Scalar Term {var_v34:Ty_list int nlrecord | true}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term db
 
 Type of the Scalar Term {var_v22:Ty_list int nlrecord | true}
 ################################################
 Skipping Variable db As this a  Formal Parameter to the current function Call
 Outer Function calls unsubscribe
 ################################################
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 1th Args option for unsubscribe : d
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 2th argument for Function unsubscribe
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v20:Ty_string | true}
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v24:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls unsubscribe
 ################################################
 
 Enumerating a Scalar Term u
 
 Type of the Scalar Term {var_v25:Ty_string | true}
 ################################################
 Skipping Variable u As this a  Formal Parameter to the current function Call
 Outer Function calls unsubscribe
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 3th argument for Function unsubscribe
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v21:Ty_string | true}
 
 Enumerating a Scalar Term u
 
 Type of the Scalar Term {var_v25:Ty_string | true}
 ################################################
 Skipping Variable u As this a  Formal Parameter to the current function Call
 Outer Function calls unsubscribe
 ################################################
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v20:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls unsubscribe
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  *************** Synthesizing Args ei : Failed for some  arg
 ############################################################
  Synthesizing the Function application Pure Component subscribe
  *************** Trying Arrow Component ************subscribe :  Arrow ( ( db : {var_v16:Ty_list int nlrecord | true} ) ->  Arrow ( ( n : {var_v17:Ty_string | true} ) ->  Arrow ( ( u : {var_v18:Ty_string | true} ) -> {v:Ty_list int nlrecord | 
 	 Conj <c (nlmem)( , db, n, u ) = (false)
 	 , 
 	 Conj <c (nlmem)( , v, n, u ) = (true)
 	 , (subscribed)( , v, n, u ) = (true) >c  >c }
  *************** Synthesizing Args ei : ti for ************subscribe
 ##################################################################################
  Synthesizing the 1th argument for Function subscribe
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v16:Ty_list int nlrecord | true}
 
 Enumerating a Scalar Term d
 
 Type of the Scalar Term {var_v34:Ty_list int nlrecord | true}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term db
 
 Type of the Scalar Term {var_v19:Ty_list int nlrecord | true}
 ################################################
 Skipping Variable db As this a  Formal Parameter to the current function Call
 Outer Function calls subscribe
 ################################################
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 1th Args option for subscribe : d
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 2th argument for Function subscribe
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v17:Ty_string | true}
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v20:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls subscribe
 ################################################
 
 Enumerating a Scalar Term u
 
 Type of the Scalar Term {var_v21:Ty_string | true}
 ################################################
 Skipping Variable u As this a  Formal Parameter to the current function Call
 Outer Function calls subscribe
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 3th argument for Function subscribe
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v18:Ty_string | true}
 
 Enumerating a Scalar Term u
 
 Type of the Scalar Term {var_v21:Ty_string | true}
 ################################################
 Skipping Variable u As this a  Formal Parameter to the current function Call
 Outer Function calls subscribe
 ################################################
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v17:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls subscribe
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  *************** Synthesizing Args ei : Failed for some  arg
  DEPTH vs MAX  0 vs 2
 ##################################################################################
  *************** Synthesizing Args ei : Failed for some  arg
 ############################################################
  Synthesizing the Function application Pure Component remove
  *************** Trying Arrow Component ************remove :  Arrow ( ( db : {var_v29:Ty_list int nlrecord | true} ) ->  Arrow ( ( n : {var_v30:Ty_string | true} ) ->  Arrow ( ( u : {var_v31:Ty_string | true} ) -> {v:Ty_list int nlrecord | (nlmem)( , v, n, u ) = (false)}
  *************** Synthesizing Args ei : ti for ************remove
 ##################################################################################
  Synthesizing the 1th argument for Function remove
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v29:Ty_list int nlrecord | true}
 
 Enumerating a Scalar Term db
 
 Type of the Scalar Term {var_v16:Ty_list int nlrecord | true}
 ################################################
 Skipping Variable db As this a  Formal Parameter to the current function Call
 Outer Function calls remove
 ################################################
 
 Enumerating a Scalar Term d
 
 Type of the Scalar Term {var_v34:Ty_list int nlrecord | true}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  , 
 goal, 
 remove, 
 confirm, 
 unsubscribe, 
 subscribe
 ############################################################
  Synthesizing the Function application Pure Component goal
  *************** Trying Arrow Component ************goal :  Arrow ( ( n : {var_v32:Ty_string | true} ) ->  Arrow ( ( u : {var_v33:Ty_string | true} ) ->  Arrow ( ( d : {var_v34:Ty_list int nlrecord | true} ) -> {v:Ty_list int nlrecord | 
 	 Conj <c (subscribed)( , v, n, u ) = (false)
 	 , 
 	 Conj <c (nlmem)( , v, n, u ) = (false)
 	 , 
 	 Impl < (promotions)( , v, u ) = (true)
 	 (email)( , v, u ) = (true) > >c  >c }
  *************** Synthesizing Args ei : ti for ************goal
 ##################################################################################
  Synthesizing the 1th argument for Function goal
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v32:Ty_string | true}
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v17:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls goal
 ################################################
 
 Enumerating a Scalar Term u
 
 Type of the Scalar Term {var_v18:Ty_string | true}
 ################################################
 Skipping Variable u As this a  Formal Parameter to the current function Call
 Outer Function calls goal
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 2th argument for Function goal
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v33:Ty_string | true}
 
 Enumerating a Scalar Term u
 
 Type of the Scalar Term {var_v18:Ty_string | true}
 ################################################
 Skipping Variable u As this a  Formal Parameter to the current function Call
 Outer Function calls goal
 ################################################
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v32:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls goal
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 3th argument for Function goal
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v34:Ty_list int nlrecord | true}
 
 Enumerating a Scalar Term db
 
 Type of the Scalar Term {var_v16:Ty_list int nlrecord | true}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term d
 
 Type of the Scalar Term {var_v34:Ty_list int nlrecord | true}
 ################################################
 Skipping Variable d As this a  Formal Parameter to the current function Call
 Outer Function calls goal
 ################################################
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 3th Args option for goal : db
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  *************** Synthesizing Args ei : Failed for some  arg
 ############################################################
  Synthesizing the Function application Pure Component remove
  *************** Trying Arrow Component ************remove :  Arrow ( ( db : {var_v29:Ty_list int nlrecord | true} ) ->  Arrow ( ( n : {var_v30:Ty_string | true} ) ->  Arrow ( ( u : {var_v31:Ty_string | true} ) -> {v:Ty_list int nlrecord | (nlmem)( , v, n, u ) = (false)}
  *************** Synthesizing Args ei : ti for ************remove
 ##################################################################################
  Synthesizing the 1th argument for Function remove
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v29:Ty_list int nlrecord | true}
 
 Enumerating a Scalar Term db
 
 Type of the Scalar Term {var_v16:Ty_list int nlrecord | true}
 ################################################
 Skipping Variable db As this a  Formal Parameter to the current function Call
 Outer Function calls remove
 ################################################
 
 Enumerating a Scalar Term d
 
 Type of the Scalar Term {var_v34:Ty_list int nlrecord | true}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 1th Args option for remove : d
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 2th argument for Function remove
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v30:Ty_string | true}
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v32:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls remove
 ################################################
 
 Enumerating a Scalar Term u
 
 Type of the Scalar Term {var_v33:Ty_string | true}
 ################################################
 Skipping Variable u As this a  Formal Parameter to the current function Call
 Outer Function calls remove
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 3th argument for Function remove
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v31:Ty_string | true}
 
 Enumerating a Scalar Term u
 
 Type of the Scalar Term {var_v33:Ty_string | true}
 ################################################
 Skipping Variable u As this a  Formal Parameter to the current function Call
 Outer Function calls remove
 ################################################
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v30:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls remove
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  *************** Synthesizing Args ei : Failed for some  arg
 ############################################################
  Synthesizing the Function application Pure Component confirm
  *************** Trying Arrow Component ************confirm :  Arrow ( ( db : {var_v22:Ty_list int nlrecord | true} ) ->  Arrow ( ( c : {var_v23:int code | true} ) ->  Arrow ( ( n : {var_v24:Ty_string | true} ) ->  Arrow ( ( u : {var_v25:Ty_string | true} ) -> {v:Ty_list int nlrecord | 
 	 Conj <c (nlmem)( , db, n, u ) = (true)
 	 , 
 	 Conj <c 
 	 Impl < (c) = (Cs)
 	 (subscribed)( , v, n, u ) = (true) >
 	 , 
 	 Impl < (c) = (Cu)
 	 (subscribed)( , v, n, u ) = (false) > >c  >c }
  *************** Synthesizing Args ei : ti for ************confirm
 ##################################################################################
  Synthesizing the 1th argument for Function confirm
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v22:Ty_list int nlrecord | true}
 
 Enumerating a Scalar Term d
 
 Type of the Scalar Term {var_v34:Ty_list int nlrecord | true}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term db
 
 Type of the Scalar Term {var_v29:Ty_list int nlrecord | true}
 ################################################
 Skipping Variable db As this a  Formal Parameter to the current function Call
 Outer Function calls confirm
 ################################################
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 1th Args option for confirm : d
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 2th argument for Function confirm
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v23:int code | true}
 
 Enumerating a Scalar Term c
 
 Type of the Scalar Term {var_v23:int code | true}
 ################################################
 Skipping Variable c As this a  Formal Parameter to the current function Call
 Outer Function calls confirm
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 3th argument for Function confirm
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v24:Ty_string | true}
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v30:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls confirm
 ################################################
 
 Enumerating a Scalar Term u
 
 Type of the Scalar Term {var_v31:Ty_string | true}
 ################################################
 Skipping Variable u As this a  Formal Parameter to the current function Call
 Outer Function calls confirm
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 4th argument for Function confirm
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v25:Ty_string | true}
 
 Enumerating a Scalar Term u
 
 Type of the Scalar Term {var_v31:Ty_string | true}
 ################################################
 Skipping Variable u As this a  Formal Parameter to the current function Call
 Outer Function calls confirm
 ################################################
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v24:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls confirm
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  *************** Synthesizing Args ei : Failed for some  arg
 ############################################################
  Synthesizing the Function application Pure Component unsubscribe
  *************** Trying Arrow Component ************unsubscribe :  Arrow ( ( db : {var_v19:Ty_list int nlrecord | true} ) ->  Arrow ( ( n : {var_v20:Ty_string | true} ) ->  Arrow ( ( u : {var_v21:Ty_string | true} ) -> {v:Ty_list int nlrecord | 
 	 Conj <c (nlmem)( , db, n, u ) = (true)
 	 , 
 	 Conj <c (nlmem)( , v, n, u ) = (true)
 	 , (subscribed)( , v, n, u ) = (false) >c  >c }
  *************** Synthesizing Args ei : ti for ************unsubscribe
 ##################################################################################
  Synthesizing the 1th argument for Function unsubscribe
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v19:Ty_list int nlrecord | true}
 
 Enumerating a Scalar Term d
 
 Type of the Scalar Term {var_v34:Ty_list int nlrecord | true}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term db
 
 Type of the Scalar Term {var_v22:Ty_list int nlrecord | true}
 ################################################
 Skipping Variable db As this a  Formal Parameter to the current function Call
 Outer Function calls unsubscribe
 ################################################
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 1th Args option for unsubscribe : d
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 2th argument for Function unsubscribe
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v20:Ty_string | true}
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v24:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls unsubscribe
 ################################################
 
 Enumerating a Scalar Term u
 
 Type of the Scalar Term {var_v25:Ty_string | true}
 ################################################
 Skipping Variable u As this a  Formal Parameter to the current function Call
 Outer Function calls unsubscribe
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 3th argument for Function unsubscribe
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v21:Ty_string | true}
 
 Enumerating a Scalar Term u
 
 Type of the Scalar Term {var_v25:Ty_string | true}
 ################################################
 Skipping Variable u As this a  Formal Parameter to the current function Call
 Outer Function calls unsubscribe
 ################################################
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v20:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls unsubscribe
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  *************** Synthesizing Args ei : Failed for some  arg
 ############################################################
  Synthesizing the Function application Pure Component subscribe
  *************** Trying Arrow Component ************subscribe :  Arrow ( ( db : {var_v16:Ty_list int nlrecord | true} ) ->  Arrow ( ( n : {var_v17:Ty_string | true} ) ->  Arrow ( ( u : {var_v18:Ty_string | true} ) -> {v:Ty_list int nlrecord | 
 	 Conj <c (nlmem)( , db, n, u ) = (false)
 	 , 
 	 Conj <c (nlmem)( , v, n, u ) = (true)
 	 , (subscribed)( , v, n, u ) = (true) >c  >c }
  *************** Synthesizing Args ei : ti for ************subscribe
 ##################################################################################
  Synthesizing the 1th argument for Function subscribe
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v16:Ty_list int nlrecord | true}
 
 Enumerating a Scalar Term d
 
 Type of the Scalar Term {var_v34:Ty_list int nlrecord | true}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term db
 
 Type of the Scalar Term {var_v19:Ty_list int nlrecord | true}
 ################################################
 Skipping Variable db As this a  Formal Parameter to the current function Call
 Outer Function calls subscribe
 ################################################
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 1th Args option for subscribe : d
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 2th argument for Function subscribe
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v17:Ty_string | true}
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v20:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls subscribe
 ################################################
 
 Enumerating a Scalar Term u
 
 Type of the Scalar Term {var_v21:Ty_string | true}
 ################################################
 Skipping Variable u As this a  Formal Parameter to the current function Call
 Outer Function calls subscribe
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 3th argument for Function subscribe
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v18:Ty_string | true}
 
 Enumerating a Scalar Term u
 
 Type of the Scalar Term {var_v21:Ty_string | true}
 ################################################
 Skipping Variable u As this a  Formal Parameter to the current function Call
 Outer Function calls subscribe
 ################################################
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v17:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls subscribe
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  *************** Synthesizing Args ei : Failed for some  arg
 >>>>>>>>>>>>>>>>>>> 1th Args option for remove : d
  DEPTH vs MAX  0 vs 2
 ##################################################################################
  Synthesizing the 2th argument for Function remove
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v30:Ty_string | true}
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v17:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls remove
 ################################################
 
 Enumerating a Scalar Term u
 
 Type of the Scalar Term {var_v18:Ty_string | true}
 ################################################
 Skipping Variable u As this a  Formal Parameter to the current function Call
 Outer Function calls remove
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 Found Constructors with required return type
  
 ********************** HERE BEFORE 
 Show No more choices for ConsApp
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  
  DEPTH vs MAX  0 vs 2
 ##################################################################################
  Synthesizing the 3th argument for Function remove
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v31:Ty_string | true}
 
 Enumerating a Scalar Term u
 
 Type of the Scalar Term {var_v18:Ty_string | true}
 ################################################
 Skipping Variable u As this a  Formal Parameter to the current function Call
 Outer Function calls remove
 ################################################
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v30:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls remove
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 Found Constructors with required return type
  
 ********************** HERE BEFORE 
 Show No more choices for ConsApp
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  
  DEPTH vs MAX  0 vs 2
 ##################################################################################
  *************** Synthesizing Args ei : Failed for some  arg
 ############################################################
  Synthesizing the Function application Pure Component confirm
  *************** Trying Arrow Component ************confirm :  Arrow ( ( db : {var_v22:Ty_list int nlrecord | true} ) ->  Arrow ( ( c : {var_v23:int code | true} ) ->  Arrow ( ( n : {var_v24:Ty_string | true} ) ->  Arrow ( ( u : {var_v25:Ty_string | true} ) -> {v:Ty_list int nlrecord | 
 	 Conj <c (nlmem)( , db, n, u ) = (true)
 	 , 
 	 Conj <c 
 	 Impl < (c) = (Cs)
 	 (subscribed)( , v, n, u ) = (true) >
 	 , 
 	 Impl < (c) = (Cu)
 	 (subscribed)( , v, n, u ) = (false) > >c  >c }
  *************** Synthesizing Args ei : ti for ************confirm
 ##################################################################################
  Synthesizing the 1th argument for Function confirm
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v22:Ty_list int nlrecord | true}
 
 Enumerating a Scalar Term d
 
 Type of the Scalar Term {var_v34:Ty_list int nlrecord | true}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term db
 
 Type of the Scalar Term {var_v29:Ty_list int nlrecord | true}
 ################################################
 Skipping Variable db As this a  Formal Parameter to the current function Call
 Outer Function calls confirm
 ################################################
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  , 
 goal, 
 remove, 
 confirm, 
 unsubscribe, 
 subscribe
 ############################################################
  Synthesizing the Function application Pure Component goal
  *************** Trying Arrow Component ************goal :  Arrow ( ( n : {var_v32:Ty_string | true} ) ->  Arrow ( ( u : {var_v33:Ty_string | true} ) ->  Arrow ( ( d : {var_v34:Ty_list int nlrecord | true} ) -> {v:Ty_list int nlrecord | 
 	 Conj <c (subscribed)( , v, n, u ) = (false)
 	 , 
 	 Conj <c (nlmem)( , v, n, u ) = (false)
 	 , 
 	 Impl < (promotions)( , v, u ) = (true)
 	 (email)( , v, u ) = (true) > >c  >c }
  *************** Synthesizing Args ei : ti for ************goal
 ##################################################################################
  Synthesizing the 1th argument for Function goal
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v32:Ty_string | true}
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v30:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls goal
 ################################################
 
 Enumerating a Scalar Term u
 
 Type of the Scalar Term {var_v31:Ty_string | true}
 ################################################
 Skipping Variable u As this a  Formal Parameter to the current function Call
 Outer Function calls goal
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 2th argument for Function goal
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v33:Ty_string | true}
 
 Enumerating a Scalar Term u
 
 Type of the Scalar Term {var_v31:Ty_string | true}
 ################################################
 Skipping Variable u As this a  Formal Parameter to the current function Call
 Outer Function calls goal
 ################################################
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v32:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls goal
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 3th argument for Function goal
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v34:Ty_list int nlrecord | true}
 
 Enumerating a Scalar Term d
 
 Type of the Scalar Term {var_v34:Ty_list int nlrecord | true}
 ################################################
 Skipping Variable d As this a  Formal Parameter to the current function Call
 Outer Function calls goal
 ################################################
 
 Enumerating a Scalar Term db
 
 Type of the Scalar Term {var_v29:Ty_list int nlrecord | true}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 3th Args option for goal : db
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  *************** Synthesizing Args ei : Failed for some  arg
 ############################################################
  Synthesizing the Function application Pure Component remove
  *************** Trying Arrow Component ************remove :  Arrow ( ( db : {var_v29:Ty_list int nlrecord | true} ) ->  Arrow ( ( n : {var_v30:Ty_string | true} ) ->  Arrow ( ( u : {var_v31:Ty_string | true} ) -> {v:Ty_list int nlrecord | (nlmem)( , v, n, u ) = (false)}
  *************** Synthesizing Args ei : ti for ************remove
 ##################################################################################
  Synthesizing the 1th argument for Function remove
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v29:Ty_list int nlrecord | true}
 
 Enumerating a Scalar Term db
 
 Type of the Scalar Term {var_v29:Ty_list int nlrecord | true}
 ################################################
 Skipping Variable db As this a  Formal Parameter to the current function Call
 Outer Function calls remove
 ################################################
 
 Enumerating a Scalar Term d
 
 Type of the Scalar Term {var_v34:Ty_list int nlrecord | true}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 1th Args option for remove : d
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 2th argument for Function remove
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v30:Ty_string | true}
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v32:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls remove
 ################################################
 
 Enumerating a Scalar Term u
 
 Type of the Scalar Term {var_v33:Ty_string | true}
 ################################################
 Skipping Variable u As this a  Formal Parameter to the current function Call
 Outer Function calls remove
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 3th argument for Function remove
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v31:Ty_string | true}
 
 Enumerating a Scalar Term u
 
 Type of the Scalar Term {var_v33:Ty_string | true}
 ################################################
 Skipping Variable u As this a  Formal Parameter to the current function Call
 Outer Function calls remove
 ################################################
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v30:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls remove
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  *************** Synthesizing Args ei : Failed for some  arg
 ############################################################
  Synthesizing the Function application Pure Component confirm
  *************** Trying Arrow Component ************confirm :  Arrow ( ( db : {var_v22:Ty_list int nlrecord | true} ) ->  Arrow ( ( c : {var_v23:int code | true} ) ->  Arrow ( ( n : {var_v24:Ty_string | true} ) ->  Arrow ( ( u : {var_v25:Ty_string | true} ) -> {v:Ty_list int nlrecord | 
 	 Conj <c (nlmem)( , db, n, u ) = (true)
 	 , 
 	 Conj <c 
 	 Impl < (c) = (Cs)
 	 (subscribed)( , v, n, u ) = (true) >
 	 , 
 	 Impl < (c) = (Cu)
 	 (subscribed)( , v, n, u ) = (false) > >c  >c }
  *************** Synthesizing Args ei : ti for ************confirm
 ##################################################################################
  Synthesizing the 1th argument for Function confirm
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v22:Ty_list int nlrecord | true}
 
 Enumerating a Scalar Term d
 
 Type of the Scalar Term {var_v34:Ty_list int nlrecord | true}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term db
 
 Type of the Scalar Term {var_v29:Ty_list int nlrecord | true}
 ################################################
 Skipping Variable db As this a  Formal Parameter to the current function Call
 Outer Function calls confirm
 ################################################
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 1th Args option for confirm : d
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 2th argument for Function confirm
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v23:int code | true}
 
 Enumerating a Scalar Term c
 
 Type of the Scalar Term {var_v23:int code | true}
 ################################################
 Skipping Variable c As this a  Formal Parameter to the current function Call
 Outer Function calls confirm
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 3th argument for Function confirm
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v24:Ty_string | true}
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v30:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls confirm
 ################################################
 
 Enumerating a Scalar Term u
 
 Type of the Scalar Term {var_v31:Ty_string | true}
 ################################################
 Skipping Variable u As this a  Formal Parameter to the current function Call
 Outer Function calls confirm
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 4th argument for Function confirm
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v25:Ty_string | true}
 
 Enumerating a Scalar Term u
 
 Type of the Scalar Term {var_v31:Ty_string | true}
 ################################################
 Skipping Variable u As this a  Formal Parameter to the current function Call
 Outer Function calls confirm
 ################################################
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v24:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls confirm
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  *************** Synthesizing Args ei : Failed for some  arg
 ############################################################
  Synthesizing the Function application Pure Component unsubscribe
  *************** Trying Arrow Component ************unsubscribe :  Arrow ( ( db : {var_v19:Ty_list int nlrecord | true} ) ->  Arrow ( ( n : {var_v20:Ty_string | true} ) ->  Arrow ( ( u : {var_v21:Ty_string | true} ) -> {v:Ty_list int nlrecord | 
 	 Conj <c (nlmem)( , db, n, u ) = (true)
 	 , 
 	 Conj <c (nlmem)( , v, n, u ) = (true)
 	 , (subscribed)( , v, n, u ) = (false) >c  >c }
  *************** Synthesizing Args ei : ti for ************unsubscribe
 ##################################################################################
  Synthesizing the 1th argument for Function unsubscribe
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v19:Ty_list int nlrecord | true}
 
 Enumerating a Scalar Term d
 
 Type of the Scalar Term {var_v34:Ty_list int nlrecord | true}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term db
 
 Type of the Scalar Term {var_v22:Ty_list int nlrecord | true}
 ################################################
 Skipping Variable db As this a  Formal Parameter to the current function Call
 Outer Function calls unsubscribe
 ################################################
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 1th Args option for unsubscribe : d
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 2th argument for Function unsubscribe
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v20:Ty_string | true}
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v24:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls unsubscribe
 ################################################
 
 Enumerating a Scalar Term u
 
 Type of the Scalar Term {var_v25:Ty_string | true}
 ################################################
 Skipping Variable u As this a  Formal Parameter to the current function Call
 Outer Function calls unsubscribe
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 3th argument for Function unsubscribe
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v21:Ty_string | true}
 
 Enumerating a Scalar Term u
 
 Type of the Scalar Term {var_v25:Ty_string | true}
 ################################################
 Skipping Variable u As this a  Formal Parameter to the current function Call
 Outer Function calls unsubscribe
 ################################################
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v20:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls unsubscribe
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  *************** Synthesizing Args ei : Failed for some  arg
 ############################################################
  Synthesizing the Function application Pure Component subscribe
  *************** Trying Arrow Component ************subscribe :  Arrow ( ( db : {var_v16:Ty_list int nlrecord | true} ) ->  Arrow ( ( n : {var_v17:Ty_string | true} ) ->  Arrow ( ( u : {var_v18:Ty_string | true} ) -> {v:Ty_list int nlrecord | 
 	 Conj <c (nlmem)( , db, n, u ) = (false)
 	 , 
 	 Conj <c (nlmem)( , v, n, u ) = (true)
 	 , (subscribed)( , v, n, u ) = (true) >c  >c }
  *************** Synthesizing Args ei : ti for ************subscribe
 ##################################################################################
  Synthesizing the 1th argument for Function subscribe
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v16:Ty_list int nlrecord | true}
 
 Enumerating a Scalar Term d
 
 Type of the Scalar Term {var_v34:Ty_list int nlrecord | true}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term db
 
 Type of the Scalar Term {var_v19:Ty_list int nlrecord | true}
 ################################################
 Skipping Variable db As this a  Formal Parameter to the current function Call
 Outer Function calls subscribe
 ################################################
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 1th Args option for subscribe : d
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 2th argument for Function subscribe
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v17:Ty_string | true}
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v20:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls subscribe
 ################################################
 
 Enumerating a Scalar Term u
 
 Type of the Scalar Term {var_v21:Ty_string | true}
 ################################################
 Skipping Variable u As this a  Formal Parameter to the current function Call
 Outer Function calls subscribe
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 3th argument for Function subscribe
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v18:Ty_string | true}
 
 Enumerating a Scalar Term u
 
 Type of the Scalar Term {var_v21:Ty_string | true}
 ################################################
 Skipping Variable u As this a  Formal Parameter to the current function Call
 Outer Function calls subscribe
 ################################################
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v17:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls subscribe
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  *************** Synthesizing Args ei : Failed for some  arg
 >>>>>>>>>>>>>>>>>>> 1th Args option for confirm : d
  DEPTH vs MAX  0 vs 2
 ##################################################################################
  Synthesizing the 2th argument for Function confirm
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v23:int code | true}
 
 Enumerating a Scalar Term c
 
 Type of the Scalar Term {var_v23:int code | true}
 ################################################
 Skipping Variable c As this a  Formal Parameter to the current function Call
 Outer Function calls confirm
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 Found Constructors with required return type
  
 ********************** HERE BEFORE 
 Show No more choices for ConsApp
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  
  DEPTH vs MAX  0 vs 2
 ##################################################################################
  Synthesizing the 3th argument for Function confirm
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v24:Ty_string | true}
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v17:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls confirm
 ################################################
 
 Enumerating a Scalar Term u
 
 Type of the Scalar Term {var_v18:Ty_string | true}
 ################################################
 Skipping Variable u As this a  Formal Parameter to the current function Call
 Outer Function calls confirm
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 Found Constructors with required return type
  
 ********************** HERE BEFORE 
 Show No more choices for ConsApp
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  
  DEPTH vs MAX  0 vs 2
 ##################################################################################
  Synthesizing the 4th argument for Function confirm
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v25:Ty_string | true}
 
 Enumerating a Scalar Term u
 
 Type of the Scalar Term {var_v18:Ty_string | true}
 ################################################
 Skipping Variable u As this a  Formal Parameter to the current function Call
 Outer Function calls confirm
 ################################################
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v24:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls confirm
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 Found Constructors with required return type
  
 ********************** HERE BEFORE 
 Show No more choices for ConsApp
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  
  DEPTH vs MAX  0 vs 2
 ##################################################################################
  *************** Synthesizing Args ei : Failed for some  arg
 ############################################################
  Synthesizing the Function application Pure Component unsubscribe
  *************** Trying Arrow Component ************unsubscribe :  Arrow ( ( db : {var_v19:Ty_list int nlrecord | true} ) ->  Arrow ( ( n : {var_v20:Ty_string | true} ) ->  Arrow ( ( u : {var_v21:Ty_string | true} ) -> {v:Ty_list int nlrecord | 
 	 Conj <c (nlmem)( , db, n, u ) = (true)
 	 , 
 	 Conj <c (nlmem)( , v, n, u ) = (true)
 	 , (subscribed)( , v, n, u ) = (false) >c  >c }
  *************** Synthesizing Args ei : ti for ************unsubscribe
 ##################################################################################
  Synthesizing the 1th argument for Function unsubscribe
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v19:Ty_list int nlrecord | true}
 
 Enumerating a Scalar Term d
 
 Type of the Scalar Term {var_v34:Ty_list int nlrecord | true}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term db
 
 Type of the Scalar Term {var_v22:Ty_list int nlrecord | true}
 ################################################
 Skipping Variable db As this a  Formal Parameter to the current function Call
 Outer Function calls unsubscribe
 ################################################
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  , 
 goal, 
 remove, 
 confirm, 
 unsubscribe, 
 subscribe
 ############################################################
  Synthesizing the Function application Pure Component goal
  *************** Trying Arrow Component ************goal :  Arrow ( ( n : {var_v32:Ty_string | true} ) ->  Arrow ( ( u : {var_v33:Ty_string | true} ) ->  Arrow ( ( d : {var_v34:Ty_list int nlrecord | true} ) -> {v:Ty_list int nlrecord | 
 	 Conj <c (subscribed)( , v, n, u ) = (false)
 	 , 
 	 Conj <c (nlmem)( , v, n, u ) = (false)
 	 , 
 	 Impl < (promotions)( , v, u ) = (true)
 	 (email)( , v, u ) = (true) > >c  >c }
  *************** Synthesizing Args ei : ti for ************goal
 ##################################################################################
  Synthesizing the 1th argument for Function goal
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v32:Ty_string | true}
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v24:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls goal
 ################################################
 
 Enumerating a Scalar Term u
 
 Type of the Scalar Term {var_v25:Ty_string | true}
 ################################################
 Skipping Variable u As this a  Formal Parameter to the current function Call
 Outer Function calls goal
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 2th argument for Function goal
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v33:Ty_string | true}
 
 Enumerating a Scalar Term u
 
 Type of the Scalar Term {var_v25:Ty_string | true}
 ################################################
 Skipping Variable u As this a  Formal Parameter to the current function Call
 Outer Function calls goal
 ################################################
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v32:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls goal
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 3th argument for Function goal
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v34:Ty_list int nlrecord | true}
 
 Enumerating a Scalar Term d
 
 Type of the Scalar Term {var_v34:Ty_list int nlrecord | true}
 ################################################
 Skipping Variable d As this a  Formal Parameter to the current function Call
 Outer Function calls goal
 ################################################
 
 Enumerating a Scalar Term db
 
 Type of the Scalar Term {var_v22:Ty_list int nlrecord | true}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 3th Args option for goal : db
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  *************** Synthesizing Args ei : Failed for some  arg
 ############################################################
  Synthesizing the Function application Pure Component remove
  *************** Trying Arrow Component ************remove :  Arrow ( ( db : {var_v29:Ty_list int nlrecord | true} ) ->  Arrow ( ( n : {var_v30:Ty_string | true} ) ->  Arrow ( ( u : {var_v31:Ty_string | true} ) -> {v:Ty_list int nlrecord | (nlmem)( , v, n, u ) = (false)}
  *************** Synthesizing Args ei : ti for ************remove
 ##################################################################################
  Synthesizing the 1th argument for Function remove
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v29:Ty_list int nlrecord | true}
 
 Enumerating a Scalar Term db
 
 Type of the Scalar Term {var_v22:Ty_list int nlrecord | true}
 ################################################
 Skipping Variable db As this a  Formal Parameter to the current function Call
 Outer Function calls remove
 ################################################
 
 Enumerating a Scalar Term d
 
 Type of the Scalar Term {var_v34:Ty_list int nlrecord | true}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 1th Args option for remove : d
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 2th argument for Function remove
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v30:Ty_string | true}
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v32:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls remove
 ################################################
 
 Enumerating a Scalar Term u
 
 Type of the Scalar Term {var_v33:Ty_string | true}
 ################################################
 Skipping Variable u As this a  Formal Parameter to the current function Call
 Outer Function calls remove
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 3th argument for Function remove
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v31:Ty_string | true}
 
 Enumerating a Scalar Term u
 
 Type of the Scalar Term {var_v33:Ty_string | true}
 ################################################
 Skipping Variable u As this a  Formal Parameter to the current function Call
 Outer Function calls remove
 ################################################
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v30:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls remove
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  *************** Synthesizing Args ei : Failed for some  arg
 ############################################################
  Synthesizing the Function application Pure Component confirm
  *************** Trying Arrow Component ************confirm :  Arrow ( ( db : {var_v22:Ty_list int nlrecord | true} ) ->  Arrow ( ( c : {var_v23:int code | true} ) ->  Arrow ( ( n : {var_v24:Ty_string | true} ) ->  Arrow ( ( u : {var_v25:Ty_string | true} ) -> {v:Ty_list int nlrecord | 
 	 Conj <c (nlmem)( , db, n, u ) = (true)
 	 , 
 	 Conj <c 
 	 Impl < (c) = (Cs)
 	 (subscribed)( , v, n, u ) = (true) >
 	 , 
 	 Impl < (c) = (Cu)
 	 (subscribed)( , v, n, u ) = (false) > >c  >c }
  *************** Synthesizing Args ei : ti for ************confirm
 ##################################################################################
  Synthesizing the 1th argument for Function confirm
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v22:Ty_list int nlrecord | true}
 
 Enumerating a Scalar Term d
 
 Type of the Scalar Term {var_v34:Ty_list int nlrecord | true}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term db
 
 Type of the Scalar Term {var_v29:Ty_list int nlrecord | true}
 ################################################
 Skipping Variable db As this a  Formal Parameter to the current function Call
 Outer Function calls confirm
 ################################################
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 1th Args option for confirm : d
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 2th argument for Function confirm
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v23:int code | true}
 
 Enumerating a Scalar Term c
 
 Type of the Scalar Term {var_v23:int code | true}
 ################################################
 Skipping Variable c As this a  Formal Parameter to the current function Call
 Outer Function calls confirm
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 3th argument for Function confirm
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v24:Ty_string | true}
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v30:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls confirm
 ################################################
 
 Enumerating a Scalar Term u
 
 Type of the Scalar Term {var_v31:Ty_string | true}
 ################################################
 Skipping Variable u As this a  Formal Parameter to the current function Call
 Outer Function calls confirm
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 4th argument for Function confirm
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v25:Ty_string | true}
 
 Enumerating a Scalar Term u
 
 Type of the Scalar Term {var_v31:Ty_string | true}
 ################################################
 Skipping Variable u As this a  Formal Parameter to the current function Call
 Outer Function calls confirm
 ################################################
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v24:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls confirm
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  *************** Synthesizing Args ei : Failed for some  arg
 ############################################################
  Synthesizing the Function application Pure Component unsubscribe
  *************** Trying Arrow Component ************unsubscribe :  Arrow ( ( db : {var_v19:Ty_list int nlrecord | true} ) ->  Arrow ( ( n : {var_v20:Ty_string | true} ) ->  Arrow ( ( u : {var_v21:Ty_string | true} ) -> {v:Ty_list int nlrecord | 
 	 Conj <c (nlmem)( , db, n, u ) = (true)
 	 , 
 	 Conj <c (nlmem)( , v, n, u ) = (true)
 	 , (subscribed)( , v, n, u ) = (false) >c  >c }
  *************** Synthesizing Args ei : ti for ************unsubscribe
 ##################################################################################
  Synthesizing the 1th argument for Function unsubscribe
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v19:Ty_list int nlrecord | true}
 
 Enumerating a Scalar Term d
 
 Type of the Scalar Term {var_v34:Ty_list int nlrecord | true}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term db
 
 Type of the Scalar Term {var_v22:Ty_list int nlrecord | true}
 ################################################
 Skipping Variable db As this a  Formal Parameter to the current function Call
 Outer Function calls unsubscribe
 ################################################
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 1th Args option for unsubscribe : d
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 2th argument for Function unsubscribe
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v20:Ty_string | true}
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v24:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls unsubscribe
 ################################################
 
 Enumerating a Scalar Term u
 
 Type of the Scalar Term {var_v25:Ty_string | true}
 ################################################
 Skipping Variable u As this a  Formal Parameter to the current function Call
 Outer Function calls unsubscribe
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 3th argument for Function unsubscribe
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v21:Ty_string | true}
 
 Enumerating a Scalar Term u
 
 Type of the Scalar Term {var_v25:Ty_string | true}
 ################################################
 Skipping Variable u As this a  Formal Parameter to the current function Call
 Outer Function calls unsubscribe
 ################################################
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v20:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls unsubscribe
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  *************** Synthesizing Args ei : Failed for some  arg
 ############################################################
  Synthesizing the Function application Pure Component subscribe
  *************** Trying Arrow Component ************subscribe :  Arrow ( ( db : {var_v16:Ty_list int nlrecord | true} ) ->  Arrow ( ( n : {var_v17:Ty_string | true} ) ->  Arrow ( ( u : {var_v18:Ty_string | true} ) -> {v:Ty_list int nlrecord | 
 	 Conj <c (nlmem)( , db, n, u ) = (false)
 	 , 
 	 Conj <c (nlmem)( , v, n, u ) = (true)
 	 , (subscribed)( , v, n, u ) = (true) >c  >c }
  *************** Synthesizing Args ei : ti for ************subscribe
 ##################################################################################
  Synthesizing the 1th argument for Function subscribe
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v16:Ty_list int nlrecord | true}
 
 Enumerating a Scalar Term d
 
 Type of the Scalar Term {var_v34:Ty_list int nlrecord | true}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term db
 
 Type of the Scalar Term {var_v19:Ty_list int nlrecord | true}
 ################################################
 Skipping Variable db As this a  Formal Parameter to the current function Call
 Outer Function calls subscribe
 ################################################
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 1th Args option for subscribe : d
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 2th argument for Function subscribe
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v17:Ty_string | true}
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v20:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls subscribe
 ################################################
 
 Enumerating a Scalar Term u
 
 Type of the Scalar Term {var_v21:Ty_string | true}
 ################################################
 Skipping Variable u As this a  Formal Parameter to the current function Call
 Outer Function calls subscribe
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 3th argument for Function subscribe
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v18:Ty_string | true}
 
 Enumerating a Scalar Term u
 
 Type of the Scalar Term {var_v21:Ty_string | true}
 ################################################
 Skipping Variable u As this a  Formal Parameter to the current function Call
 Outer Function calls subscribe
 ################################################
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v17:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls subscribe
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  *************** Synthesizing Args ei : Failed for some  arg
 >>>>>>>>>>>>>>>>>>> 1th Args option for unsubscribe : d
  DEPTH vs MAX  0 vs 2
 ##################################################################################
  Synthesizing the 2th argument for Function unsubscribe
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v20:Ty_string | true}
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v17:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls unsubscribe
 ################################################
 
 Enumerating a Scalar Term u
 
 Type of the Scalar Term {var_v18:Ty_string | true}
 ################################################
 Skipping Variable u As this a  Formal Parameter to the current function Call
 Outer Function calls unsubscribe
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 Found Constructors with required return type
  
 ********************** HERE BEFORE 
 Show No more choices for ConsApp
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  
  DEPTH vs MAX  0 vs 2
 ##################################################################################
  Synthesizing the 3th argument for Function unsubscribe
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v21:Ty_string | true}
 
 Enumerating a Scalar Term u
 
 Type of the Scalar Term {var_v18:Ty_string | true}
 ################################################
 Skipping Variable u As this a  Formal Parameter to the current function Call
 Outer Function calls unsubscribe
 ################################################
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v20:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls unsubscribe
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 Found Constructors with required return type
  
 ********************** HERE BEFORE 
 Show No more choices for ConsApp
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  
  DEPTH vs MAX  0 vs 2
 ##################################################################################
  *************** Synthesizing Args ei : Failed for some  arg
 ############################################################
  Synthesizing the Function application Pure Component subscribe
  *************** Trying Arrow Component ************subscribe :  Arrow ( ( db : {var_v16:Ty_list int nlrecord | true} ) ->  Arrow ( ( n : {var_v17:Ty_string | true} ) ->  Arrow ( ( u : {var_v18:Ty_string | true} ) -> {v:Ty_list int nlrecord | 
 	 Conj <c (nlmem)( , db, n, u ) = (false)
 	 , 
 	 Conj <c (nlmem)( , v, n, u ) = (true)
 	 , (subscribed)( , v, n, u ) = (true) >c  >c }
  *************** Synthesizing Args ei : ti for ************subscribe
 ##################################################################################
  Synthesizing the 1th argument for Function subscribe
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v16:Ty_list int nlrecord | true}
 
 Enumerating a Scalar Term d
 
 Type of the Scalar Term {var_v34:Ty_list int nlrecord | true}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term db
 
 Type of the Scalar Term {var_v19:Ty_list int nlrecord | true}
 ################################################
 Skipping Variable db As this a  Formal Parameter to the current function Call
 Outer Function calls subscribe
 ################################################
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  , 
 goal, 
 remove, 
 confirm, 
 unsubscribe, 
 subscribe
 ############################################################
  Synthesizing the Function application Pure Component goal
  *************** Trying Arrow Component ************goal :  Arrow ( ( n : {var_v32:Ty_string | true} ) ->  Arrow ( ( u : {var_v33:Ty_string | true} ) ->  Arrow ( ( d : {var_v34:Ty_list int nlrecord | true} ) -> {v:Ty_list int nlrecord | 
 	 Conj <c (subscribed)( , v, n, u ) = (false)
 	 , 
 	 Conj <c (nlmem)( , v, n, u ) = (false)
 	 , 
 	 Impl < (promotions)( , v, u ) = (true)
 	 (email)( , v, u ) = (true) > >c  >c }
  *************** Synthesizing Args ei : ti for ************goal
 ##################################################################################
  Synthesizing the 1th argument for Function goal
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v32:Ty_string | true}
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v20:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls goal
 ################################################
 
 Enumerating a Scalar Term u
 
 Type of the Scalar Term {var_v21:Ty_string | true}
 ################################################
 Skipping Variable u As this a  Formal Parameter to the current function Call
 Outer Function calls goal
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 2th argument for Function goal
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v33:Ty_string | true}
 
 Enumerating a Scalar Term u
 
 Type of the Scalar Term {var_v21:Ty_string | true}
 ################################################
 Skipping Variable u As this a  Formal Parameter to the current function Call
 Outer Function calls goal
 ################################################
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v32:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls goal
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 3th argument for Function goal
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v34:Ty_list int nlrecord | true}
 
 Enumerating a Scalar Term d
 
 Type of the Scalar Term {var_v34:Ty_list int nlrecord | true}
 ################################################
 Skipping Variable d As this a  Formal Parameter to the current function Call
 Outer Function calls goal
 ################################################
 
 Enumerating a Scalar Term db
 
 Type of the Scalar Term {var_v19:Ty_list int nlrecord | true}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 3th Args option for goal : db
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  *************** Synthesizing Args ei : Failed for some  arg
 ############################################################
  Synthesizing the Function application Pure Component remove
  *************** Trying Arrow Component ************remove :  Arrow ( ( db : {var_v29:Ty_list int nlrecord | true} ) ->  Arrow ( ( n : {var_v30:Ty_string | true} ) ->  Arrow ( ( u : {var_v31:Ty_string | true} ) -> {v:Ty_list int nlrecord | (nlmem)( , v, n, u ) = (false)}
  *************** Synthesizing Args ei : ti for ************remove
 ##################################################################################
  Synthesizing the 1th argument for Function remove
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v29:Ty_list int nlrecord | true}
 
 Enumerating a Scalar Term db
 
 Type of the Scalar Term {var_v19:Ty_list int nlrecord | true}
 ################################################
 Skipping Variable db As this a  Formal Parameter to the current function Call
 Outer Function calls remove
 ################################################
 
 Enumerating a Scalar Term d
 
 Type of the Scalar Term {var_v34:Ty_list int nlrecord | true}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 1th Args option for remove : d
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 2th argument for Function remove
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v30:Ty_string | true}
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v32:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls remove
 ################################################
 
 Enumerating a Scalar Term u
 
 Type of the Scalar Term {var_v33:Ty_string | true}
 ################################################
 Skipping Variable u As this a  Formal Parameter to the current function Call
 Outer Function calls remove
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 3th argument for Function remove
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v31:Ty_string | true}
 
 Enumerating a Scalar Term u
 
 Type of the Scalar Term {var_v33:Ty_string | true}
 ################################################
 Skipping Variable u As this a  Formal Parameter to the current function Call
 Outer Function calls remove
 ################################################
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v30:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls remove
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  *************** Synthesizing Args ei : Failed for some  arg
 ############################################################
  Synthesizing the Function application Pure Component confirm
  *************** Trying Arrow Component ************confirm :  Arrow ( ( db : {var_v22:Ty_list int nlrecord | true} ) ->  Arrow ( ( c : {var_v23:int code | true} ) ->  Arrow ( ( n : {var_v24:Ty_string | true} ) ->  Arrow ( ( u : {var_v25:Ty_string | true} ) -> {v:Ty_list int nlrecord | 
 	 Conj <c (nlmem)( , db, n, u ) = (true)
 	 , 
 	 Conj <c 
 	 Impl < (c) = (Cs)
 	 (subscribed)( , v, n, u ) = (true) >
 	 , 
 	 Impl < (c) = (Cu)
 	 (subscribed)( , v, n, u ) = (false) > >c  >c }
  *************** Synthesizing Args ei : ti for ************confirm
 ##################################################################################
  Synthesizing the 1th argument for Function confirm
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v22:Ty_list int nlrecord | true}
 
 Enumerating a Scalar Term d
 
 Type of the Scalar Term {var_v34:Ty_list int nlrecord | true}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term db
 
 Type of the Scalar Term {var_v29:Ty_list int nlrecord | true}
 ################################################
 Skipping Variable db As this a  Formal Parameter to the current function Call
 Outer Function calls confirm
 ################################################
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 1th Args option for confirm : d
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 2th argument for Function confirm
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v23:int code | true}
 
 Enumerating a Scalar Term c
 
 Type of the Scalar Term {var_v23:int code | true}
 ################################################
 Skipping Variable c As this a  Formal Parameter to the current function Call
 Outer Function calls confirm
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 3th argument for Function confirm
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v24:Ty_string | true}
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v30:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls confirm
 ################################################
 
 Enumerating a Scalar Term u
 
 Type of the Scalar Term {var_v31:Ty_string | true}
 ################################################
 Skipping Variable u As this a  Formal Parameter to the current function Call
 Outer Function calls confirm
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 4th argument for Function confirm
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v25:Ty_string | true}
 
 Enumerating a Scalar Term u
 
 Type of the Scalar Term {var_v31:Ty_string | true}
 ################################################
 Skipping Variable u As this a  Formal Parameter to the current function Call
 Outer Function calls confirm
 ################################################
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v24:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls confirm
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  *************** Synthesizing Args ei : Failed for some  arg
 ############################################################
  Synthesizing the Function application Pure Component unsubscribe
  *************** Trying Arrow Component ************unsubscribe :  Arrow ( ( db : {var_v19:Ty_list int nlrecord | true} ) ->  Arrow ( ( n : {var_v20:Ty_string | true} ) ->  Arrow ( ( u : {var_v21:Ty_string | true} ) -> {v:Ty_list int nlrecord | 
 	 Conj <c (nlmem)( , db, n, u ) = (true)
 	 , 
 	 Conj <c (nlmem)( , v, n, u ) = (true)
 	 , (subscribed)( , v, n, u ) = (false) >c  >c }
  *************** Synthesizing Args ei : ti for ************unsubscribe
 ##################################################################################
  Synthesizing the 1th argument for Function unsubscribe
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v19:Ty_list int nlrecord | true}
 
 Enumerating a Scalar Term d
 
 Type of the Scalar Term {var_v34:Ty_list int nlrecord | true}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term db
 
 Type of the Scalar Term {var_v22:Ty_list int nlrecord | true}
 ################################################
 Skipping Variable db As this a  Formal Parameter to the current function Call
 Outer Function calls unsubscribe
 ################################################
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 1th Args option for unsubscribe : d
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 2th argument for Function unsubscribe
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v20:Ty_string | true}
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v24:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls unsubscribe
 ################################################
 
 Enumerating a Scalar Term u
 
 Type of the Scalar Term {var_v25:Ty_string | true}
 ################################################
 Skipping Variable u As this a  Formal Parameter to the current function Call
 Outer Function calls unsubscribe
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 3th argument for Function unsubscribe
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v21:Ty_string | true}
 
 Enumerating a Scalar Term u
 
 Type of the Scalar Term {var_v25:Ty_string | true}
 ################################################
 Skipping Variable u As this a  Formal Parameter to the current function Call
 Outer Function calls unsubscribe
 ################################################
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v20:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls unsubscribe
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  *************** Synthesizing Args ei : Failed for some  arg
 ############################################################
  Synthesizing the Function application Pure Component subscribe
  *************** Trying Arrow Component ************subscribe :  Arrow ( ( db : {var_v16:Ty_list int nlrecord | true} ) ->  Arrow ( ( n : {var_v17:Ty_string | true} ) ->  Arrow ( ( u : {var_v18:Ty_string | true} ) -> {v:Ty_list int nlrecord | 
 	 Conj <c (nlmem)( , db, n, u ) = (false)
 	 , 
 	 Conj <c (nlmem)( , v, n, u ) = (true)
 	 , (subscribed)( , v, n, u ) = (true) >c  >c }
  *************** Synthesizing Args ei : ti for ************subscribe
 ##################################################################################
  Synthesizing the 1th argument for Function subscribe
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v16:Ty_list int nlrecord | true}
 
 Enumerating a Scalar Term d
 
 Type of the Scalar Term {var_v34:Ty_list int nlrecord | true}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term db
 
 Type of the Scalar Term {var_v19:Ty_list int nlrecord | true}
 ################################################
 Skipping Variable db As this a  Formal Parameter to the current function Call
 Outer Function calls subscribe
 ################################################
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 1th Args option for subscribe : d
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 2th argument for Function subscribe
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v17:Ty_string | true}
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v20:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls subscribe
 ################################################
 
 Enumerating a Scalar Term u
 
 Type of the Scalar Term {var_v21:Ty_string | true}
 ################################################
 Skipping Variable u As this a  Formal Parameter to the current function Call
 Outer Function calls subscribe
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 3th argument for Function subscribe
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v18:Ty_string | true}
 
 Enumerating a Scalar Term u
 
 Type of the Scalar Term {var_v21:Ty_string | true}
 ################################################
 Skipping Variable u As this a  Formal Parameter to the current function Call
 Outer Function calls subscribe
 ################################################
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v17:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls subscribe
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  *************** Synthesizing Args ei : Failed for some  arg
 >>>>>>>>>>>>>>>>>>> 1th Args option for subscribe : d
  DEPTH vs MAX  0 vs 2
 ##################################################################################
  Synthesizing the 2th argument for Function subscribe
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v17:Ty_string | true}
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v17:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls subscribe
 ################################################
 
 Enumerating a Scalar Term u
 
 Type of the Scalar Term {var_v18:Ty_string | true}
 ################################################
 Skipping Variable u As this a  Formal Parameter to the current function Call
 Outer Function calls subscribe
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 Found Constructors with required return type
  
 ********************** HERE BEFORE 
 Show No more choices for ConsApp
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  
  DEPTH vs MAX  0 vs 2
 ##################################################################################
  Synthesizing the 3th argument for Function subscribe
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v18:Ty_string | true}
 
 Enumerating a Scalar Term u
 
 Type of the Scalar Term {var_v18:Ty_string | true}
 ################################################
 Skipping Variable u As this a  Formal Parameter to the current function Call
 Outer Function calls subscribe
 ################################################
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v17:Ty_string | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls subscribe
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 Found Constructors with required return type
  
 ********************** HERE BEFORE 
 Show No more choices for ConsApp
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  
  DEPTH vs MAX  0 vs 2
 ##################################################################################
  *************** Synthesizing Args ei : Failed for some  arg
  EXPLORED Args.parser output 
 EXPLORED learningOn  true
 EXPLORED bidirectionality  true
 EXPLORED effect-filter  false
 EXPLORED specfile :: ./prudent_tests/hegel/Cobalt+/FWInsCons.spec
 EXPLORED goal Number :: 0
 EXPLORED Max path length :: 2
 EXPLORED Nested If :: 1typewhitespace var: fwstate
semicolon
typewhitespace var: srpair
semicolon
typewhitespace var: nlrecord
semicolon
typewhitespace var: user
semicolon
typewhitespace var: code
semicolon
stexcwhitespace var: device
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: int
whitespace colon
whitespace var: bool
semicolon
stexcwhitespace var: dsize
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: lmem
whitespace colon
whitespace lbrace
var: a
rbrace
whitespace colon
whitespace var: a
whitespace colon
whitespace var: bool
semicolon
stexcwhitespace var: lhd
whitespace colon
whitespace lbrace
var: a
rbrace
whitespace colon
whitespace var: a
semicolon
stexcwhitespace var: fst
whitespace colon
whitespace var: fwstate
whitespace colon
whitespace lbrace
var: srpair
rbrace
whitespace semicolon
stexcwhitespace var: snd
whitespace colon
whitespace var: fwstate
whitespace colon
whitespace lbrace
var: int
rbrace
semicolon
stexcwhitespace var: central
whitespace colon
whitespace lbrace
var: srpair
rbrace
whitespace colon
whitespace var: int
whitespace colon
whitespace var: bool
semicolon
stexcwhitespace var: cansend
whitespace colon
whitespace lbrace
var: srpair
rbrace
whitespace colon
whitespace var: int
whitespace colon
whitespace var: int
whitespace colon
whitespace var: bool
semicolon
stexcwhitespace var: is_central
whitespace colon
whitespace var: int
whitespace colon
whitespace var: bool
semicolon
stexcwhitespace var: nlmem
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
whitespace colon
whitespace var: string
whitespace colon
whitespace var: string
whitespace colon
whitespace var: bool
semicolon
stexcwhitespace var: ns
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
whitespace colon
whitespace var: string
whitespace colon
whitespace var: string
whitespace colon
whitespace var: nlrecord
semicolon
stexcwhitespace var: subscribed
whitespace colon
whitespace var: nlrecord
whitespace colon
whitespace var: bool
semicolon
stexcwhitespace var: nletter
whitespace colon
whitespace var: nlrecord
whitespace colon
whitespace var: string
semicolon
stexcwhitespace var: code
whitespace colon
whitespace var: nlrecord
whitespace colon
whitespace var: code
semicolon
stexcwhitespace var: articles
whitespace colon
whitespace var: nlrecord
whitespace colon
whitespace lbrace
var: string
rbrace
semicolon
stexcwhitespace var: email
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
whitespace colon
whitespace var: user
whitespace colon
whitespace var: bool
semicolon
stexcwhitespace var: promotions
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
whitespace colon
whitespace var: user
whitespace colon
whitespace var: bool
semicolon
var: add_device
whitespace colon
whitespace lparen
var: dtable
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace whitespace lparen
var: cstab
whitespace colon
whitespace lbrace
var: srpair
rbrace
rparen
whitespace arrow
whitespace whitespace lparen
var: d
whitespace colon
whitespace lcurly
var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace var: device
whitespace lparen
var: dtable
comma
whitespace var: v
rparen
whitespace equalopwhitespace falsercurly
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace var: fwstate
whitespace pipe
lambdalparen
var: s
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
dotwhitespace var: fst
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: cstab
whitespace conjwhitespace lparen
var: s
whitespace equalopwhitespace var: snd
whitespace lparen
var: v
rparen
whitespace implieswhitespace whitespace var: device
lparen
var: s
comma
whitespace var: d
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace var: dsize
lparen
var: s
rparen
whitespace equalopwhitespace var: dsize
lparen
var: dtable
rparen
whitespace pluswhitespace int: 1
rparen
whitespace rcurly
semicolon
var: diff_device
whitespace colon
whitespace lparen
var: sr
whitespace colon
whitespace lbrace
var: srpair
rbrace
rparen
whitespace arrow
whitespace lparen
var: dtable
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lparen
var: d
whitespace colon
whitespace lcurly
var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace truercurly
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace var: device
lparen
var: dtable
comma
whitespace var: v
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace notwhitespace lbrace
var: v
equalopvar: d
rbrace
whitespace rcurly
semicolon
var: add_connection
whitespace colon
whitespace lparen
var: sr
whitespace colon
whitespace lbrace
var: srpair
rbrace
rparen
whitespace arrow
whitespace lparen
var: dtable
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lparen
var: s
whitespace colon
whitespace lcurly
var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace var: device
lparen
var: dtable
comma
whitespace var: v
rparen
whitespace equalopwhitespace truercurly
rparen
whitespace arrow
whitespace lparen
var: r
whitespace colon
whitespace lcurly
var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace var: device
lparen
var: dtable
comma
whitespace var: v
rparen
whitespace equalopwhitespace truercurly
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace var: fwstate
whitespace pipe
whitespace lambdalparen
var: f
whitespace colon
whitespace lbrace
var: srpair
rbrace
rparen
dotwhitespace var: snd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: dtable
whitespace conjwhitespace lparen
var: f
whitespace equalopwhitespace var: fst
whitespace lparen
var: v
rparen
whitespace implieswhitespace var: cansend
lparen
var: f
comma
whitespace var: s
comma
whitespace var: r
rparen
whitespace equalopwhitespace truerparen
whitespace rcurly
semicolon
var: make_central
whitespace colon
whitespace lparen
var: sr
whitespace colon
whitespace lbrace
var: srpair
rbrace
rparen
whitespace arrow
whitespace lparen
var: dtable
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lparen
var: d
whitespace colon
whitespace lcurly
var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace var: device
lparen
var: dtable
comma
whitespace var: v
rparen
whitespace equalopwhitespace truercurly
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace var: fwstate
whitespace pipe
lambdalparen
var: f
whitespace colon
whitespace lbrace
var: srpair
rbrace
rparen
dotwhitespace var: snd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: dtable
whitespace conjwhitespace lparen
var: f
whitespace equalopwhitespace var: fst
whitespace lparen
var: v
rparen
whitespace implieswhitespace var: central
lparen
var: f
comma
whitespace var: d
rparen
whitespace equalopwhitespace truerparen
whitespace rcurly
semicolon
var: delete_device
whitespace colon
whitespace lparen
var: sr
whitespace colon
whitespace lbrace
var: srpair
rbrace
rparen
whitespace arrow
whitespace lparen
var: dtable
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lparen
var: d
whitespace colon
whitespace lcurly
var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace truercurly
rparen
whitespace arrow
whitespace lparen
var: y
whitespace colon
whitespace lcurly
var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace notwhitespace lbrace
var: v
whitespace equalopwhitespace var: d
rbrace
whitespace conjwhitespace var: device
lparen
var: dtable
comma
whitespace var: v
rparen
whitespace equalopwhitespace truewhitespace whitespace conjwhitespace var: central
lparen
var: sr
comma
whitespace var: v
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace whitespace var: device
lparen
var: dtable
comma
whitespace var: d
rparen
equalopwhitespace truercurly
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace var: fwstate
whitespace pipe
lambdalparen
var: f
whitespace colon
whitespace lbrace
var: srpair
rbrace
rparen
comma
whitespace lparen
var: s
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
dotwhitespace lparen
var: f
whitespace equalopwhitespace var: fst
whitespace lparen
var: v
rparen
whitespace conjwhitespace var: s
whitespace equalopwhitespace var: snd
whitespace lparen
var: v
rparen
rparen
whitespace implieswhitespace whitespace lparen
var: device
lparen
var: s
comma
whitespace var: d
rparen
whitespace equalopwhitespace falsewhitespace conjwhitespace var: central
lparen
var: f
comma
whitespace var: y
rparen
whitespace equalopwhitespace truewhitespace rparen
rcurly
semicolon
var: select
whitespace colon
whitespace lparen
var: db
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
rparen
whitespace arrow
whitespace lparen
var: n
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lparen
var: u
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace var: nlrecord
whitespace pipe
whitespace var: nlmem
lparen
var: db
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace var: nletter
lparen
var: v
rparen
whitespace equalopwhitespace var: n
whitespace conjwhitespace var: user
lparen
var: v
rparen
whitespace equalopwhitespace var: u
whitespace rcurly
semicolon
var: nlmem
whitespace colon
whitespace lparen
var: db
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
rparen
whitespace arrow
whitespace lparen
var: n
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lparen
var: u
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace var: bool
whitespace pipe
whitespace lparen
var: v
whitespace equalopwhitespace truewhitespace iffwhitespace var: nlmem
lparen
var: db
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace truerparen
whitespace conjwhitespace lparen
var: v
whitespace equalopwhitespace falsewhitespace iffwhitespace var: nlmem
lparen
var: db
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace falserparen
whitespace rcurly
semicolon
var: subscribe
whitespace colon
whitespace lparen
var: db
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
rparen
whitespace arrow
whitespace lparen
var: n
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lparen
var: u
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
whitespace pipe
whitespace var: nlmem
lparen
var: db
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace falsewhitespace conjwhitespace var: nlmem
lparen
var: v
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace var: subscribed
lparen
var: v
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace truewhitespace rcurly
semicolon
var: unsubscribe
whitespace colon
whitespace lparen
var: db
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
rparen
whitespace arrow
whitespace lparen
var: n
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lparen
var: u
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
whitespace pipe
whitespace var: nlmem
lparen
var: db
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace var: nlmem
lparen
var: v
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace var: subscribed
lparen
var: v
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace falsewhitespace rcurly
semicolon
var: confirm
whitespace colon
whitespace lparen
var: db
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
rparen
whitespace arrow
whitespace lparen
var: c
whitespace colon
whitespace var: code
rparen
whitespace arrow
whitespace lparen
var: n
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lparen
var: u
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
whitespace pipe
whitespace var: nlmem
lparen
var: db
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace lparen
lparen
var: c
whitespace equalopwhitespace var: Cs
whitespace implieswhitespace var: subscribed
lparen
var: v
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace truerparen
whitespace conjwhitespace lparen
var: c
whitespace equalopwhitespace var: Cu
whitespace implieswhitespace var: subscribed
lparen
var: v
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace falserparen
rparen
whitespace rcurly
semicolon
whitespace var: read
whitespace colon
whitespace lparen
var: db
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
rparen
whitespace arrow
whitespace lparen
var: n
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lparen
var: u
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace lbrace
var: string
rbrace
whitespace pipe
whitespace var: nlmem
lparen
var: db
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace var: subscribed
lparen
var: v
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace var: v
whitespace equalopwhitespace var: articles
lparen
var: v
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace rcurly
semicolon
whitespace var: remove
whitespace colon
whitespace lparen
var: db
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
rparen
whitespace arrow
whitespace lparen
var: n
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lparen
var: u
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace lbrace
var: nlrecord
rbrace
whitespace pipe
whitespace var: nlmem
lparen
var: v
comma
whitespace var: n
comma
whitespace var: u
rparen
whitespace equalopwhitespace falsercurly
semicolon
var: goal
whitespace colon
whitespace lparen
var: sr
whitespace colon
whitespace lbrace
var: srpair
rbrace
rparen
whitespace arrow
whitespace whitespace lparen
var: dtable
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace whitespace lparen
var: d
whitespace colon
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace truercurly
rparen
whitespace arrow
whitespace whitespace lparen
var: x
whitespace colon
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace truercurly
rparen
whitespace arrow
whitespace whitespace lcurly
var: v
whitespace colon
whitespace lparen

  EXPLORED Args.parser output 
 EXPLORED learningOn  true
 EXPLORED bidirectionality  true
 EXPLORED effect-filter  false
 EXPLORED specfile :: ./prudent_tests/hegel/Hoogle+/revAppend.spec
 EXPLORED goal Number :: 0
 EXPLORED Max path length :: 2
 EXPLORED Nested If :: 1typewhitespace var: ipair
semicolon
typewhitespace var: plist
semicolon
stexcwhitespace var: llen
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: pllen
whitespace colon
whitespace lbrace
var: ipair
rbrace
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: lmem
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: int
whitespace colon
whitespace var: bool
semicolon
stexcwhitespace var: lhd
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: plhd
whitespace colon
whitespace lbrace
var: ipair
rbrace
whitespace colon
whitespace var: ipair
semicolon
stexcwhitespace var: last
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: pllast
whitespace colon
whitespace lbrace
var: ipair
rbrace
whitespace colon
whitespace var: ipair
semicolon
stexcwhitespace var: ppr1
whitespace colon
whitespace var: ipair
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: ppr2
whitespace colon
whitespace var: ipair
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: nth
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: int
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: lsnd
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: pen
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: fst
whitespace colon
whitespace var: plist
whitespace colon
whitespace lbrace
var: int
rbrace
semicolon
stexcwhitespace var: snd
whitespace colon
whitespace var: plist
whitespace colon
whitespace lbrace
var: int
rbrace
semicolon
var: ep
whitespace colon
whitespace var: int
semicolon
var: length
whitespace colon
whitespace lparen
var: x
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace var: llen
whitespace lparen
var: x
rparen
whitespace equalopwhitespace var: v
rcurly
semicolon
whitespace var: rev
whitespace colon
whitespace lparen
var: l
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace pipe
whitespace whitespace var: llen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: llen
whitespace lparen
var: l
rparen
whitespace conjwhitespace var: lhd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: last
whitespace lparen
var: l
rparen
whitespace conjwhitespace var: last
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: lhd
whitespace lparen
var: l
rparen
whitespace conjwhitespace var: lsnd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: pen
whitespace lparen
var: l
rparen
whitespace conjwhitespace var: pen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: lsnd
whitespace lparen
var: v
rparen
whitespace rcurly
semicolon
var: compare_lengths
whitespace colon
whitespace lparen
var: x
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lparen
var: y
colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace var: bool
whitespace pipe
whitespace lbrace
var: v
equaloptruerbrace
whitespace iffwhitespace lparen
var: llen
whitespace lparen
var: x
rparen
whitespace equalopwhitespace var: llen
whitespace lparen
var: y
rparen
rparen
rcurly
semicolon
var: cons
whitespace colon
whitespace lparen
var: x
whitespace colon
whitespace var: int
rparen
whitespace arrow
whitespace lparen
var: xs
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace pipe
whitespace var: llen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: llen
whitespace lparen
var: xs
rparen
whitespace pluswhitespace int: 1
whitespace conjwhitespace var: lmem
whitespace lparen
var: v
comma
whitespace var: x
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace var: lhd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: x
whitespace conjwhitespace var: lsnd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: lhd
whitespace lparen
var: xs
rparen
whitespace conjwhitespace var: last
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: last
whitespace lparen
var: xs
rparen
whitespace conjwhitespace var: pen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: pen
whitespace lparen
var: xs
rparen
whitespace rcurly
semicolon
var: hd
whitespace colon
whitespace lparen
var: l
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace var: lmem
whitespace lparen
var: l
comma
whitespace var: v
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace var: lhd
whitespace lparen
var: l
rparen
whitespace equalopwhitespace var: v
whitespace whitespace rcurly
semicolon
var: tl
whitespace colon
whitespace lparen
var: l
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace pipe
whitespace var: llen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: llen
whitespace lparen
var: l
rparen
whitespace ar-minuswhitespace int: 1
whitespace conjwhitespace var: last
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: last
whitespace lparen
var: l
rparen
whitespace conjwhitespace var: lhd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: lsnd
whitespace lparen
var: l
rparen
whitespace conjwhitespace var: pen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: pen
whitespace lparen
var: l
rparen
whitespace rcurly
semicolon
var: nth
whitespace colon
whitespace lparen
var: l
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lparen
var: n
whitespace colon
whitespace var: int
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace var: lmem
whitespace lparen
var: l
comma
whitespace var: v
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace var: nth
whitespace lparen
var: l
comma
whitespace var: n
rparen
whitespace equalopwhitespace var: v
whitespace whitespace rcurly
semicolon
var: append
whitespace colon
whitespace lparen
var: l1
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lparen
var: l2
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace pipe
whitespace whitespace var: llen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: llen
whitespace lparen
var: l1
rparen
whitespace pluswhitespace var: llen
whitespace lparen
var: l2
rparen
whitespace conjwhitespace var: lhd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: lhd
whitespace lparen
var: l1
rparen
whitespace conjwhitespace var: lsnd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: lsnd
whitespace lparen
var: l1
rparen
whitespace conjwhitespace var: last
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: last
whitespace lparen
var: l2
rparen
whitespace conjwhitespace var: pen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: pen
whitespace lparen
var: l2
rparen
whitespace rcurly
semicolon
var: combine
whitespace colon
whitespace lparen
var: l1
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lparen
var: l2
whitespace colon
whitespace lcurly
var: v
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace pipe
whitespace var: llen
whitespace lparen
var: l1
rparen
whitespace equalopwhitespace var: llen
whitespace lparen
var: l2
rparen
rcurly
rparen
whitespace arrow
whitespace whitespace lcurly
var: v
whitespace colon
whitespace lbrace
var: ipair
rbrace
whitespace pipe
whitespace lambdalparen
var: H
whitespace colon
whitespace var: ipair
rparen
comma
whitespace lparen
var: L
whitespace colon
whitespace var: ipair
rparen
dotwhitespace var: pllen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: pllen
whitespace lparen
var: l1
rparen
whitespace conjwhitespace var: plhd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: H
whitespace conjwhitespace var: pllast
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: L
whitespace conjwhitespace var: ppr1
whitespace lparen
var: H
rparen
whitespace equalopwhitespace var: lhd
whitespace lparen
var: l1
rparen
whitespace conjwhitespace var: ppr2
whitespace lparen
var: H
rparen
whitespace equalopwhitespace var: lhd
whitespace lparen
var: l2
rparen
whitespace conjwhitespace var: ppr1
whitespace lparen
var: L
rparen
whitespace equalopwhitespace var: last
whitespace lparen
var: l1
rparen
whitespace conjwhitespace var: ppr2
whitespace lparen
var: L
rparen
whitespace equalopwhitespace var: last
whitespace lparen
var: l2
rparen
whitespace whitespace rcurly
semicolon
var: splitAt
whitespace colon
whitespace lparen
var: y
colon
var: int
rparen
whitespace arrow
whitespace lparen
var: l
whitespace colon
whitespace lcurly
whitespace var: v
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace pipe
whitespace var: llen
whitespace lparen
var: v
rparen
whitespace lessthanopwhitespace var: y
rcurly
rparen
whitespace arrow
whitespace whitespace lcurly
var: v
colon
var: plist
whitespace pipe
whitespace lambdalparen
var: H
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
comma
whitespace lparen
var: L
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
dotwhitespace lparen
var: fst
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: H
whitespace conjwhitespace var: snd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: L
rparen
whitespace implieswhitespace whitespace var: llen
whitespace lparen
var: H
rparen
whitespace equalopwhitespace var: y
whitespace conjwhitespace var: llen
whitespace lparen
var: L
rparen
whitespace equalopwhitespace var: llen
whitespace lparen
var: l
rparen
whitespace ar-minuswhitespace var: y
whitespace whitespace rcurly
semicolon
var: null
whitespace colon
whitespace lparen
var: l
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace var: bool
whitespace pipe
whitespace lbrace
var: v
equaloptruerbrace
whitespace iffwhitespace var: llen
whitespace lparen
var: l
rparen
whitespace equalopwhitespace int: 0
rcurly
semicolon
var: last
whitespace colon
whitespace lparen
var: l
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace var: last
whitespace lparen
var: l
rparen
whitespace equalopwhitespace var: v
rcurly
semicolon
whitespace var: init
whitespace colon
whitespace lparen
var: l
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace pipe
whitespace var: llen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: llen
whitespace lparen
var: v
rparen
whitespace ar-minusint: 1
rcurly
semicolon
whitespace var: take
whitespace colon
whitespace lparen
var: n
whitespace colon
whitespace var: int
rparen
whitespace arrow
whitespace lparen
var: l
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace pipe
whitespace lambdalparen
var: u
whitespace colon
whitespace var: int
rparen
dotwhitespace whitespace var: llen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: n
whitespace conjwhitespace whitespace lparen
var: lmem
whitespace lparen
var: v
comma
whitespace var: u
rparen
whitespace equalopwhitespace truerparen
whitespace implieswhitespace var: lmem
whitespace lparen
var: l
comma
whitespace var: u
rparen
whitespace equalopwhitespace truercurly
semicolon
whitespace stexcwhitespace var: slen
whitespace colon
whitespace lbrace
var: a
rbrace
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: ord
whitespace colon
whitespace var: int
whitespace colon
whitespace var: int
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: bool
semicolon
var: goal
whitespace colon
whitespace lparen
var: z
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace whitespace lcurly
var: v
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace pipe
whitespace lambdalparen
var: u
whitespace colon
whitespace var: int
rparen
comma
whitespace lparen
var: w
whitespace colon
whitespace var: int
rparen
dotwhitespace var: lmem
whitespace lparen
var: v
comma
whitespace var: u
rparen
whitespace equalopwhitespace truewhitespace implieswhitespace var: lmem
whitespace lparen
var: z
comma
whitespace var: u
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace var: llen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: llen
whitespace lparen
var: z
rparen
whitespace pluswhitespace var: llen
whitespace lparen
var: z
rparen
whitespace conjwhitespace var: ord
whitespace lparen
var: u
comma
whitespace var: w
comma
whitespace var: z
rparen
whitespace equalopwhitespace truewhitespace implieswhitespace whitespace lparen
var: ord
whitespace lparen
var: u
comma
whitespace var: w
comma
whitespace var: v
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace var: ord
whitespace lparen
var: w
comma
whitespace var: u
comma
whitespace var: v
rparen
whitespace equalopwhitespace truerparen
whitespace rcurly
semicolon
RelSpec {  SRs ;  PRs ;  TSs  
 Assume false
 name ep : 
 params :
 Type {var_v0:int | true} 
 Assume false
 name length : 
 params :
 Type  Arrow ( ( x : {var_v1:Ty_list int | true} ) -> {v:int | (llen)(x) ==(v)} 
 Assume false
 name rev : 
 params :
 Type  Arrow ( ( l : {var_v2:Ty_list int | true} ) -> {v:Ty_list int | 
 	 Conj <c (llen)(v) ==(llen)(l)
 	 , 
 	 Conj <c (lhd)(v) ==(last)(l)
 	 , 
 	 Conj <c (last)(v) ==(lhd)(l)
 	 , 
 	 Conj <c (lsnd)(v) ==(pen)(l)
 	 , (pen)(v) ==(lsnd)(v) >c  >c  >c  >c } 
 Assume false
 name compare_lengths : 
 params :
 Type  Arrow ( ( x : {var_v3:Ty_list int | true} ) ->  Arrow ( ( y : {var_v4:Ty_list int | true} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  (llen)(x) ==(llen)(y)} 
 Assume false
 name cons : 
 params :
 Type  Arrow ( ( x : {var_v5:int | true} ) ->  Arrow ( ( xs : {var_v6:Ty_list int | true} ) -> {v:Ty_list int | 
 	 Conj <c (llen)(v) ==((llen)(xs) + (1))
 	 , 
 	 Conj <c (lmem)( , v, x ) = (true)
 	 , 
 	 Conj <c (lhd)(v) ==(x)
 	 , 
 	 Conj <c (lsnd)(v) ==(lhd)(xs)
 	 , 
 	 Conj <c (last)(v) ==(last)(xs)
 	 , (pen)(v) ==(pen)(xs) >c  >c  >c  >c  >c } 
 Assume false
 name hd : 
 params :
 Type  Arrow ( ( l : {var_v7:Ty_list int | true} ) -> {v:int | 
 	 Conj <c (lmem)( , l, v ) = (true)
 	 , (lhd)(l) ==(v) >c } 
 Assume false
 name tl : 
 params :
 Type  Arrow ( ( l : {var_v8:Ty_list int | true} ) -> {v:Ty_list int | 
 	 Conj <c (llen)(v) ==((llen)(l) -- (1))
 	 , 
 	 Conj <c (last)(v) ==(last)(l)
 	 , 
 	 Conj <c (lhd)(v) ==(lsnd)(l)
 	 , (pen)(v) ==(pen)(l) >c  >c  >c } 
 Assume false
 name nth : 
 params :
 Type  Arrow ( ( l : {var_v9:Ty_list int | true} ) ->  Arrow ( ( n : {var_v10:int | true} ) -> {v:int | 
 	 Conj <c (lmem)( , l, v ) = (true)
 	 , (nth)( , l, n ) ==(v) >c } 
 Assume false
 name append : 
 params :
 Type  Arrow ( ( l1 : {var_v11:Ty_list int | true} ) ->  Arrow ( ( l2 : {var_v12:Ty_list int | true} ) -> {v:Ty_list int | 
 	 Conj <c (llen)(v) ==((llen)(l1) + (llen)(l2))
 	 , 
 	 Conj <c (lhd)(v) ==(lhd)(l1)
 	 , 
 	 Conj <c (lsnd)(v) ==(lsnd)(l1)
 	 , 
 	 Conj <c (last)(v) ==(last)(l2)
 	 , (pen)(v) ==(pen)(l2) >c  >c  >c  >c } 
 Assume false
 name combine : 
 params :
 Type  Arrow ( ( l1 : {var_v13:Ty_list int | true} ) ->  Arrow ( ( l2 : {v:Ty_list int | (llen)(l1) ==(llen)(l2)} ) -> {v:Ty_list int ipair | Forall 
 	 
 Key =H Value = int ipair
 Key =L Value = int ipair{ 
 	 Conj <c (pllen)(v) ==(pllen)(l1)
 	 , 
 	 Conj <c (plhd)(v) = (H)
 	 , 
 	 Conj <c (pllast)(v) = (L)
 	 , 
 	 Conj <c (ppr1)(H) ==(lhd)(l1)
 	 , 
 	 Conj <c (ppr2)(H) ==(lhd)(l2)
 	 , 
 	 Conj <c (ppr1)(L) ==(last)(l1)
 	 , (ppr2)(L) ==(last)(l2) >c  >c  >c  >c  >c  >c  }} 
 Assume false
 name splitAt : 
 params :
 Type  Arrow ( ( y : {var_v14:int | true} ) ->  Arrow ( ( l : {v:Ty_list int | (llen)(v) > (y)} ) -> {v:int plist | Forall 
 	 
 Key =H Value = Ty_list int
 Key =L Value = Ty_list int{ 
 	 Impl < 
 	 Conj <c (fst)(v) = (H)
 	 , (snd)(v) = (L) >c 
 	 
 	 Conj <c (llen)(H) ==(y)
 	 , (llen)(L) ==((llen)(l) -- (y)) >c  > }} 
 Assume false
 name null : 
 params :
 Type  Arrow ( ( l : {var_v15:Ty_list int | true} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  (llen)(l) ==(0)} 
 Assume false
 name last : 
 params :
 Type  Arrow ( ( l : {var_v16:Ty_list int | true} ) -> {v:int | (last)(l) ==(v)} 
 Assume false
 name init : 
 params :
 Type  Arrow ( ( l : {var_v17:Ty_list int | true} ) -> {v:Ty_list int | (llen)(v) ==((llen)(v) -- (1))} 
 Assume false
 name take : 
 params :
 Type  Arrow ( ( n : {var_v18:int | true} ) ->  Arrow ( ( l : {var_v19:Ty_list int | true} ) -> {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c (llen)(v) ==(n)
 	 , 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , l, u ) = (true) > >c  }} 
 Assume false
 name goal : 
 params :
 Type  Arrow ( ( z : {var_v20:Ty_list int | true} ) -> {v:Ty_list int | Forall 
 	 
 Key =u Value = int
 Key =w Value = int{ 
 	 Impl < (lmem)( , v, u ) = (true)
 	 
 	 Conj <c (lmem)( , z, u ) = (true)
 	 , 
 	 Conj <c (llen)(v) ==((llen)(z) + (llen)(z))
 	 , 
 	 Impl < (ord)( , u, w, z ) = (true)
 	 
 	 Conj <c (ord)( , u, w, v ) = (true)
 	 , (ord)( , w, u, v ) = (true) >c  > >c  >c  > }};  Formulas  }
 INITIAL GAMMA 
 
 goal :  Arrow ( ( z : {var_v20:Ty_list int | true} ) -> {v:Ty_list int | Forall 
 	 
 Key =u Value = int
 Key =w Value = int{ 
 	 Impl < (lmem)( , v, u ) = (true)
 	 
 	 Conj <c (lmem)( , z, u ) = (true)
 	 , 
 	 Conj <c (llen)(v) ==((llen)(z) + (llen)(z))
 	 , 
 	 Impl < (ord)( , u, w, z ) = (true)
 	 
 	 Conj <c (ord)( , u, w, v ) = (true)
 	 , (ord)( , w, u, v ) = (true) >c  > >c  >c  > }}
 take :  Arrow ( ( n : {var_v18:int | true} ) ->  Arrow ( ( l : {var_v19:Ty_list int | true} ) -> {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c (llen)(v) ==(n)
 	 , 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , l, u ) = (true) > >c  }}
 init :  Arrow ( ( l : {var_v17:Ty_list int | true} ) -> {v:Ty_list int | (llen)(v) ==((llen)(v) -- (1))}
 last :  Arrow ( ( l : {var_v16:Ty_list int | true} ) -> {v:int | (last)(l) ==(v)}
 null :  Arrow ( ( l : {var_v15:Ty_list int | true} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  (llen)(l) ==(0)}
 splitAt :  Arrow ( ( y : {var_v14:int | true} ) ->  Arrow ( ( l : {v:Ty_list int | (llen)(v) > (y)} ) -> {v:int plist | Forall 
 	 
 Key =H Value = Ty_list int
 Key =L Value = Ty_list int{ 
 	 Impl < 
 	 Conj <c (fst)(v) = (H)
 	 , (snd)(v) = (L) >c 
 	 
 	 Conj <c (llen)(H) ==(y)
 	 , (llen)(L) ==((llen)(l) -- (y)) >c  > }}
 combine :  Arrow ( ( l1 : {var_v13:Ty_list int | true} ) ->  Arrow ( ( l2 : {v:Ty_list int | (llen)(l1) ==(llen)(l2)} ) -> {v:Ty_list int ipair | Forall 
 	 
 Key =H Value = int ipair
 Key =L Value = int ipair{ 
 	 Conj <c (pllen)(v) ==(pllen)(l1)
 	 , 
 	 Conj <c (plhd)(v) = (H)
 	 , 
 	 Conj <c (pllast)(v) = (L)
 	 , 
 	 Conj <c (ppr1)(H) ==(lhd)(l1)
 	 , 
 	 Conj <c (ppr2)(H) ==(lhd)(l2)
 	 , 
 	 Conj <c (ppr1)(L) ==(last)(l1)
 	 , (ppr2)(L) ==(last)(l2) >c  >c  >c  >c  >c  >c  }}
 append :  Arrow ( ( l1 : {var_v11:Ty_list int | true} ) ->  Arrow ( ( l2 : {var_v12:Ty_list int | true} ) -> {v:Ty_list int | 
 	 Conj <c (llen)(v) ==((llen)(l1) + (llen)(l2))
 	 , 
 	 Conj <c (lhd)(v) ==(lhd)(l1)
 	 , 
 	 Conj <c (lsnd)(v) ==(lsnd)(l1)
 	 , 
 	 Conj <c (last)(v) ==(last)(l2)
 	 , (pen)(v) ==(pen)(l2) >c  >c  >c  >c }
 nth :  Arrow ( ( l : {var_v9:Ty_list int | true} ) ->  Arrow ( ( n : {var_v10:int | true} ) -> {v:int | 
 	 Conj <c (lmem)( , l, v ) = (true)
 	 , (nth)( , l, n ) ==(v) >c }
 tl :  Arrow ( ( l : {var_v8:Ty_list int | true} ) -> {v:Ty_list int | 
 	 Conj <c (llen)(v) ==((llen)(l) -- (1))
 	 , 
 	 Conj <c (last)(v) ==(last)(l)
 	 , 
 	 Conj <c (lhd)(v) ==(lsnd)(l)
 	 , (pen)(v) ==(pen)(l) >c  >c  >c }
 hd :  Arrow ( ( l : {var_v7:Ty_list int | true} ) -> {v:int | 
 	 Conj <c (lmem)( , l, v ) = (true)
 	 , (lhd)(l) ==(v) >c }
 cons :  Arrow ( ( x : {var_v5:int | true} ) ->  Arrow ( ( xs : {var_v6:Ty_list int | true} ) -> {v:Ty_list int | 
 	 Conj <c (llen)(v) ==((llen)(xs) + (1))
 	 , 
 	 Conj <c (lmem)( , v, x ) = (true)
 	 , 
 	 Conj <c (lhd)(v) ==(x)
 	 , 
 	 Conj <c (lsnd)(v) ==(lhd)(xs)
 	 , 
 	 Conj <c (last)(v) ==(last)(xs)
 	 , (pen)(v) ==(pen)(xs) >c  >c  >c  >c  >c }
 compare_lengths :  Arrow ( ( x : {var_v3:Ty_list int | true} ) ->  Arrow ( ( y : {var_v4:Ty_list int | true} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  (llen)(x) ==(llen)(y)}
 rev :  Arrow ( ( l : {var_v2:Ty_list int | true} ) -> {v:Ty_list int | 
 	 Conj <c (llen)(v) ==(llen)(l)
 	 , 
 	 Conj <c (lhd)(v) ==(last)(l)
 	 , 
 	 Conj <c (last)(v) ==(lhd)(l)
 	 , 
 	 Conj <c (lsnd)(v) ==(pen)(l)
 	 , (pen)(v) ==(lsnd)(v) >c  >c  >c  >c }
 length :  Arrow ( ( x : {var_v1:Ty_list int | true} ) -> {v:int | (llen)(x) ==(v)}
 ep : {var_v0:int | true}
 INITIAL SIGMA 
 
 TypeNames 
 
 plist
 ipair
 Qualifiers 
 
 Qual llen :  :-> Ty_list int :-> int
 Qual pllen :  :-> Ty_list int ipair :-> int
 Qual lmem :  :-> Ty_list int :-> int :-> Ty_bool
 Qual lhd :  :-> Ty_list int :-> int
 Qual plhd :  :-> Ty_list int ipair :-> int ipair
 Qual last :  :-> Ty_list int :-> int
 Qual pllast :  :-> Ty_list int ipair :-> int ipair
 Qual ppr1 :  :-> int ipair :-> int
 Qual ppr2 :  :-> int ipair :-> int
 Qual nth :  :-> Ty_list int :-> int :-> int
 Qual lsnd :  :-> Ty_list int :-> int
 Qual pen :  :-> Ty_list int :-> int
 Qual fst :  :-> int plist :-> Ty_list int
 Qual snd :  :-> int plist :-> Ty_list int
 Qual slen :  :-> Ty_list int a :-> int
 Qual ord :  :-> int :-> int :-> Ty_list int :-> Ty_bool
 Show ***********Calling S-FUNC synthesize***************
 Show Uncurried , z:{var_v20:Ty_list int | true} -> {v:Ty_list int | Forall 
 	 
 Key =u Value = int
 Key =w Value = int{ 
 	 Impl < (lmem)( , v, u ) = (true)
 	 
 	 Conj <c (lmem)( , z, u ) = (true)
 	 , 
 	 Conj <c (llen)(v) ==((llen)(z) + (llen)(z))
 	 , 
 	 Impl < (ord)( , u, w, z ) = (true)
 	 
 	 Conj <c (ord)( , u, w, v ) = (true)
 	 , (ord)( , w, u, v ) = (true) >c  > >c  >c  > }}
 Decreasing Measure z
 Decreasing Type {var_v20:Ty_list int | true}
 Calculated Decreasing Predicate (slen)(z) > (slen)(var_v20)
 Calculated Decreased Goal Type  Arrow ( ( z1 : {var_v20:Ty_list int | 
 	 Conj <c true
 	 , (slen)(z) > (slen)(var_v20) >c } ) -> {v:Ty_list int | Forall 
 	 
 Key =u Value = int
 Key =w Value = int{ 
 	 Impl < (lmem)( , v, u ) = (true)
 	 
 	 Conj <c (lmem)( , z, u ) = (true)
 	 , 
 	 Conj <c (llen)(v) ==((llen)(z) + (llen)(z))
 	 , 
 	 Impl < (ord)( , u, w, z ) = (true)
 	 
 	 Conj <c (ord)( , u, w, v ) = (true)
 	 , (ord)( , w, u, v ) = (true) >c  > >c  >c  > }}
 Show Trying :: Top-level Match
 Show :: Synthesize Match {v:Ty_list int | Forall 
 	 
 Key =u Value = int
 Key =w Value = int{ 
 	 Impl < (lmem)( , v, u ) = (true)
 	 
 	 Conj <c (lmem)( , z, u ) = (true)
 	 , 
 	 Conj <c (llen)(v) ==((llen)(z) + (llen)(z))
 	 , 
 	 Impl < (ord)( , u, w, z ) = (true)
 	 
 	 Conj <c (ord)( , u, w, v ) = (true)
 	 , (ord)( , w, u, v ) = (true) >c  > >c  >c  > }}
 Show :: List Ty_list int
 Show LIST CASE ??Ty_list int PHI trueNil Length (slen)(z) =={(0)}
 Show Predicate Cons branch :: 
 	 Conj <c (slen)(z) ==((slen)(var_xs22) + {(1)})
 	 , (slen)(z) > {(0)} >c 
 Show Predicate Nil branch :: (slen)(z) =={(0)}
 Show ***********Calling Scalar synthesize***************
 esynthesizeScalar for {v:Ty_list int | Forall 
 	 
 Key =u Value = int
 Key =w Value = int{ 
 	 Impl < (lmem)( , v, u ) = (true)
 	 
 	 Conj <c (lmem)( , z, u ) = (true)
 	 , 
 	 Conj <c (llen)(v) ==((llen)(z) + (llen)(z))
 	 , 
 	 Impl < (ord)( , u, w, z ) = (true)
 	 
 	 Conj <c (ord)( , u, w, v ) = (true)
 	 , (ord)( , w, u, v ) = (true) >c  > >c  >c  > }}
 
 Enumerating a Scalar Term z
 
 Type of the Scalar Term {var_v20:Ty_list int | true}          
# of Final Z3 expressions 7
 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 
 FaileD the subtype check T_vi <: T_goal
  Entering Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  , 
 goal, 
 take, 
 init, 
 append, 
 tl, 
 cons, 
 rev
 ############################################################
  Synthesizing the Function application Pure Component goal
  *************** Trying Arrow Component ************goal :  Arrow ( ( z1 : {var_v20:Ty_list int | 
 	 Conj <c true
 	 , (slen)(z) > (slen)(var_v20) >c } ) -> {v:Ty_list int | Forall 
 	 
 Key =u Value = int
 Key =w Value = int{ 
 	 Impl < (lmem)( , v, u ) = (true)
 	 
 	 Conj <c (lmem)( , z, u ) = (true)
 	 , 
 	 Conj <c (llen)(v) ==((llen)(z) + (llen)(z))
 	 , 
 	 Impl < (ord)( , u, w, z ) = (true)
 	 
 	 Conj <c (ord)( , u, w, v ) = (true)
 	 , (ord)( , w, u, v ) = (true) >c  > >c  >c  > }}
  *************** Synthesizing Args ei : ti for ************goal
 ##################################################################################
  Synthesizing the 1th argument for Function goal
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v20:Ty_list int | 
 	 Conj <c true
 	 , (slen)(z) > (slen)(var_v20) >c }
 
 Enumerating a Scalar Term z
 
 Type of the Scalar Term {var_v20:Ty_list int | true}
# of Final Z3 expressions 2
 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 
 FaileD the subtype check T_vi <: T_goal
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  *************** Synthesizing Args ei : Failed for some  arg
 ############################################################
  Synthesizing the Function application Pure Component take
  *************** Trying Arrow Component ************take :  Arrow ( ( n : {var_v18:int | true} ) ->  Arrow ( ( l : {var_v19:Ty_list int | true} ) -> {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c (llen)(v) ==(n)
 	 , 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , l, u ) = (true) > >c  }}
  *************** Synthesizing Args ei : ti for ************take
 ##################################################################################
  Synthesizing the 1th argument for Function take
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v18:int | true}
 
 Enumerating a Scalar Term ep
 
 Type of the Scalar Term {var_v0:int | true}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 1th Args option for take : ep
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 2th argument for Function take
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v19:Ty_list int | true}
 
 Enumerating a Scalar Term z
 
 Type of the Scalar Term {var_v20:Ty_list int | true}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term z1
 
 Type of the Scalar Term {var_v20:Ty_list int | 
 	 Conj <c true
 	 , (slen)(z) > (slen)(var_v20) >c }
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 2th Args option for take : z1
 >>>>>>>>>>>>>>>>>>> 2th Args option for take : z
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  *************** Successfully Synthesized Args ei Forall i 
 1 th Argument Options for take
 EI ep
 2 th Argument Options for take
 EI z1
 EI z
 # of Possible Argument Options for take 2
 # of Possible Argument Options for take 2
 Possible Arg Options 
 EI ep
 EI z1
 Possible Arg Options 
 EI ep
 EI z
 Show f (ei, e2, ....en) Case
 Finding Already seen tree for apply take  (, ep ), z1 )
 Typechecking apply take  (, ep ), z1 )
 Against {v:Ty_list int | Forall 
 	 
 Key =u Value = int
 Key =w Value = int{ 
 	 Impl < (lmem)( , v, u ) = (true)
 	 
 	 Conj <c (lmem)( , z, u ) = (true)
 	 , 
 	 Conj <c (llen)(v) ==((llen)(z) + (llen)(z))
 	 , 
 	 Impl < (ord)( , u, w, z ) = (true)
 	 
 	 Conj <c (ord)( , u, w, v ) = (true)
 	 , (ord)( , w, u, v ) = (true) >c  > >c  >c  > }}
 Typechecking the Term apply take  (, ep ), z1 )
 Against {v:Ty_list int | Forall 
 	 
 Key =u Value = int
 Key =w Value = int{ 
 	 Impl < (lmem)( , v, u ) = (true)
 	 
 	 Conj <c (lmem)( , z, u ) = (true)
 	 , 
 	 Conj <c (llen)(v) ==((llen)(z) + (llen)(z))
 	 , 
 	 Impl < (ord)( , u, w, z ) = (true)
 	 
 	 Conj <c (ord)( , u, w, v ) = (true)
 	 , (ord)( , w, u, v ) = (true) >c  > >c  >c  > }}
 Argument ep :: {var_v0:int | true} | true
 Argument z1 :: {var_v20:Ty_list int | 
 	 Conj <c true
 	 , (slen)(z) > (slen)(var_v20) >c } | 
 	 Conj <c true
 	 , (slen)(z) > (slen)(z1) >c 
 AppType Type {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c (llen)(v) ==(ep)
 	 , 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , z1, u ) = (true) > >c  }}                  
# of Final Z3 expressions 11
 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply take  (, ep ), z1 )
 Finding Already seen tree for apply take  (, ep ), z )
 Typechecking apply take  (, ep ), z )
 Against {v:Ty_list int | Forall 
 	 
 Key =u Value = int
 Key =w Value = int{ 
 	 Impl < (lmem)( , v, u ) = (true)
 	 
 	 Conj <c (lmem)( , z, u ) = (true)
 	 , 
 	 Conj <c (llen)(v) ==((llen)(z) + (llen)(z))
 	 , 
 	 Impl < (ord)( , u, w, z ) = (true)
 	 
 	 Conj <c (ord)( , u, w, v ) = (true)
 	 , (ord)( , w, u, v ) = (true) >c  > >c  >c  > }}
 Typechecking the Term apply take  (, ep ), z )
 Against {v:Ty_list int | Forall 
 	 
 Key =u Value = int
 Key =w Value = int{ 
 	 Impl < (lmem)( , v, u ) = (true)
 	 
 	 Conj <c (lmem)( , z, u ) = (true)
 	 , 
 	 Conj <c (llen)(v) ==((llen)(z) + (llen)(z))
 	 , 
 	 Impl < (ord)( , u, w, z ) = (true)
 	 
 	 Conj <c (ord)( , u, w, v ) = (true)
 	 , (ord)( , w, u, v ) = (true) >c  > >c  >c  > }}
 Argument ep :: {var_v0:int | true} | true
 Argument z :: {var_v20:Ty_list int | true} | true
 AppType Type {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c (llen)(v) ==(ep)
 	 , 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , z, u ) = (true) > >c  }}                  
# of Final Z3 expressions 11
 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply take  (, ep ), z )
  ###################################################
  The Choice of Function take Was Ill Fated Try Next Choice of function {v:Ty_list int | Forall 
 	 
 Key =u Value = int
 Key =w Value = int{ 
 	 Impl < (lmem)( , v, u ) = (true)
 	 
 	 Conj <c (lmem)( , z, u ) = (true)
 	 , 
 	 Conj <c (llen)(v) ==((llen)(z) + (llen)(z))
 	 , 
 	 Impl < (ord)( , u, w, z ) = (true)
 	 
 	 Conj <c (ord)( , u, w, v ) = (true)
 	 , (ord)( , w, u, v ) = (true) >c  > >c  >c  > }}
 ############################################################
  Synthesizing the Function application Pure Component init
  *************** Trying Arrow Component ************init :  Arrow ( ( l : {var_v17:Ty_list int | true} ) -> {v:Ty_list int | (llen)(v) ==((llen)(v) -- (1))}
  *************** Synthesizing Args ei : ti for ************init
 ##################################################################################
  Synthesizing the 1th argument for Function init
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v17:Ty_list int | true}
 
 Enumerating a Scalar Term z
 
 Type of the Scalar Term {var_v20:Ty_list int | true}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term z1
 
 Type of the Scalar Term {var_v20:Ty_list int | 
 	 Conj <c true
 	 , (slen)(z) > (slen)(var_v20) >c }
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term l
 
 Type of the Scalar Term {var_v19:Ty_list int | true}
 ################################################
 Skipping Variable l As this a  Formal Parameter to the current function Call
 Outer Function calls init
 ################################################
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 1th Args option for init : z1
 >>>>>>>>>>>>>>>>>>> 1th Args option for init : z
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  *************** Successfully Synthesized Args ei Forall i 
 1 th Argument Options for init
 EI z1
 EI z
 # of Possible Argument Options for init 2
 # of Possible Argument Options for init 2
 Possible Arg Options 
 EI z1
 Possible Arg Options 
 EI z
 Apply Single Argument Case : f (ei) Case init
  Case : f (ei) Case init z1
 Finding Already seen tree for apply init  (, z1 )
 Typechecking apply init  (, z1 )
 Against {v:Ty_list int | Forall 
 	 
 Key =u Value = int
 Key =w Value = int{ 
 	 Impl < (lmem)( , v, u ) = (true)
 	 
 	 Conj <c (lmem)( , z, u ) = (true)
 	 , 
 	 Conj <c (llen)(v) ==((llen)(z) + (llen)(z))
 	 , 
 	 Impl < (ord)( , u, w, z ) = (true)
 	 
 	 Conj <c (ord)( , u, w, v ) = (true)
 	 , (ord)( , w, u, v ) = (true) >c  > >c  >c  > }}
 Typechecking the Term apply init  (, z1 )
 Against {v:Ty_list int | Forall 
 	 
 Key =u Value = int
 Key =w Value = int{ 
 	 Impl < (lmem)( , v, u ) = (true)
 	 
 	 Conj <c (lmem)( , z, u ) = (true)
 	 , 
 	 Conj <c (llen)(v) ==((llen)(z) + (llen)(z))
 	 , 
 	 Impl < (ord)( , u, w, z ) = (true)
 	 
 	 Conj <c (ord)( , u, w, v ) = (true)
 	 , (ord)( , w, u, v ) = (true) >c  > >c  >c  > }}
 Argument z1 :: {var_v20:Ty_list int | 
 	 Conj <c true
 	 , (slen)(z) > (slen)(var_v20) >c } | 
 	 Conj <c true
 	 , (slen)(z) > (slen)(z1) >c 
 AppType Type {v:Ty_list int | (llen)(v) ==((llen)(v) -- (1))}          
# of Final Z3 expressions 11
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
  Show *************** TypeChecking Succsessful {v:Ty_list int | (llen)(v) ==((llen)(v) -- (1))}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 let _lbv0 = apply init  (, z1 )
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  Case : f (ei) Case init z
 Finding Already seen tree for apply init  (, z )
 Typechecking apply init  (, z )
 Against {v:Ty_list int | Forall 
 	 
 Key =u Value = int
 Key =w Value = int{ 
 	 Impl < (lmem)( , v, u ) = (true)
 	 
 	 Conj <c (lmem)( , z, u ) = (true)
 	 , 
 	 Conj <c (llen)(v) ==((llen)(z) + (llen)(z))
 	 , 
 	 Impl < (ord)( , u, w, z ) = (true)
 	 
 	 Conj <c (ord)( , u, w, v ) = (true)
 	 , (ord)( , w, u, v ) = (true) >c  > >c  >c  > }}
 Typechecking the Term apply init  (, z )
 Against {v:Ty_list int | Forall 
 	 
 Key =u Value = int
 Key =w Value = int{ 
 	 Impl < (lmem)( , v, u ) = (true)
 	 
 	 Conj <c (lmem)( , z, u ) = (true)
 	 , 
 	 Conj <c (llen)(v) ==((llen)(z) + (llen)(z))
 	 , 
 	 Impl < (ord)( , u, w, z ) = (true)
 	 
 	 Conj <c (ord)( , u, w, v ) = (true)
 	 , (ord)( , w, u, v ) = (true) >c  > >c  >c  > }}
 Argument z :: {var_v20:Ty_list int | true} | true
 AppType Type {v:Ty_list int | (llen)(v) ==((llen)(v) -- (1))}          
# of Final Z3 expressions 11
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
  Show *************** TypeChecking Succsessful {v:Ty_list int | (llen)(v) ==((llen)(v) -- (1))}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 let _lbv1 = apply init  (, z )
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  ###################################################
  The Choice of Function init Was Succefull for {v:Ty_list int | Forall 
 	 
 Key =u Value = int
 Key =w Value = int{ 
 	 Impl < (lmem)( , v, u ) = (true)
 	 
 	 Conj <c (lmem)( , z, u ) = (true)
 	 , 
 	 Conj <c (llen)(v) ==((llen)(z) + (llen)(z))
 	 , 
 	 Impl < (ord)( , u, w, z ) = (true)
 	 
 	 Conj <c (ord)( , u, w, v ) = (true)
 	 , (ord)( , w, u, v ) = (true) >c  > >c  >c  > }} Continuing for completeness
  ###################################################
 Show :: Successfully Synthesisized Nil Branch 
 Now Trying Cons
 Show ***********Calling Scalar synthesize***************
 esynthesizeScalar for {v:Ty_list int | Forall 
 	 
 Key =u Value = int
 Key =w Value = int{ 
 	 Impl < (lmem)( , v, u ) = (true)
 	 
 	 Conj <c (lmem)( , z, u ) = (true)
 	 , 
 	 Conj <c (llen)(v) ==((llen)(z) + (llen)(z))
 	 , 
 	 Impl < (ord)( , u, w, z ) = (true)
 	 
 	 Conj <c (ord)( , u, w, v ) = (true)
 	 , (ord)( , w, u, v ) = (true) >c  > >c  >c  > }}
 
 Enumerating a Scalar Term z
 
 Type of the Scalar Term {var_v20:Ty_list int | true}          
# of Final Z3 expressions 8
 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 
 FaileD the subtype check T_vi <: T_goal
  Entering Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  , 
 goal, 
 take, 
 init, 
 append, 
 tl, 
 cons, 
 rev
 ############################################################
  Synthesizing the Function application Pure Component goal
  *************** Trying Arrow Component ************goal :  Arrow ( ( z1 : {var_v20:Ty_list int | 
 	 Conj <c true
 	 , (slen)(z) > (slen)(var_v20) >c } ) -> {v:Ty_list int | Forall 
 	 
 Key =u Value = int
 Key =w Value = int{ 
 	 Impl < (lmem)( , v, u ) = (true)
 	 
 	 Conj <c (lmem)( , z, u ) = (true)
 	 , 
 	 Conj <c (llen)(v) ==((llen)(z) + (llen)(z))
 	 , 
 	 Impl < (ord)( , u, w, z ) = (true)
 	 
 	 Conj <c (ord)( , u, w, v ) = (true)
 	 , (ord)( , w, u, v ) = (true) >c  > >c  >c  > }}
  *************** Synthesizing Args ei : ti for ************goal
 ##################################################################################
  Synthesizing the 1th argument for Function goal
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v20:Ty_list int | 
 	 Conj <c true
 	 , (slen)(z) > (slen)(var_v20) >c }
 
 Enumerating a Scalar Term z
 
 Type of the Scalar Term {var_v20:Ty_list int | true}
# of Final Z3 expressions 3
 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 
 FaileD the subtype check T_vi <: T_goal
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  *************** Synthesizing Args ei : Failed for some  arg
 ############################################################
  Synthesizing the Function application Pure Component take
  *************** Trying Arrow Component ************take :  Arrow ( ( n : {var_v18:int | true} ) ->  Arrow ( ( l : {var_v19:Ty_list int | true} ) -> {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c (llen)(v) ==(n)
 	 , 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , l, u ) = (true) > >c  }}
  *************** Synthesizing Args ei : ti for ************take
 ##################################################################################
  Synthesizing the 1th argument for Function take
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v18:int | true}
 
 Enumerating a Scalar Term var_x21
 
 Type of the Scalar Term {v_0:int | true}
 ################################################
 Skipping Variable var_x21 As this a Ghost Variable
 ################################################
 
 Enumerating a Scalar Term ep
 
 Type of the Scalar Term {var_v0:int | true}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 1th Args option for take : ep
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 2th argument for Function take
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v19:Ty_list int | true}
 
 Enumerating a Scalar Term z
 
 Type of the Scalar Term {var_v20:Ty_list int | true}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term z1
 
 Type of the Scalar Term {var_v20:Ty_list int | 
 	 Conj <c true
 	 , (slen)(z) > (slen)(var_v20) >c }
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 2th Args option for take : z1
 >>>>>>>>>>>>>>>>>>> 2th Args option for take : z
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  *************** Successfully Synthesized Args ei Forall i 
 1 th Argument Options for take
 EI ep
 2 th Argument Options for take
 EI z1
 EI z
 # of Possible Argument Options for take 2
 # of Possible Argument Options for take 2
 Possible Arg Options 
 EI ep
 EI z1
 Possible Arg Options 
 EI ep
 EI z
 Show f (ei, e2, ....en) Case
 Finding Already seen tree for apply take  (, ep ), z1 )
 Typechecking apply take  (, ep ), z1 )
 Against {v:Ty_list int | Forall 
 	 
 Key =u Value = int
 Key =w Value = int{ 
 	 Impl < (lmem)( , v, u ) = (true)
 	 
 	 Conj <c (lmem)( , z, u ) = (true)
 	 , 
 	 Conj <c (llen)(v) ==((llen)(z) + (llen)(z))
 	 , 
 	 Impl < (ord)( , u, w, z ) = (true)
 	 
 	 Conj <c (ord)( , u, w, v ) = (true)
 	 , (ord)( , w, u, v ) = (true) >c  > >c  >c  > }}
 Typechecking the Term apply take  (, ep ), z1 )
 Against {v:Ty_list int | Forall 
 	 
 Key =u Value = int
 Key =w Value = int{ 
 	 Impl < (lmem)( , v, u ) = (true)
 	 
 	 Conj <c (lmem)( , z, u ) = (true)
 	 , 
 	 Conj <c (llen)(v) ==((llen)(z) + (llen)(z))
 	 , 
 	 Impl < (ord)( , u, w, z ) = (true)
 	 
 	 Conj <c (ord)( , u, w, v ) = (true)
 	 , (ord)( , w, u, v ) = (true) >c  > >c  >c  > }}
 Argument ep :: {var_v0:int | true} | true
 Argument z1 :: {var_v20:Ty_list int | 
 	 Conj <c true
 	 , (slen)(z) > (slen)(var_v20) >c } | 
 	 Conj <c true
 	 , (slen)(z) > (slen)(z1) >c 
 AppType Type {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c (llen)(v) ==(ep)
 	 , 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , z1, u ) = (true) > >c  }}                  
# of Final Z3 expressions 11
 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply take  (, ep ), z1 )
 Finding Already seen tree for apply take  (, ep ), z )
 Typechecking apply take  (, ep ), z )
 Against {v:Ty_list int | Forall 
 	 
 Key =u Value = int
 Key =w Value = int{ 
 	 Impl < (lmem)( , v, u ) = (true)
 	 
 	 Conj <c (lmem)( , z, u ) = (true)
 	 , 
 	 Conj <c (llen)(v) ==((llen)(z) + (llen)(z))
 	 , 
 	 Impl < (ord)( , u, w, z ) = (true)
 	 
 	 Conj <c (ord)( , u, w, v ) = (true)
 	 , (ord)( , w, u, v ) = (true) >c  > >c  >c  > }}
 Typechecking the Term apply take  (, ep ), z )
 Against {v:Ty_list int | Forall 
 	 
 Key =u Value = int
 Key =w Value = int{ 
 	 Impl < (lmem)( , v, u ) = (true)
 	 
 	 Conj <c (lmem)( , z, u ) = (true)
 	 , 
 	 Conj <c (llen)(v) ==((llen)(z) + (llen)(z))
 	 , 
 	 Impl < (ord)( , u, w, z ) = (true)
 	 
 	 Conj <c (ord)( , u, w, v ) = (true)
 	 , (ord)( , w, u, v ) = (true) >c  > >c  >c  > }}
 Argument ep :: {var_v0:int | true} | true
 Argument z :: {var_v20:Ty_list int | true} | true
 AppType Type {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c (llen)(v) ==(ep)
 	 , 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , z, u ) = (true) > >c  }}                  
# of Final Z3 expressions 11
 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply take  (, ep ), z )
  ###################################################
  The Choice of Function take Was Ill Fated Try Next Choice of function {v:Ty_list int | Forall 
 	 
 Key =u Value = int
 Key =w Value = int{ 
 	 Impl < (lmem)( , v, u ) = (true)
 	 
 	 Conj <c (lmem)( , z, u ) = (true)
 	 , 
 	 Conj <c (llen)(v) ==((llen)(z) + (llen)(z))
 	 , 
 	 Impl < (ord)( , u, w, z ) = (true)
 	 
 	 Conj <c (ord)( , u, w, v ) = (true)
 	 , (ord)( , w, u, v ) = (true) >c  > >c  >c  > }}
 ############################################################
  Synthesizing the Function application Pure Component init
  *************** Trying Arrow Component ************init :  Arrow ( ( l : {var_v17:Ty_list int | true} ) -> {v:Ty_list int | (llen)(v) ==((llen)(v) -- (1))}
  *************** Synthesizing Args ei : ti for ************init
 ##################################################################################
  Synthesizing the 1th argument for Function init
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v17:Ty_list int | true}
 
 Enumerating a Scalar Term z
 
 Type of the Scalar Term {var_v20:Ty_list int | true}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term z1
 
 Type of the Scalar Term {var_v20:Ty_list int | 
 	 Conj <c true
 	 , (slen)(z) > (slen)(var_v20) >c }
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term l
 
 Type of the Scalar Term {var_v19:Ty_list int | true}
 ################################################
 Skipping Variable l As this a  Formal Parameter to the current function Call
 Outer Function calls init
 ################################################
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 1th Args option for init : z1
 >>>>>>>>>>>>>>>>>>> 1th Args option for init : z
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  *************** Successfully Synthesized Args ei Forall i 
 1 th Argument Options for init
 EI z1
 EI z
 # of Possible Argument Options for init 2
 # of Possible Argument Options for init 2
 Possible Arg Options 
 EI z1
 Possible Arg Options 
 EI z
 Apply Single Argument Case : f (ei) Case init
  Case : f (ei) Case init z1
 Finding Already seen tree for apply init  (, z1 )
 Found _lbv0
  Case : f (ei) Case init z
 Finding Already seen tree for apply init  (, z )
 Found _lbv1
  ###################################################
  The Choice of Function init Was Succefull for {v:Ty_list int | Forall 
 	 
 Key =u Value = int
 Key =w Value = int{ 
 	 Impl < (lmem)( , v, u ) = (true)
 	 
 	 Conj <c (lmem)( , z, u ) = (true)
 	 , 
 	 Conj <c (llen)(v) ==((llen)(z) + (llen)(z))
 	 , 
 	 Impl < (ord)( , u, w, z ) = (true)
 	 
 	 Conj <c (ord)( , u, w, v ) = (true)
 	 , (ord)( , w, u, v ) = (true) >c  > >c  >c  > }} Continuing for completeness
  ###################################################
 Show :: Successfully Synthesized Cons Branch 2
 EXPLORED :: Show Found Match match x with ... solution
 *************************
 Success : 
 Number of synthesized programs : 1
 ************************* : 
  EXPLORED Args.parser output 
 EXPLORED learningOn  true
 EXPLORED bidirectionality  true
 EXPLORED effect-filter  false
 EXPLORED specfile :: ./prudent_tests/hegel/Hoogle+/nthIcr.spec
 EXPLORED goal Number :: 0
 EXPLORED Max path length :: 2
 EXPLORED Nested If :: 1typewhitespace var: ipair
semicolon
typewhitespace var: plist
semicolon
stexcwhitespace var: llen
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: pllen
whitespace colon
whitespace lbrace
var: ipair
rbrace
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: lmem
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: int
whitespace colon
whitespace var: bool
semicolon
stexcwhitespace var: lhd
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: plhd
whitespace colon
whitespace lbrace
var: ipair
rbrace
whitespace colon
whitespace var: ipair
semicolon
stexcwhitespace var: last
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: pllast
whitespace colon
whitespace lbrace
var: ipair
rbrace
whitespace colon
whitespace var: ipair
semicolon
stexcwhitespace var: ppr1
whitespace colon
whitespace var: ipair
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: ppr2
whitespace colon
whitespace var: ipair
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: nth
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: int
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: lsnd
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: pen
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: fst
whitespace colon
whitespace var: plist
whitespace colon
whitespace lbrace
var: int
rbrace
semicolon
stexcwhitespace var: snd
whitespace colon
whitespace var: plist
whitespace colon
whitespace lbrace
var: int
rbrace
semicolon
var: ep
whitespace colon
whitespace var: int
semicolon
var: length
whitespace colon
whitespace lparen
var: x
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace var: llen
whitespace lparen
var: x
rparen
whitespace equalopwhitespace var: v
rcurly
semicolon
whitespace var: rev
whitespace colon
whitespace lparen
var: l
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace pipe
whitespace whitespace var: llen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: llen
whitespace lparen
var: l
rparen
whitespace conjwhitespace var: lhd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: last
whitespace lparen
var: l
rparen
whitespace conjwhitespace var: last
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: lhd
whitespace lparen
var: l
rparen
whitespace conjwhitespace var: lsnd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: pen
whitespace lparen
var: l
rparen
whitespace conjwhitespace var: pen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: lsnd
whitespace lparen
var: v
rparen
whitespace rcurly
semicolon
var: compare_lengths
whitespace colon
whitespace lparen
var: x
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lparen
var: y
colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace var: bool
whitespace pipe
whitespace lbrace
var: v
equaloptruerbrace
whitespace iffwhitespace lparen
var: llen
whitespace lparen
var: x
rparen
whitespace equalopwhitespace var: llen
whitespace lparen
var: y
rparen
rparen
rcurly
semicolon
var: cons
whitespace colon
whitespace lparen
var: x
whitespace colon
whitespace var: int
rparen
whitespace arrow
whitespace lparen
var: xs
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace pipe
whitespace var: llen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: llen
whitespace lparen
var: xs
rparen
whitespace pluswhitespace int: 1
whitespace conjwhitespace var: lmem
whitespace lparen
var: v
comma
whitespace var: x
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace var: lhd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: x
whitespace conjwhitespace var: lsnd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: lhd
whitespace lparen
var: xs
rparen
whitespace conjwhitespace var: last
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: last
whitespace lparen
var: xs
rparen
whitespace conjwhitespace var: pen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: pen
whitespace lparen
var: xs
rparen
whitespace rcurly
semicolon
var: hd
whitespace colon
whitespace lparen
var: l
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace var: lmem
whitespace lparen
var: l
comma
whitespace var: v
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace var: lhd
whitespace lparen
var: l
rparen
whitespace equalopwhitespace var: v
whitespace whitespace rcurly
semicolon
var: tl
whitespace colon
whitespace lparen
var: l
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace pipe
whitespace var: llen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: llen
whitespace lparen
var: l
rparen
whitespace ar-minuswhitespace int: 1
whitespace conjwhitespace var: last
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: last
whitespace lparen
var: l
rparen
whitespace conjwhitespace var: lhd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: lsnd
whitespace lparen
var: l
rparen
whitespace conjwhitespace var: pen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: pen
whitespace lparen
var: l
rparen
whitespace rcurly
semicolon
var: nth
whitespace colon
whitespace lparen
var: l
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lparen
var: n
whitespace colon
whitespace var: int
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace var: lmem
whitespace lparen
var: l
comma
whitespace var: v
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace var: nth
whitespace lparen
var: l
comma
whitespace var: n
rparen
whitespace equalopwhitespace var: v
whitespace whitespace rcurly
semicolon
var: append
whitespace colon
whitespace lparen
var: l1
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lparen
var: l2
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace pipe
whitespace whitespace var: llen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: llen
whitespace lparen
var: l1
rparen
whitespace pluswhitespace var: llen
whitespace lparen
var: l2
rparen
whitespace conjwhitespace var: lhd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: lhd
whitespace lparen
var: l1
rparen
whitespace conjwhitespace var: lsnd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: lsnd
whitespace lparen
var: l1
rparen
whitespace conjwhitespace var: last
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: last
whitespace lparen
var: l2
rparen
whitespace conjwhitespace var: pen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: pen
whitespace lparen
var: l2
rparen
whitespace rcurly
semicolon
var: combine
whitespace colon
whitespace lparen
var: l1
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lparen
var: l2
whitespace colon
whitespace lcurly
var: v
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace pipe
whitespace var: llen
whitespace lparen
var: l1
rparen
whitespace equalopwhitespace var: llen
whitespace lparen
var: l2
rparen
rcurly
rparen
whitespace arrow
whitespace whitespace lcurly
var: v
whitespace colon
whitespace lbrace
var: ipair
rbrace
whitespace pipe
whitespace lambdalparen
var: H
whitespace colon
whitespace var: ipair
rparen
comma
whitespace lparen
var: L
whitespace colon
whitespace var: ipair
rparen
dotwhitespace var: pllen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: pllen
whitespace lparen
var: l1
rparen
whitespace conjwhitespace var: plhd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: H
whitespace conjwhitespace var: pllast
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: L
whitespace conjwhitespace var: ppr1
whitespace lparen
var: H
rparen
whitespace equalopwhitespace var: lhd
whitespace lparen
var: l1
rparen
whitespace conjwhitespace var: ppr2
whitespace lparen
var: H
rparen
whitespace equalopwhitespace var: lhd
whitespace lparen
var: l2
rparen
whitespace conjwhitespace var: ppr1
whitespace lparen
var: L
rparen
whitespace equalopwhitespace var: last
whitespace lparen
var: l1
rparen
whitespace conjwhitespace var: ppr2
whitespace lparen
var: L
rparen
whitespace equalopwhitespace var: last
whitespace lparen
var: l2
rparen
whitespace whitespace rcurly
semicolon
var: splitAt
whitespace colon
whitespace lparen
var: y
colon
var: int
rparen
whitespace arrow
whitespace lparen
var: l
whitespace colon
whitespace lcurly
whitespace var: v
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace pipe
whitespace var: llen
whitespace lparen
var: v
rparen
whitespace lessthanopwhitespace var: y
rcurly
rparen
whitespace arrow
whitespace whitespace lcurly
var: v
colon
var: plist
whitespace pipe
whitespace lambdalparen
var: H
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
comma
whitespace lparen
var: L
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
dotwhitespace lparen
var: fst
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: H
whitespace conjwhitespace var: snd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: L
rparen
whitespace implieswhitespace whitespace var: llen
whitespace lparen
var: H
rparen
whitespace equalopwhitespace var: y
whitespace conjwhitespace var: llen
whitespace lparen
var: L
rparen
whitespace equalopwhitespace var: llen
whitespace lparen
var: l
rparen
whitespace ar-minuswhitespace var: y
whitespace whitespace rcurly
semicolon
var: null
whitespace colon
whitespace lparen
var: l
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace var: bool
whitespace pipe
whitespace lbrace
var: v
equaloptruerbrace
whitespace iffwhitespace var: llen
whitespace lparen
var: l
rparen
whitespace equalopwhitespace int: 0
rcurly
semicolon
var: last
whitespace colon
whitespace lparen
var: l
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace var: last
whitespace lparen
var: l
rparen
whitespace equalopwhitespace var: v
rcurly
semicolon
whitespace var: init
whitespace colon
whitespace lparen
var: l
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace pipe
whitespace var: llen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: llen
whitespace lparen
var: v
rparen
whitespace ar-minusint: 1
rcurly
semicolon
whitespace var: take
whitespace colon
whitespace lparen
var: n
whitespace colon
whitespace var: int
rparen
whitespace arrow
whitespace lparen
var: l
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace pipe
whitespace lambdalparen
var: u
whitespace colon
whitespace var: int
rparen
dotwhitespace whitespace var: llen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: n
whitespace conjwhitespace whitespace lparen
var: lmem
whitespace lparen
var: v
comma
whitespace var: u
rparen
whitespace equalopwhitespace truerparen
whitespace implieswhitespace var: lmem
whitespace lparen
var: l
comma
whitespace var: u
rparen
whitespace equalopwhitespace truercurly
semicolon
whitespace var: goal
whitespace colon
whitespace lparen
var: x
whitespace colon
whitespace var: int
rparen
whitespace arrow
whitespace lparen
var: xs
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace whitespace lcurly
var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace lambdalparen
var: u
whitespace colon
whitespace var: int
rparen
dotwhitespace lparen
var: nth
whitespace lparen
var: xs
comma
whitespace var: x
rparen
whitespace equalopwhitespace var: u
rparen
whitespace implieswhitespace lbrace
var: v
whitespace equalopwhitespace var: u
rbrace
whitespace rcurly
semicolon
RelSpec {  SRs ;  PRs ;  TSs  
 Assume false
 name ep : 
 params :
 Type {var_v0:int | true} 
 Assume false
 name length : 
 params :
 Type  Arrow ( ( x : {var_v1:Ty_list int | true} ) -> {v:int | (llen)(x) ==(v)} 
 Assume false
 name rev : 
 params :
 Type  Arrow ( ( l : {var_v2:Ty_list int | true} ) -> {v:Ty_list int | 
 	 Conj <c (llen)(v) ==(llen)(l)
 	 , 
 	 Conj <c (lhd)(v) ==(last)(l)
 	 , 
 	 Conj <c (last)(v) ==(lhd)(l)
 	 , 
 	 Conj <c (lsnd)(v) ==(pen)(l)
 	 , (pen)(v) ==(lsnd)(v) >c  >c  >c  >c } 
 Assume false
 name compare_lengths : 
 params :
 Type  Arrow ( ( x : {var_v3:Ty_list int | true} ) ->  Arrow ( ( y : {var_v4:Ty_list int | true} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  (llen)(x) ==(llen)(y)} 
 Assume false
 name cons : 
 params :
 Type  Arrow ( ( x : {var_v5:int | true} ) ->  Arrow ( ( xs : {var_v6:Ty_list int | true} ) -> {v:Ty_list int | 
 	 Conj <c (llen)(v) ==((llen)(xs) + (1))
 	 , 
 	 Conj <c (lmem)( , v, x ) = (true)
 	 , 
 	 Conj <c (lhd)(v) ==(x)
 	 , 
 	 Conj <c (lsnd)(v) ==(lhd)(xs)
 	 , 
 	 Conj <c (last)(v) ==(last)(xs)
 	 , (pen)(v) ==(pen)(xs) >c  >c  >c  >c  >c } 
 Assume false
 name hd : 
 params :
 Type  Arrow ( ( l : {var_v7:Ty_list int | true} ) -> {v:int | 
 	 Conj <c (lmem)( , l, v ) = (true)
 	 , (lhd)(l) ==(v) >c } 
 Assume false
 name tl : 
 params :
 Type  Arrow ( ( l : {var_v8:Ty_list int | true} ) -> {v:Ty_list int | 
 	 Conj <c (llen)(v) ==((llen)(l) -- (1))
 	 , 
 	 Conj <c (last)(v) ==(last)(l)
 	 , 
 	 Conj <c (lhd)(v) ==(lsnd)(l)
 	 , (pen)(v) ==(pen)(l) >c  >c  >c } 
 Assume false
 name nth : 
 params :
 Type  Arrow ( ( l : {var_v9:Ty_list int | true} ) ->  Arrow ( ( n : {var_v10:int | true} ) -> {v:int | 
 	 Conj <c (lmem)( , l, v ) = (true)
 	 , (nth)( , l, n ) ==(v) >c } 
 Assume false
 name append : 
 params :
 Type  Arrow ( ( l1 : {var_v11:Ty_list int | true} ) ->  Arrow ( ( l2 : {var_v12:Ty_list int | true} ) -> {v:Ty_list int | 
 	 Conj <c (llen)(v) ==((llen)(l1) + (llen)(l2))
 	 , 
 	 Conj <c (lhd)(v) ==(lhd)(l1)
 	 , 
 	 Conj <c (lsnd)(v) ==(lsnd)(l1)
 	 , 
 	 Conj <c (last)(v) ==(last)(l2)
 	 , (pen)(v) ==(pen)(l2) >c  >c  >c  >c } 
 Assume false
 name combine : 
 params :
 Type  Arrow ( ( l1 : {var_v13:Ty_list int | true} ) ->  Arrow ( ( l2 : {v:Ty_list int | (llen)(l1) ==(llen)(l2)} ) -> {v:Ty_list int ipair | Forall 
 	 
 Key =H Value = int ipair
 Key =L Value = int ipair{ 
 	 Conj <c (pllen)(v) ==(pllen)(l1)
 	 , 
 	 Conj <c (plhd)(v) = (H)
 	 , 
 	 Conj <c (pllast)(v) = (L)
 	 , 
 	 Conj <c (ppr1)(H) ==(lhd)(l1)
 	 , 
 	 Conj <c (ppr2)(H) ==(lhd)(l2)
 	 , 
 	 Conj <c (ppr1)(L) ==(last)(l1)
 	 , (ppr2)(L) ==(last)(l2) >c  >c  >c  >c  >c  >c  }} 
 Assume false
 name splitAt : 
 params :
 Type  Arrow ( ( y : {var_v14:int | true} ) ->  Arrow ( ( l : {v:Ty_list int | (llen)(v) > (y)} ) -> {v:int plist | Forall 
 	 
 Key =H Value = Ty_list int
 Key =L Value = Ty_list int{ 
 	 Impl < 
 	 Conj <c (fst)(v) = (H)
 	 , (snd)(v) = (L) >c 
 	 
 	 Conj <c (llen)(H) ==(y)
 	 , (llen)(L) ==((llen)(l) -- (y)) >c  > }} 
 Assume false
 name null : 
 params :
 Type  Arrow ( ( l : {var_v15:Ty_list int | true} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  (llen)(l) ==(0)} 
 Assume false
 name last : 
 params :
 Type  Arrow ( ( l : {var_v16:Ty_list int | true} ) -> {v:int | (last)(l) ==(v)} 
 Assume false
 name init : 
 params :
 Type  Arrow ( ( l : {var_v17:Ty_list int | true} ) -> {v:Ty_list int | (llen)(v) ==((llen)(v) -- (1))} 
 Assume false
 name take : 
 params :
 Type  Arrow ( ( n : {var_v18:int | true} ) ->  Arrow ( ( l : {var_v19:Ty_list int | true} ) -> {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c (llen)(v) ==(n)
 	 , 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , l, u ) = (true) > >c  }} 
 Assume false
 name goal : 
 params :
 Type  Arrow ( ( x : {var_v20:int | true} ) ->  Arrow ( ( xs : {var_v21:Ty_list int | true} ) -> {v:int | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (nth)( , xs, x ) = (u)
 	 v = u > }};  Formulas  }
 INITIAL GAMMA 
 
 goal :  Arrow ( ( x : {var_v20:int | true} ) ->  Arrow ( ( xs : {var_v21:Ty_list int | true} ) -> {v:int | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (nth)( , xs, x ) = (u)
 	 v = u > }}
 take :  Arrow ( ( n : {var_v18:int | true} ) ->  Arrow ( ( l : {var_v19:Ty_list int | true} ) -> {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c (llen)(v) ==(n)
 	 , 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , l, u ) = (true) > >c  }}
 init :  Arrow ( ( l : {var_v17:Ty_list int | true} ) -> {v:Ty_list int | (llen)(v) ==((llen)(v) -- (1))}
 last :  Arrow ( ( l : {var_v16:Ty_list int | true} ) -> {v:int | (last)(l) ==(v)}
 null :  Arrow ( ( l : {var_v15:Ty_list int | true} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  (llen)(l) ==(0)}
 splitAt :  Arrow ( ( y : {var_v14:int | true} ) ->  Arrow ( ( l : {v:Ty_list int | (llen)(v) > (y)} ) -> {v:int plist | Forall 
 	 
 Key =H Value = Ty_list int
 Key =L Value = Ty_list int{ 
 	 Impl < 
 	 Conj <c (fst)(v) = (H)
 	 , (snd)(v) = (L) >c 
 	 
 	 Conj <c (llen)(H) ==(y)
 	 , (llen)(L) ==((llen)(l) -- (y)) >c  > }}
 combine :  Arrow ( ( l1 : {var_v13:Ty_list int | true} ) ->  Arrow ( ( l2 : {v:Ty_list int | (llen)(l1) ==(llen)(l2)} ) -> {v:Ty_list int ipair | Forall 
 	 
 Key =H Value = int ipair
 Key =L Value = int ipair{ 
 	 Conj <c (pllen)(v) ==(pllen)(l1)
 	 , 
 	 Conj <c (plhd)(v) = (H)
 	 , 
 	 Conj <c (pllast)(v) = (L)
 	 , 
 	 Conj <c (ppr1)(H) ==(lhd)(l1)
 	 , 
 	 Conj <c (ppr2)(H) ==(lhd)(l2)
 	 , 
 	 Conj <c (ppr1)(L) ==(last)(l1)
 	 , (ppr2)(L) ==(last)(l2) >c  >c  >c  >c  >c  >c  }}
 append :  Arrow ( ( l1 : {var_v11:Ty_list int | true} ) ->  Arrow ( ( l2 : {var_v12:Ty_list int | true} ) -> {v:Ty_list int | 
 	 Conj <c (llen)(v) ==((llen)(l1) + (llen)(l2))
 	 , 
 	 Conj <c (lhd)(v) ==(lhd)(l1)
 	 , 
 	 Conj <c (lsnd)(v) ==(lsnd)(l1)
 	 , 
 	 Conj <c (last)(v) ==(last)(l2)
 	 , (pen)(v) ==(pen)(l2) >c  >c  >c  >c }
 nth :  Arrow ( ( l : {var_v9:Ty_list int | true} ) ->  Arrow ( ( n : {var_v10:int | true} ) -> {v:int | 
 	 Conj <c (lmem)( , l, v ) = (true)
 	 , (nth)( , l, n ) ==(v) >c }
 tl :  Arrow ( ( l : {var_v8:Ty_list int | true} ) -> {v:Ty_list int | 
 	 Conj <c (llen)(v) ==((llen)(l) -- (1))
 	 , 
 	 Conj <c (last)(v) ==(last)(l)
 	 , 
 	 Conj <c (lhd)(v) ==(lsnd)(l)
 	 , (pen)(v) ==(pen)(l) >c  >c  >c }
 hd :  Arrow ( ( l : {var_v7:Ty_list int | true} ) -> {v:int | 
 	 Conj <c (lmem)( , l, v ) = (true)
 	 , (lhd)(l) ==(v) >c }
 cons :  Arrow ( ( x : {var_v5:int | true} ) ->  Arrow ( ( xs : {var_v6:Ty_list int | true} ) -> {v:Ty_list int | 
 	 Conj <c (llen)(v) ==((llen)(xs) + (1))
 	 , 
 	 Conj <c (lmem)( , v, x ) = (true)
 	 , 
 	 Conj <c (lhd)(v) ==(x)
 	 , 
 	 Conj <c (lsnd)(v) ==(lhd)(xs)
 	 , 
 	 Conj <c (last)(v) ==(last)(xs)
 	 , (pen)(v) ==(pen)(xs) >c  >c  >c  >c  >c }
 compare_lengths :  Arrow ( ( x : {var_v3:Ty_list int | true} ) ->  Arrow ( ( y : {var_v4:Ty_list int | true} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  (llen)(x) ==(llen)(y)}
 rev :  Arrow ( ( l : {var_v2:Ty_list int | true} ) -> {v:Ty_list int | 
 	 Conj <c (llen)(v) ==(llen)(l)
 	 , 
 	 Conj <c (lhd)(v) ==(last)(l)
 	 , 
 	 Conj <c (last)(v) ==(lhd)(l)
 	 , 
 	 Conj <c (lsnd)(v) ==(pen)(l)
 	 , (pen)(v) ==(lsnd)(v) >c  >c  >c  >c }
 length :  Arrow ( ( x : {var_v1:Ty_list int | true} ) -> {v:int | (llen)(x) ==(v)}
 ep : {var_v0:int | true}
 INITIAL SIGMA 
 
 TypeNames 
 
 plist
 ipair
 Qualifiers 
 
 Qual llen :  :-> Ty_list int :-> int
 Qual pllen :  :-> Ty_list int ipair :-> int
 Qual lmem :  :-> Ty_list int :-> int :-> Ty_bool
 Qual lhd :  :-> Ty_list int :-> int
 Qual plhd :  :-> Ty_list int ipair :-> int ipair
 Qual last :  :-> Ty_list int :-> int
 Qual pllast :  :-> Ty_list int ipair :-> int ipair
 Qual ppr1 :  :-> int ipair :-> int
 Qual ppr2 :  :-> int ipair :-> int
 Qual nth :  :-> Ty_list int :-> int :-> int
 Qual lsnd :  :-> Ty_list int :-> int
 Qual pen :  :-> Ty_list int :-> int
 Qual fst :  :-> int plist :-> Ty_list int
 Qual snd :  :-> int plist :-> Ty_list int
 Show ***********Calling S-FUNC synthesize***************
 Show Uncurried , x:{var_v20:int | true}, xs:{var_v21:Ty_list int | true} -> {v:int | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (nth)( , xs, x ) = (u)
 	 v = u > }}
 Decreasing Measure x
 Decreasing Type {var_v20:int | true}
 Calculated Decreasing Predicate x > var_v20
 Calculated Decreased Goal Type  Arrow ( ( x1 : {var_v20:int | 
 	 Conj <c true
 	 , x > var_v20 >c } ) ->  Arrow ( ( xs : {var_v21:Ty_list int | true} ) -> {v:int | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (nth)( , xs, x1 ) = (u)
 	 v = u > }}
 Show Trying :: Top-level Match
 Show :: Synthesize Match {v:int | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (nth)( , xs, x ) = (u)
 	 v = u > }}
 Show :: List int
 Show :: Non List Case
 Match-case failed :: Try Top-level If-then-else 
 **********************************************
 iSynthesize If-THEN-ELSE {v:int | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (nth)( , xs, x ) = (u)
 	 v = u > }}
 **********************************************
  *********************Synthesizing the Guard*******************
 iSynthesize Boolean Guard {var_v22:Ty_bool | true}
  *********************Synthesizing the Guard*******************
 esynthesizeScalar for {var_v22:Ty_bool | true}
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
  *********************Guard Synthesized*******************
 iSynthesize Following Boolean Guards Found 
  ********************Guard Synthesized*******************
  If then else Failed :: Try without subdivision
 
  Entering Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  , 
 goal, 
 last, 
 nth, 
 hd, 
 length
 ############################################################
  Synthesizing the Function application Pure Component goal
  *************** Trying Arrow Component ************goal :  Arrow ( ( x1 : {var_v20:int | 
 	 Conj <c true
 	 , x > var_v20 >c } ) ->  Arrow ( ( xs : {var_v21:Ty_list int | true} ) -> {v:int | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (nth)( , xs, x1 ) = (u)
 	 v = u > }}
  *************** Synthesizing Args ei : ti for ************goal
 ##################################################################################
  Synthesizing the 1th argument for Function goal
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v20:int | 
 	 Conj <c true
 	 , x > var_v20 >c }
 
 Enumerating a Scalar Term ep
 
 Type of the Scalar Term {var_v0:int | true}     
# of Final Z3 expressions 2
 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term x
 
 Type of the Scalar Term {var_v20:int | true}
 ################################################
 Skipping Variable x as it is bound variable for Cons constructor
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  , 
 goal, 
 last, 
 nth, 
 hd, 
 length
 ############################################################
  Synthesizing the Function application Pure Component goal
 ################################################
 Skipping Variable goal As Outer Function Call is goal
 ################################################
 ############################################################
  Synthesizing the Function application Pure Component last
  *************** Trying Arrow Component ************last :  Arrow ( ( l : {var_v16:Ty_list int | true} ) -> {v:int | (last)(l) ==(v)}
  *************** Synthesizing Args ei : ti for ************last
 ##################################################################################
  Synthesizing the 1th argument for Function last
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v16:Ty_list int | true}
 
 Enumerating a Scalar Term xs
 
 Type of the Scalar Term {var_v21:Ty_list int | true}
 ################################################
 Skipping Variable xs as it is bound variable for Cons constructor
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  *************** Synthesizing Args ei : Failed for some  arg
 ############################################################
  Synthesizing the Function application Pure Component nth
  *************** Trying Arrow Component ************nth :  Arrow ( ( l : {var_v9:Ty_list int | true} ) ->  Arrow ( ( n : {var_v10:int | true} ) -> {v:int | 
 	 Conj <c (lmem)( , l, v ) = (true)
 	 , (nth)( , l, n ) ==(v) >c }
  *************** Synthesizing Args ei : ti for ************nth
 ##################################################################################
  Synthesizing the 1th argument for Function nth
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v9:Ty_list int | true}
 
 Enumerating a Scalar Term xs
 
 Type of the Scalar Term {var_v21:Ty_list int | true}
 ################################################
 Skipping Variable xs as it is bound variable for Cons constructor
 ################################################
 
 Enumerating a Scalar Term l
 
 Type of the Scalar Term {var_v16:Ty_list int | true}
 ################################################
 Skipping Variable l As this a  Formal Parameter to the current function Call
 Outer Function calls nth
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 2th argument for Function nth
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v10:int | true}
 
 Enumerating a Scalar Term ep
 
 Type of the Scalar Term {var_v0:int | true}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term x
 
 Type of the Scalar Term {var_v20:int | true}
 ################################################
 Skipping Variable x as it is bound variable for Cons constructor
 ################################################
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 2th Args option for nth : ep
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  *************** Synthesizing Args ei : Failed for some  arg
 ############################################################
  Synthesizing the Function application Pure Component hd
  *************** Trying Arrow Component ************hd :  Arrow ( ( l : {var_v7:Ty_list int | true} ) -> {v:int | 
 	 Conj <c (lmem)( , l, v ) = (true)
 	 , (lhd)(l) ==(v) >c }
  *************** Synthesizing Args ei : ti for ************hd
 ##################################################################################
  Synthesizing the 1th argument for Function hd
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v7:Ty_list int | true}
 
 Enumerating a Scalar Term xs
 
 Type of the Scalar Term {var_v21:Ty_list int | true}
 ################################################
 Skipping Variable xs as it is bound variable for Cons constructor
 ################################################
 
 Enumerating a Scalar Term l
 
 Type of the Scalar Term {var_v9:Ty_list int | true}
 ################################################
 Skipping Variable l As this a  Formal Parameter to the current function Call
 Outer Function calls hd
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  *************** Synthesizing Args ei : Failed for some  arg
 ############################################################
  Synthesizing the Function application Pure Component length
  *************** Trying Arrow Component ************length :  Arrow ( ( x : {var_v1:Ty_list int | true} ) -> {v:int | (llen)(x) ==(v)}
  *************** Synthesizing Args ei : ti for ************length
 ##################################################################################
  Synthesizing the 1th argument for Function length
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v1:Ty_list int | true}
 
 Enumerating a Scalar Term xs
 
 Type of the Scalar Term {var_v21:Ty_list int | true}
 ################################################
 Skipping Variable xs as it is bound variable for Cons constructor
 ################################################
 
 Enumerating a Scalar Term l
 
 Type of the Scalar Term {var_v7:Ty_list int | true}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 1th Args option for length : l
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  *************** Successfully Synthesized Args ei Forall i 
 1 th Argument Options for length
 EI l
 # of Possible Argument Options for length 1
 # of Possible Argument Options for length 1
 Possible Arg Options 
 EI l
 Apply Single Argument Case : f (ei) Case length
  Case : f (ei) Case length l
 Finding Already seen tree for apply length  (, l )
 Typechecking apply length  (, l )
 Against {var_v20:int | 
 	 Conj <c true
 	 , x > var_v20 >c }
 Typechecking the Term apply length  (, l )
 Against {var_v20:int | 
 	 Conj <c true
 	 , x > var_v20 >c }
 Argument l :: {var_v7:Ty_list int | true} | true
 AppType Type {v:int | (llen)(l) ==(v)}     
  EXPLORED Args.parser output 
 EXPLORED learningOn  true
 EXPLORED bidirectionality  true
 EXPLORED effect-filter  false
 EXPLORED specfile :: ./prudent_tests/hegel/Hoogle+/applyList.spec
 EXPLORED goal Number :: 0
 EXPLORED Max path length :: 2
 EXPLORED Nested If :: 1typewhitespace var: ipair
semicolon
typewhitespace var: plist
semicolon
stexcwhitespace var: llen
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: pllen
whitespace colon
whitespace lbrace
var: ipair
rbrace
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: lmem
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: int
whitespace colon
whitespace var: bool
semicolon
stexcwhitespace var: lhd
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: plhd
whitespace colon
whitespace lbrace
var: ipair
rbrace
whitespace colon
whitespace var: ipair
semicolon
stexcwhitespace var: last
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: pllast
whitespace colon
whitespace lbrace
var: ipair
rbrace
whitespace colon
whitespace var: ipair
semicolon
stexcwhitespace var: ppr1
whitespace colon
whitespace var: ipair
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: ppr2
whitespace colon
whitespace var: ipair
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: nth
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: int
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: lsnd
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: pen
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: fst
whitespace colon
whitespace var: plist
whitespace colon
whitespace lbrace
var: int
rbrace
semicolon
stexcwhitespace var: snd
whitespace colon
whitespace var: plist
whitespace colon
whitespace lbrace
var: int
rbrace
semicolon
var: ep
whitespace colon
whitespace var: int
semicolon
var: length
whitespace colon
whitespace lparen
var: x
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace var: llen
whitespace lparen
var: x
rparen
whitespace equalopwhitespace var: v
rcurly
semicolon
whitespace var: rev
whitespace colon
whitespace lparen
var: l
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace pipe
whitespace whitespace var: llen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: llen
whitespace lparen
var: l
rparen
whitespace conjwhitespace var: lhd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: last
whitespace lparen
var: l
rparen
whitespace conjwhitespace var: last
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: lhd
whitespace lparen
var: l
rparen
whitespace conjwhitespace var: lsnd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: pen
whitespace lparen
var: l
rparen
whitespace conjwhitespace var: pen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: lsnd
whitespace lparen
var: v
rparen
whitespace rcurly
semicolon
var: compare_lengths
whitespace colon
whitespace lparen
var: x
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lparen
var: y
colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace var: bool
whitespace pipe
whitespace lbrace
var: v
equaloptruerbrace
whitespace iffwhitespace lparen
var: llen
whitespace lparen
var: x
rparen
whitespace equalopwhitespace var: llen
whitespace lparen
var: y
rparen
rparen
rcurly
semicolon
var: cons
whitespace colon
whitespace lparen
var: x
whitespace colon
whitespace var: int
rparen
whitespace arrow
whitespace lparen
var: xs
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace pipe
whitespace var: llen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: llen
whitespace lparen
var: xs
rparen
whitespace pluswhitespace int: 1
whitespace conjwhitespace var: lmem
whitespace lparen
var: v
comma
whitespace var: x
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace var: lhd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: x
whitespace conjwhitespace var: lsnd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: lhd
whitespace lparen
var: xs
rparen
whitespace conjwhitespace var: last
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: last
whitespace lparen
var: xs
rparen
whitespace conjwhitespace var: pen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: pen
whitespace lparen
var: xs
rparen
whitespace rcurly
semicolon
var: hd
whitespace colon
whitespace lparen
var: l
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace var: lmem
whitespace lparen
var: l
comma
whitespace var: v
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace var: lhd
whitespace lparen
var: l
rparen
whitespace equalopwhitespace var: v
whitespace whitespace rcurly
semicolon
var: tl
whitespace colon
whitespace lparen
var: l
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace pipe
whitespace var: llen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: llen
whitespace lparen
var: l
rparen
whitespace ar-minuswhitespace int: 1
whitespace conjwhitespace var: last
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: last
whitespace lparen
var: l
rparen
whitespace conjwhitespace var: lhd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: lsnd
whitespace lparen
var: l
rparen
whitespace conjwhitespace var: pen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: pen
whitespace lparen
var: l
rparen
whitespace rcurly
semicolon
var: nth
whitespace colon
whitespace lparen
var: l
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lparen
var: n
whitespace colon
whitespace var: int
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace var: lmem
whitespace lparen
var: l
comma
whitespace var: v
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace var: nth
whitespace lparen
var: l
comma
whitespace var: n
rparen
whitespace equalopwhitespace var: v
whitespace whitespace rcurly
semicolon
var: append
whitespace colon
whitespace lparen
var: l1
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lparen
var: l2
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace pipe
whitespace whitespace var: llen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: llen
whitespace lparen
var: l1
rparen
whitespace pluswhitespace var: llen
whitespace lparen
var: l2
rparen
whitespace conjwhitespace var: lhd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: lhd
whitespace lparen
var: l1
rparen
whitespace conjwhitespace var: lsnd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: lsnd
whitespace lparen
var: l1
rparen
whitespace conjwhitespace var: last
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: last
whitespace lparen
var: l2
rparen
whitespace conjwhitespace var: pen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: pen
whitespace lparen
var: l2
rparen
whitespace rcurly
semicolon
var: combine
whitespace colon
whitespace lparen
var: l1
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lparen
var: l2
whitespace colon
whitespace lcurly
var: v
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace pipe
whitespace var: llen
whitespace lparen
var: l1
rparen
whitespace equalopwhitespace var: llen
whitespace lparen
var: l2
rparen
rcurly
rparen
whitespace arrow
whitespace whitespace lcurly
var: v
whitespace colon
whitespace lbrace
var: ipair
rbrace
whitespace pipe
whitespace lambdalparen
var: H
whitespace colon
whitespace var: ipair
rparen
comma
whitespace lparen
var: L
whitespace colon
whitespace var: ipair
rparen
dotwhitespace var: pllen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: pllen
whitespace lparen
var: l1
rparen
whitespace conjwhitespace var: plhd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: H
whitespace conjwhitespace var: pllast
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: L
whitespace conjwhitespace var: ppr1
whitespace lparen
var: H
rparen
whitespace equalopwhitespace var: lhd
whitespace lparen
var: l1
rparen
whitespace conjwhitespace var: ppr2
whitespace lparen
var: H
rparen
whitespace equalopwhitespace var: lhd
whitespace lparen
var: l2
rparen
whitespace conjwhitespace var: ppr1
whitespace lparen
var: L
rparen
whitespace equalopwhitespace var: last
whitespace lparen
var: l1
rparen
whitespace conjwhitespace var: ppr2
whitespace lparen
var: L
rparen
whitespace equalopwhitespace var: last
whitespace lparen
var: l2
rparen
whitespace whitespace rcurly
semicolon
var: splitAt
whitespace colon
whitespace lparen
var: y
colon
var: int
rparen
whitespace arrow
whitespace lparen
var: l
whitespace colon
whitespace lcurly
whitespace var: v
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace pipe
whitespace var: llen
whitespace lparen
var: v
rparen
whitespace lessthanopwhitespace var: y
rcurly
rparen
whitespace arrow
whitespace whitespace lcurly
var: v
colon
var: plist
whitespace pipe
whitespace lambdalparen
var: H
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
comma
whitespace lparen
var: L
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
dotwhitespace lparen
var: fst
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: H
whitespace conjwhitespace var: snd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: L
rparen
whitespace implieswhitespace whitespace var: llen
whitespace lparen
var: H
rparen
whitespace equalopwhitespace var: y
whitespace conjwhitespace var: llen
whitespace lparen
var: L
rparen
whitespace equalopwhitespace var: llen
whitespace lparen
var: l
rparen
whitespace ar-minuswhitespace var: y
whitespace whitespace rcurly
semicolon
var: null
whitespace colon
whitespace lparen
var: l
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace var: bool
whitespace pipe
whitespace lbrace
var: v
equaloptruerbrace
whitespace iffwhitespace var: llen
whitespace lparen
var: l
rparen
whitespace equalopwhitespace int: 0
rcurly
semicolon
var: last
whitespace colon
whitespace lparen
var: l
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace var: last
whitespace lparen
var: l
rparen
whitespace equalopwhitespace var: v
rcurly
semicolon
whitespace var: init
whitespace colon
whitespace lparen
var: l
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace pipe
whitespace var: llen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: llen
whitespace lparen
var: v
rparen
whitespace ar-minusint: 1
rcurly
semicolon
whitespace var: take
whitespace colon
whitespace lparen
var: n
whitespace colon
whitespace var: int
rparen
whitespace arrow
whitespace lparen
var: l
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace pipe
whitespace lambdalparen
var: u
whitespace colon
whitespace var: int
rparen
dotwhitespace whitespace var: llen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: n
whitespace conjwhitespace whitespace lparen
var: lmem
whitespace lparen
var: v
comma
whitespace var: u
rparen
whitespace equalopwhitespace truerparen
whitespace implieswhitespace var: lmem
whitespace lparen
var: l
comma
whitespace var: u
rparen
whitespace equalopwhitespace truercurly
semicolon
whitespace whitespace var: goal
whitespace colon
whitespace lparen
var: fs
whitespace colon
whitespace lcurly
var: v
whitespace colon
whitespace lbrace
var: Int
whitespace arrow

  EXPLORED Args.parser output 
 EXPLORED learningOn  true
 EXPLORED bidirectionality  true
 EXPLORED effect-filter  false
 EXPLORED specfile :: ./prudent_tests/hegel/Hoogle+/nth.spec
 EXPLORED goal Number :: 0
 EXPLORED Max path length :: 2
 EXPLORED Nested If :: 1typewhitespace var: ipair
semicolon
typewhitespace var: plist
semicolon
stexcwhitespace var: llen
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: pllen
whitespace colon
whitespace lbrace
var: ipair
rbrace
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: lmem
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: int
whitespace colon
whitespace var: bool
semicolon
stexcwhitespace var: lhd
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: plhd
whitespace colon
whitespace lbrace
var: ipair
rbrace
whitespace colon
whitespace var: ipair
semicolon
stexcwhitespace var: last
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: pllast
whitespace colon
whitespace lbrace
var: ipair
rbrace
whitespace colon
whitespace var: ipair
semicolon
stexcwhitespace var: ppr1
whitespace colon
whitespace var: ipair
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: ppr2
whitespace colon
whitespace var: ipair
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: nth
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: int
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: lsnd
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: pen
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: fst
whitespace colon
whitespace var: plist
whitespace colon
whitespace lbrace
var: int
rbrace
semicolon
stexcwhitespace var: snd
whitespace colon
whitespace var: plist
whitespace colon
whitespace lbrace
var: int
rbrace
semicolon
var: ep
whitespace colon
whitespace var: int
semicolon
var: length
whitespace colon
whitespace lparen
var: x
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace var: llen
whitespace lparen
var: x
rparen
whitespace equalopwhitespace var: v
rcurly
semicolon
whitespace var: rev
whitespace colon
whitespace lparen
var: l
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace pipe
whitespace whitespace var: llen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: llen
whitespace lparen
var: l
rparen
whitespace conjwhitespace var: lhd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: last
whitespace lparen
var: l
rparen
whitespace conjwhitespace var: last
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: lhd
whitespace lparen
var: l
rparen
whitespace conjwhitespace var: lsnd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: pen
whitespace lparen
var: l
rparen
whitespace conjwhitespace var: pen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: lsnd
whitespace lparen
var: v
rparen
whitespace rcurly
semicolon
var: compare_lengths
whitespace colon
whitespace lparen
var: x
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lparen
var: y
colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace var: bool
whitespace pipe
whitespace lbrace
var: v
equaloptruerbrace
whitespace iffwhitespace lparen
var: llen
whitespace lparen
var: x
rparen
whitespace equalopwhitespace var: llen
whitespace lparen
var: y
rparen
rparen
rcurly
semicolon
var: cons
whitespace colon
whitespace lparen
var: x
whitespace colon
whitespace var: int
rparen
whitespace arrow
whitespace lparen
var: xs
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace pipe
whitespace var: llen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: llen
whitespace lparen
var: xs
rparen
whitespace pluswhitespace int: 1
whitespace conjwhitespace var: lmem
whitespace lparen
var: v
comma
whitespace var: x
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace var: lhd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: x
whitespace conjwhitespace var: lsnd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: lhd
whitespace lparen
var: xs
rparen
whitespace conjwhitespace var: last
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: last
whitespace lparen
var: xs
rparen
whitespace conjwhitespace var: pen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: pen
whitespace lparen
var: xs
rparen
whitespace rcurly
semicolon
var: hd
whitespace colon
whitespace lparen
var: l
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace var: lmem
whitespace lparen
var: l
comma
whitespace var: v
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace var: lhd
whitespace lparen
var: l
rparen
whitespace equalopwhitespace var: v
whitespace whitespace rcurly
semicolon
var: tl
whitespace colon
whitespace lparen
var: l
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace pipe
whitespace var: llen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: llen
whitespace lparen
var: l
rparen
whitespace ar-minuswhitespace int: 1
whitespace conjwhitespace var: last
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: last
whitespace lparen
var: l
rparen
whitespace conjwhitespace var: lhd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: lsnd
whitespace lparen
var: l
rparen
whitespace conjwhitespace var: pen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: pen
whitespace lparen
var: l
rparen
whitespace rcurly
semicolon
var: nth
whitespace colon
whitespace lparen
var: l
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lparen
var: n
whitespace colon
whitespace var: int
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace var: lmem
whitespace lparen
var: l
comma
whitespace var: v
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace var: nth
whitespace lparen
var: l
comma
whitespace var: n
rparen
whitespace equalopwhitespace var: v
whitespace whitespace rcurly
semicolon
var: append
whitespace colon
whitespace lparen
var: l1
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lparen
var: l2
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace pipe
whitespace whitespace var: llen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: llen
whitespace lparen
var: l1
rparen
whitespace pluswhitespace var: llen
whitespace lparen
var: l2
rparen
whitespace conjwhitespace var: lhd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: lhd
whitespace lparen
var: l1
rparen
whitespace conjwhitespace var: lsnd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: lsnd
whitespace lparen
var: l1
rparen
whitespace conjwhitespace var: last
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: last
whitespace lparen
var: l2
rparen
whitespace conjwhitespace var: pen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: pen
whitespace lparen
var: l2
rparen
whitespace rcurly
semicolon
var: combine
whitespace colon
whitespace lparen
var: l1
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lparen
var: l2
whitespace colon
whitespace lcurly
var: v
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace pipe
whitespace var: llen
whitespace lparen
var: l1
rparen
whitespace equalopwhitespace var: llen
whitespace lparen
var: l2
rparen
rcurly
rparen
whitespace arrow
whitespace whitespace lcurly
var: v
whitespace colon
whitespace lbrace
var: ipair
rbrace
whitespace pipe
whitespace lambdalparen
var: H
whitespace colon
whitespace var: ipair
rparen
comma
whitespace lparen
var: L
whitespace colon
whitespace var: ipair
rparen
dotwhitespace var: pllen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: pllen
whitespace lparen
var: l1
rparen
whitespace conjwhitespace var: plhd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: H
whitespace conjwhitespace var: pllast
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: L
whitespace conjwhitespace var: ppr1
whitespace lparen
var: H
rparen
whitespace equalopwhitespace var: lhd
whitespace lparen
var: l1
rparen
whitespace conjwhitespace var: ppr2
whitespace lparen
var: H
rparen
whitespace equalopwhitespace var: lhd
whitespace lparen
var: l2
rparen
whitespace conjwhitespace var: ppr1
whitespace lparen
var: L
rparen
whitespace equalopwhitespace var: last
whitespace lparen
var: l1
rparen
whitespace conjwhitespace var: ppr2
whitespace lparen
var: L
rparen
whitespace equalopwhitespace var: last
whitespace lparen
var: l2
rparen
whitespace whitespace rcurly
semicolon
var: splitAt
whitespace colon
whitespace lparen
var: y
colon
var: int
rparen
whitespace arrow
whitespace lparen
var: l
whitespace colon
whitespace lcurly
whitespace var: v
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace pipe
whitespace var: llen
whitespace lparen
var: v
rparen
whitespace lessthanopwhitespace var: y
rcurly
rparen
whitespace arrow
whitespace whitespace lcurly
var: v
colon
var: plist
whitespace pipe
whitespace lambdalparen
var: H
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
comma
whitespace lparen
var: L
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
dotwhitespace lparen
var: fst
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: H
whitespace conjwhitespace var: snd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: L
rparen
whitespace implieswhitespace whitespace var: llen
whitespace lparen
var: H
rparen
whitespace equalopwhitespace var: y
whitespace conjwhitespace var: llen
whitespace lparen
var: L
rparen
whitespace equalopwhitespace var: llen
whitespace lparen
var: l
rparen
whitespace ar-minuswhitespace var: y
whitespace whitespace rcurly
semicolon
var: null
whitespace colon
whitespace lparen
var: l
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace var: bool
whitespace pipe
whitespace lbrace
var: v
equaloptruerbrace
whitespace iffwhitespace var: llen
whitespace lparen
var: l
rparen
whitespace equalopwhitespace int: 0
rcurly
semicolon
var: last
whitespace colon
whitespace lparen
var: l
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace var: last
whitespace lparen
var: l
rparen
whitespace equalopwhitespace var: v
rcurly
semicolon
whitespace var: init
whitespace colon
whitespace lparen
var: l
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace pipe
whitespace var: llen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: llen
whitespace lparen
var: v
rparen
whitespace ar-minusint: 1
rcurly
semicolon
whitespace var: take
whitespace colon
whitespace lparen
var: n
whitespace colon
whitespace var: int
rparen
whitespace arrow
whitespace lparen
var: l
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace pipe
whitespace lambdalparen
var: u
whitespace colon
whitespace var: int
rparen
dotwhitespace whitespace var: llen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: n
whitespace conjwhitespace whitespace lparen
var: lmem
whitespace lparen
var: v
comma
whitespace var: u
rparen
whitespace equalopwhitespace truerparen
whitespace implieswhitespace var: lmem
whitespace lparen
var: l
comma
whitespace var: u
rparen
whitespace equalopwhitespace truercurly
semicolon
whitespace var: goal
whitespace colon
whitespace lparen
var: a1
colon
var: int
rparen
whitespace arrow
whitespace lparen
var: a2
colon
var: int
rparen
whitespace arrow
whitespace lparen
var: a3
colon
lcurly
whitespace var: v1
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace pipe
whitespace notwhitespace lparen
var: a1
whitespace lessthanopwhitespace var: llen
whitespace lparen
var: v1
rparen
rparen
whitespace conjwhitespace notwhitespace lparen
var: a2
whitespace lessthanopwhitespace var: llen
whitespace lparen
var: v1
rparen
rparen
rcurly
rparen
whitespace arrow
lcurly
var: v
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace pipe
whitespace lambdalparen
var: u
whitespace colon
whitespace var: int
rparen
dotwhitespace lparen
var: lmem
whitespace lparen
var: v
comma
whitespace var: u
rparen
whitespace equalopwhitespace truewhitespace implieswhitespace whitespace var: lmem
whitespace lparen
var: a3
comma
whitespace var: u
rparen
whitespace equalopwhitespace truerparen
whitespace conjwhitespace var: llen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: llen
whitespace lparen
var: a3
rparen
whitespace pluswhitespace int: 2
whitespace conjwhitespace var: nth
whitespace lparen
var: a3
comma
whitespace var: a1
rparen
whitespace equalopwhitespace var: pen
whitespace lparen
var: v
rparen
whitespace conjwhitespace var: nth
whitespace lparen
var: a3
comma
whitespace var: a2
rparen
whitespace equalopwhitespace var: last
whitespace lparen
var: v
rparen
rcurly
semicolon
RelSpec {  SRs ;  PRs ;  TSs  
 Assume false
 name ep : 
 params :
 Type {var_v0:int | true} 
 Assume false
 name length : 
 params :
 Type  Arrow ( ( x : {var_v1:Ty_list int | true} ) -> {v:int | (llen)(x) ==(v)} 
 Assume false
 name rev : 
 params :
 Type  Arrow ( ( l : {var_v2:Ty_list int | true} ) -> {v:Ty_list int | 
 	 Conj <c (llen)(v) ==(llen)(l)
 	 , 
 	 Conj <c (lhd)(v) ==(last)(l)
 	 , 
 	 Conj <c (last)(v) ==(lhd)(l)
 	 , 
 	 Conj <c (lsnd)(v) ==(pen)(l)
 	 , (pen)(v) ==(lsnd)(v) >c  >c  >c  >c } 
 Assume false
 name compare_lengths : 
 params :
 Type  Arrow ( ( x : {var_v3:Ty_list int | true} ) ->  Arrow ( ( y : {var_v4:Ty_list int | true} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  (llen)(x) ==(llen)(y)} 
 Assume false
 name cons : 
 params :
 Type  Arrow ( ( x : {var_v5:int | true} ) ->  Arrow ( ( xs : {var_v6:Ty_list int | true} ) -> {v:Ty_list int | 
 	 Conj <c (llen)(v) ==((llen)(xs) + (1))
 	 , 
 	 Conj <c (lmem)( , v, x ) = (true)
 	 , 
 	 Conj <c (lhd)(v) ==(x)
 	 , 
 	 Conj <c (lsnd)(v) ==(lhd)(xs)
 	 , 
 	 Conj <c (last)(v) ==(last)(xs)
 	 , (pen)(v) ==(pen)(xs) >c  >c  >c  >c  >c } 
 Assume false
 name hd : 
 params :
 Type  Arrow ( ( l : {var_v7:Ty_list int | true} ) -> {v:int | 
 	 Conj <c (lmem)( , l, v ) = (true)
 	 , (lhd)(l) ==(v) >c } 
 Assume false
 name tl : 
 params :
 Type  Arrow ( ( l : {var_v8:Ty_list int | true} ) -> {v:Ty_list int | 
 	 Conj <c (llen)(v) ==((llen)(l) -- (1))
 	 , 
 	 Conj <c (last)(v) ==(last)(l)
 	 , 
 	 Conj <c (lhd)(v) ==(lsnd)(l)
 	 , (pen)(v) ==(pen)(l) >c  >c  >c } 
 Assume false
 name nth : 
 params :
 Type  Arrow ( ( l : {var_v9:Ty_list int | true} ) ->  Arrow ( ( n : {var_v10:int | true} ) -> {v:int | 
 	 Conj <c (lmem)( , l, v ) = (true)
 	 , (nth)( , l, n ) ==(v) >c } 
 Assume false
 name append : 
 params :
 Type  Arrow ( ( l1 : {var_v11:Ty_list int | true} ) ->  Arrow ( ( l2 : {var_v12:Ty_list int | true} ) -> {v:Ty_list int | 
 	 Conj <c (llen)(v) ==((llen)(l1) + (llen)(l2))
 	 , 
 	 Conj <c (lhd)(v) ==(lhd)(l1)
 	 , 
 	 Conj <c (lsnd)(v) ==(lsnd)(l1)
 	 , 
 	 Conj <c (last)(v) ==(last)(l2)
 	 , (pen)(v) ==(pen)(l2) >c  >c  >c  >c } 
 Assume false
 name combine : 
 params :
 Type  Arrow ( ( l1 : {var_v13:Ty_list int | true} ) ->  Arrow ( ( l2 : {v:Ty_list int | (llen)(l1) ==(llen)(l2)} ) -> {v:Ty_list int ipair | Forall 
 	 
 Key =H Value = int ipair
 Key =L Value = int ipair{ 
 	 Conj <c (pllen)(v) ==(pllen)(l1)
 	 , 
 	 Conj <c (plhd)(v) = (H)
 	 , 
 	 Conj <c (pllast)(v) = (L)
 	 , 
 	 Conj <c (ppr1)(H) ==(lhd)(l1)
 	 , 
 	 Conj <c (ppr2)(H) ==(lhd)(l2)
 	 , 
 	 Conj <c (ppr1)(L) ==(last)(l1)
 	 , (ppr2)(L) ==(last)(l2) >c  >c  >c  >c  >c  >c  }} 
 Assume false
 name splitAt : 
 params :
 Type  Arrow ( ( y : {var_v14:int | true} ) ->  Arrow ( ( l : {v:Ty_list int | (llen)(v) > (y)} ) -> {v:int plist | Forall 
 	 
 Key =H Value = Ty_list int
 Key =L Value = Ty_list int{ 
 	 Impl < 
 	 Conj <c (fst)(v) = (H)
 	 , (snd)(v) = (L) >c 
 	 
 	 Conj <c (llen)(H) ==(y)
 	 , (llen)(L) ==((llen)(l) -- (y)) >c  > }} 
 Assume false
 name null : 
 params :
 Type  Arrow ( ( l : {var_v15:Ty_list int | true} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  (llen)(l) ==(0)} 
 Assume false
 name last : 
 params :
 Type  Arrow ( ( l : {var_v16:Ty_list int | true} ) -> {v:int | (last)(l) ==(v)} 
 Assume false
 name init : 
 params :
 Type  Arrow ( ( l : {var_v17:Ty_list int | true} ) -> {v:Ty_list int | (llen)(v) ==((llen)(v) -- (1))} 
 Assume false
 name take : 
 params :
 Type  Arrow ( ( n : {var_v18:int | true} ) ->  Arrow ( ( l : {var_v19:Ty_list int | true} ) -> {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c (llen)(v) ==(n)
 	 , 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , l, u ) = (true) > >c  }} 
 Assume false
 name goal : 
 params :
 Type  Arrow ( ( a1 : {var_v20:int | true} ) ->  Arrow ( ( a2 : {var_v21:int | true} ) ->  Arrow ( ( a3 : {v1:Ty_list int | 
 	 Conj <c Negation (a1) > (llen)(v1)
 	 , Negation (a2) > (llen)(v1) >c } ) -> {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , a3, u ) = (true) >
 	 , 
 	 Conj <c (llen)(v) ==((llen)(a3) + (2))
 	 , 
 	 Conj <c (nth)( , a3, a1 ) ==(pen)(v)
 	 , (nth)( , a3, a2 ) ==(last)(v) >c  >c  >c  }};  Formulas  }
 INITIAL GAMMA 
 
 goal :  Arrow ( ( a1 : {var_v20:int | true} ) ->  Arrow ( ( a2 : {var_v21:int | true} ) ->  Arrow ( ( a3 : {v1:Ty_list int | 
 	 Conj <c Negation (a1) > (llen)(v1)
 	 , Negation (a2) > (llen)(v1) >c } ) -> {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , a3, u ) = (true) >
 	 , 
 	 Conj <c (llen)(v) ==((llen)(a3) + (2))
 	 , 
 	 Conj <c (nth)( , a3, a1 ) ==(pen)(v)
 	 , (nth)( , a3, a2 ) ==(last)(v) >c  >c  >c  }}
 take :  Arrow ( ( n : {var_v18:int | true} ) ->  Arrow ( ( l : {var_v19:Ty_list int | true} ) -> {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c (llen)(v) ==(n)
 	 , 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , l, u ) = (true) > >c  }}
 init :  Arrow ( ( l : {var_v17:Ty_list int | true} ) -> {v:Ty_list int | (llen)(v) ==((llen)(v) -- (1))}
 last :  Arrow ( ( l : {var_v16:Ty_list int | true} ) -> {v:int | (last)(l) ==(v)}
 null :  Arrow ( ( l : {var_v15:Ty_list int | true} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  (llen)(l) ==(0)}
 splitAt :  Arrow ( ( y : {var_v14:int | true} ) ->  Arrow ( ( l : {v:Ty_list int | (llen)(v) > (y)} ) -> {v:int plist | Forall 
 	 
 Key =H Value = Ty_list int
 Key =L Value = Ty_list int{ 
 	 Impl < 
 	 Conj <c (fst)(v) = (H)
 	 , (snd)(v) = (L) >c 
 	 
 	 Conj <c (llen)(H) ==(y)
 	 , (llen)(L) ==((llen)(l) -- (y)) >c  > }}
 combine :  Arrow ( ( l1 : {var_v13:Ty_list int | true} ) ->  Arrow ( ( l2 : {v:Ty_list int | (llen)(l1) ==(llen)(l2)} ) -> {v:Ty_list int ipair | Forall 
 	 
 Key =H Value = int ipair
 Key =L Value = int ipair{ 
 	 Conj <c (pllen)(v) ==(pllen)(l1)
 	 , 
 	 Conj <c (plhd)(v) = (H)
 	 , 
 	 Conj <c (pllast)(v) = (L)
 	 , 
 	 Conj <c (ppr1)(H) ==(lhd)(l1)
 	 , 
 	 Conj <c (ppr2)(H) ==(lhd)(l2)
 	 , 
 	 Conj <c (ppr1)(L) ==(last)(l1)
 	 , (ppr2)(L) ==(last)(l2) >c  >c  >c  >c  >c  >c  }}
 append :  Arrow ( ( l1 : {var_v11:Ty_list int | true} ) ->  Arrow ( ( l2 : {var_v12:Ty_list int | true} ) -> {v:Ty_list int | 
 	 Conj <c (llen)(v) ==((llen)(l1) + (llen)(l2))
 	 , 
 	 Conj <c (lhd)(v) ==(lhd)(l1)
 	 , 
 	 Conj <c (lsnd)(v) ==(lsnd)(l1)
 	 , 
 	 Conj <c (last)(v) ==(last)(l2)
 	 , (pen)(v) ==(pen)(l2) >c  >c  >c  >c }
 nth :  Arrow ( ( l : {var_v9:Ty_list int | true} ) ->  Arrow ( ( n : {var_v10:int | true} ) -> {v:int | 
 	 Conj <c (lmem)( , l, v ) = (true)
 	 , (nth)( , l, n ) ==(v) >c }
 tl :  Arrow ( ( l : {var_v8:Ty_list int | true} ) -> {v:Ty_list int | 
 	 Conj <c (llen)(v) ==((llen)(l) -- (1))
 	 , 
 	 Conj <c (last)(v) ==(last)(l)
 	 , 
 	 Conj <c (lhd)(v) ==(lsnd)(l)
 	 , (pen)(v) ==(pen)(l) >c  >c  >c }
 hd :  Arrow ( ( l : {var_v7:Ty_list int | true} ) -> {v:int | 
 	 Conj <c (lmem)( , l, v ) = (true)
 	 , (lhd)(l) ==(v) >c }
 cons :  Arrow ( ( x : {var_v5:int | true} ) ->  Arrow ( ( xs : {var_v6:Ty_list int | true} ) -> {v:Ty_list int | 
 	 Conj <c (llen)(v) ==((llen)(xs) + (1))
 	 , 
 	 Conj <c (lmem)( , v, x ) = (true)
 	 , 
 	 Conj <c (lhd)(v) ==(x)
 	 , 
 	 Conj <c (lsnd)(v) ==(lhd)(xs)
 	 , 
 	 Conj <c (last)(v) ==(last)(xs)
 	 , (pen)(v) ==(pen)(xs) >c  >c  >c  >c  >c }
 compare_lengths :  Arrow ( ( x : {var_v3:Ty_list int | true} ) ->  Arrow ( ( y : {var_v4:Ty_list int | true} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  (llen)(x) ==(llen)(y)}
 rev :  Arrow ( ( l : {var_v2:Ty_list int | true} ) -> {v:Ty_list int | 
 	 Conj <c (llen)(v) ==(llen)(l)
 	 , 
 	 Conj <c (lhd)(v) ==(last)(l)
 	 , 
 	 Conj <c (last)(v) ==(lhd)(l)
 	 , 
 	 Conj <c (lsnd)(v) ==(pen)(l)
 	 , (pen)(v) ==(lsnd)(v) >c  >c  >c  >c }
 length :  Arrow ( ( x : {var_v1:Ty_list int | true} ) -> {v:int | (llen)(x) ==(v)}
 ep : {var_v0:int | true}
 INITIAL SIGMA 
 
 TypeNames 
 
 plist
 ipair
 Qualifiers 
 
 Qual llen :  :-> Ty_list int :-> int
 Qual pllen :  :-> Ty_list int ipair :-> int
 Qual lmem :  :-> Ty_list int :-> int :-> Ty_bool
 Qual lhd :  :-> Ty_list int :-> int
 Qual plhd :  :-> Ty_list int ipair :-> int ipair
 Qual last :  :-> Ty_list int :-> int
 Qual pllast :  :-> Ty_list int ipair :-> int ipair
 Qual ppr1 :  :-> int ipair :-> int
 Qual ppr2 :  :-> int ipair :-> int
 Qual nth :  :-> Ty_list int :-> int :-> int
 Qual lsnd :  :-> Ty_list int :-> int
 Qual pen :  :-> Ty_list int :-> int
 Qual fst :  :-> int plist :-> Ty_list int
 Qual snd :  :-> int plist :-> Ty_list int
 Show ***********Calling S-FUNC synthesize***************
 Show Uncurried , a1:{var_v20:int | true}, a2:{var_v21:int | true}, a3:{v1:Ty_list int | 
 	 Conj <c Negation (a1) > (llen)(v1)
 	 , Negation (a2) > (llen)(v1) >c } -> {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , a3, u ) = (true) >
 	 , 
 	 Conj <c (llen)(v) ==((llen)(a3) + (2))
 	 , 
 	 Conj <c (nth)( , a3, a1 ) ==(pen)(v)
 	 , (nth)( , a3, a2 ) ==(last)(v) >c  >c  >c  }}
 Decreasing Measure a1
 Decreasing Type {var_v20:int | true}
 Calculated Decreasing Predicate a1 > var_v20
 Calculated Decreased Goal Type  Arrow ( ( a11 : {var_v20:int | 
 	 Conj <c true
 	 , a1 > var_v20 >c } ) ->  Arrow ( ( a2 : {var_v21:int | true} ) ->  Arrow ( ( a3 : {v1:Ty_list int | 
 	 Conj <c Negation (a11) > (llen)(v1)
 	 , Negation (a2) > (llen)(v1) >c } ) -> {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , a3, u ) = (true) >
 	 , 
 	 Conj <c (llen)(v) ==((llen)(a3) + (2))
 	 , 
 	 Conj <c (nth)( , a3, a11 ) ==(pen)(v)
 	 , (nth)( , a3, a2 ) ==(last)(v) >c  >c  >c  }}
 Show Trying :: Top-level Match
 Show :: Synthesize Match {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , a3, u ) = (true) >
 	 , 
 	 Conj <c (llen)(v) ==((llen)(a3) + (2))
 	 , 
 	 Conj <c (nth)( , a3, a1 ) ==(pen)(v)
 	 , (nth)( , a3, a2 ) ==(last)(v) >c  >c  >c  }}
 Show :: List int
 Show :: Non List Case
 Match-case failed :: Try Top-level If-then-else 
 **********************************************
 iSynthesize If-THEN-ELSE {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , a3, u ) = (true) >
 	 , 
 	 Conj <c (llen)(v) ==((llen)(a3) + (2))
 	 , 
 	 Conj <c (nth)( , a3, a1 ) ==(pen)(v)
 	 , (nth)( , a3, a2 ) ==(last)(v) >c  >c  >c  }}
 **********************************************
  *********************Synthesizing the Guard*******************
 iSynthesize Boolean Guard {var_v22:Ty_bool | true}
  *********************Synthesizing the Guard*******************
 esynthesizeScalar for {var_v22:Ty_bool | true}
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
  *********************Guard Synthesized*******************
 iSynthesize Following Boolean Guards Found 
  ********************Guard Synthesized*******************
  If then else Failed :: Try without subdivision
 
  Entering Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  , 
 goal, 
 take, 
 init, 
 append, 
 tl, 
 cons, 
 rev
 ############################################################
  Synthesizing the Function application Pure Component goal
  *************** Trying Arrow Component ************goal :  Arrow ( ( a11 : {var_v20:int | 
 	 Conj <c true
 	 , a1 > var_v20 >c } ) ->  Arrow ( ( a2 : {var_v21:int | true} ) ->  Arrow ( ( a3 : {v1:Ty_list int | 
 	 Conj <c Negation (a11) > (llen)(v1)
 	 , Negation (a2) > (llen)(v1) >c } ) -> {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , a3, u ) = (true) >
 	 , 
 	 Conj <c (llen)(v) ==((llen)(a3) + (2))
 	 , 
 	 Conj <c (nth)( , a3, a11 ) ==(pen)(v)
 	 , (nth)( , a3, a2 ) ==(last)(v) >c  >c  >c  }}
  *************** Synthesizing Args ei : ti for ************goal
 ##################################################################################
  Synthesizing the 1th argument for Function goal
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v20:int | 
 	 Conj <c true
 	 , a1 > var_v20 >c }
 
 Enumerating a Scalar Term ep
 
 Type of the Scalar Term {var_v0:int | true}     
# of Final Z3 expressions 3
 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term a1
 
 Type of the Scalar Term {var_v20:int | true}     
# of Final Z3 expressions 3
 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term a2
 
 Type of the Scalar Term {var_v21:int | true}     
# of Final Z3 expressions 3
 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 
 FaileD the subtype check T_vi <: T_goal
  Entering Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  , 
 last, 
 nth, 
 hd, 
 length
 ############################################################
  Synthesizing the Function application Pure Component last
  *************** Trying Arrow Component ************last :  Arrow ( ( l : {var_v16:Ty_list int | true} ) -> {v:int | (last)(l) ==(v)}
  *************** Synthesizing Args ei : ti for ************last
 ##################################################################################
  Synthesizing the 1th argument for Function last
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v16:Ty_list int | true}
 
 Enumerating a Scalar Term a3
 
 Type of the Scalar Term {v1:Ty_list int | 
 	 Conj <c Negation (a1) > (llen)(v1)
 	 , Negation (a2) > (llen)(v1) >c }
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 1th Args option for last : a3
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  *************** Successfully Synthesized Args ei Forall i 
 1 th Argument Options for last
 EI a3
 # of Possible Argument Options for last 1
 # of Possible Argument Options for last 1
 Possible Arg Options 
 EI a3
 Apply Single Argument Case : f (ei) Case last
  Case : f (ei) Case last a3
 Finding Already seen tree for apply last  (, a3 )
 Typechecking apply last  (, a3 )
 Against {var_v20:int | 
 	 Conj <c true
 	 , a1 > var_v20 >c }
 Typechecking the Term apply last  (, a3 )
 Against {var_v20:int | 
 	 Conj <c true
 	 , a1 > var_v20 >c }
 Argument a3 :: {v1:Ty_list int | 
 	 Conj <c Negation (a1) > (llen)(v1)
 	 , Negation (a2) > (llen)(v1) >c } | 
 	 Conj <c Negation (a1) > (llen)(a3)
 	 , Negation (a2) > (llen)(a3) >c 
 AppType Type {v:int | (last)(a3) ==(v)}     
# of Final Z3 expressions 7
 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply last  (, a3 )
  ###################################################
  The Choice of Function last Was Ill Fated Try Next Choice of function
 ############################################################
  Synthesizing the Function application Pure Component nth
  *************** Trying Arrow Component ************nth :  Arrow ( ( l : {var_v9:Ty_list int | true} ) ->  Arrow ( ( n : {var_v10:int | true} ) -> {v:int | 
 	 Conj <c (lmem)( , l, v ) = (true)
 	 , (nth)( , l, n ) ==(v) >c }
  *************** Synthesizing Args ei : ti for ************nth
 ##################################################################################
  Synthesizing the 1th argument for Function nth
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v9:Ty_list int | true}
 
 Enumerating a Scalar Term a3
 
 Type of the Scalar Term {v1:Ty_list int | 
 	 Conj <c Negation (a1) > (llen)(v1)
 	 , Negation (a2) > (llen)(v1) >c }
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term l
 
 Type of the Scalar Term {var_v16:Ty_list int | true}
 ################################################
 Skipping Variable l As this a  Formal Parameter to the current function Call
 Outer Function calls nth
 ################################################
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 1th Args option for nth : a3
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 2th argument for Function nth
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v10:int | true}
 
 Enumerating a Scalar Term ep
 
 Type of the Scalar Term {var_v0:int | true}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term a1
 
 Type of the Scalar Term {var_v20:int | true}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term a2
 
 Type of the Scalar Term {var_v21:int | true}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 2th Args option for nth : a2
 >>>>>>>>>>>>>>>>>>> 2th Args option for nth : a1
 >>>>>>>>>>>>>>>>>>> 2th Args option for nth : ep
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  *************** Successfully Synthesized Args ei Forall i 
 1 th Argument Options for nth
 EI a3
 2 th Argument Options for nth
 EI a2
 EI a1
 EI ep
 # of Possible Argument Options for nth 3
 # of Possible Argument Options for nth 3
 Possible Arg Options 
 EI a3
 EI a2
 Possible Arg Options 
 EI a3
 EI a1
 Possible Arg Options 
 EI a3
 EI ep
 Show f (ei, e2, ....en) Case
 Finding Already seen tree for apply nth  (, a3 ), a2 )
 Typechecking apply nth  (, a3 ), a2 )
 Against {var_v20:int | 
 	 Conj <c true
 	 , a1 > var_v20 >c }
 Typechecking the Term apply nth  (, a3 ), a2 )
 Against {var_v20:int | 
 	 Conj <c true
 	 , a1 > var_v20 >c }
 Argument a3 :: {v1:Ty_list int | 
 	 Conj <c Negation (a1) > (llen)(v1)
 	 , Negation (a2) > (llen)(v1) >c } | 
 	 Conj <c Negation (a1) > (llen)(a3)
 	 , Negation (a2) > (llen)(a3) >c 
 Argument a2 :: {var_v21:int | true} | true
 AppType Type {v:int | 
 	 Conj <c (lmem)( , a3, v ) = (true)
 	 , (nth)( , a3, a2 ) ==(v) >c }         
# of Final Z3 expressions 11
 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply nth  (, a3 ), a2 )
 Finding Already seen tree for apply nth  (, a3 ), a1 )
 Typechecking apply nth  (, a3 ), a1 )
 Against {var_v20:int | 
 	 Conj <c true
 	 , a1 > var_v20 >c }
 Typechecking the Term apply nth  (, a3 ), a1 )
 Against {var_v20:int | 
 	 Conj <c true
 	 , a1 > var_v20 >c }
 Argument a3 :: {v1:Ty_list int | 
 	 Conj <c Negation (a1) > (llen)(v1)
 	 , Negation (a2) > (llen)(v1) >c } | 
 	 Conj <c Negation (a1) > (llen)(a3)
 	 , Negation (a2) > (llen)(a3) >c 
 Argument a1 :: {var_v20:int | true} | true
 AppType Type {v:int | 
 	 Conj <c (lmem)( , a3, v ) = (true)
 	 , (nth)( , a3, a1 ) ==(v) >c }         
# of Final Z3 expressions 11
 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply nth  (, a3 ), a1 )
 Finding Already seen tree for apply nth  (, a3 ), ep )
 Typechecking apply nth  (, a3 ), ep )
 Against {var_v20:int | 
 	 Conj <c true
 	 , a1 > var_v20 >c }
 Typechecking the Term apply nth  (, a3 ), ep )
 Against {var_v20:int | 
 	 Conj <c true
 	 , a1 > var_v20 >c }
 Argument a3 :: {v1:Ty_list int | 
 	 Conj <c Negation (a1) > (llen)(v1)
 	 , Negation (a2) > (llen)(v1) >c } | 
 	 Conj <c Negation (a1) > (llen)(a3)
 	 , Negation (a2) > (llen)(a3) >c 
 Argument ep :: {var_v0:int | true} | true
 AppType Type {v:int | 
 	 Conj <c (lmem)( , a3, v ) = (true)
 	 , (nth)( , a3, ep ) ==(v) >c }         
# of Final Z3 expressions 11
 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply nth  (, a3 ), ep )
  ###################################################
  The Choice of Function nth Was Ill Fated Try Next Choice of function {var_v20:int | 
 	 Conj <c true
 	 , a1 > var_v20 >c }
 ############################################################
  Synthesizing the Function application Pure Component hd
  *************** Trying Arrow Component ************hd :  Arrow ( ( l : {var_v7:Ty_list int | true} ) -> {v:int | 
 	 Conj <c (lmem)( , l, v ) = (true)
 	 , (lhd)(l) ==(v) >c }
  *************** Synthesizing Args ei : ti for ************hd
 ##################################################################################
  Synthesizing the 1th argument for Function hd
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v7:Ty_list int | true}
 
 Enumerating a Scalar Term a3
 
 Type of the Scalar Term {v1:Ty_list int | 
 	 Conj <c Negation (a1) > (llen)(v1)
 	 , Negation (a2) > (llen)(v1) >c }
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term l
 
 Type of the Scalar Term {var_v9:Ty_list int | true}
 ################################################
 Skipping Variable l As this a  Formal Parameter to the current function Call
 Outer Function calls hd
 ################################################
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 1th Args option for hd : a3
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  *************** Successfully Synthesized Args ei Forall i 
 1 th Argument Options for hd
 EI a3
 # of Possible Argument Options for hd 1
 # of Possible Argument Options for hd 1
 Possible Arg Options 
 EI a3
 Apply Single Argument Case : f (ei) Case hd
  Case : f (ei) Case hd a3
 Finding Already seen tree for apply hd  (, a3 )
 Typechecking apply hd  (, a3 )
 Against {var_v20:int | 
 	 Conj <c true
 	 , a1 > var_v20 >c }
 Typechecking the Term apply hd  (, a3 )
 Against {var_v20:int | 
 	 Conj <c true
 	 , a1 > var_v20 >c }
 Argument a3 :: {v1:Ty_list int | 
 	 Conj <c Negation (a1) > (llen)(v1)
 	 , Negation (a2) > (llen)(v1) >c } | 
 	 Conj <c Negation (a1) > (llen)(a3)
 	 , Negation (a2) > (llen)(a3) >c 
 AppType Type {v:int | 
 	 Conj <c (lmem)( , a3, v ) = (true)
 	 , (lhd)(a3) ==(v) >c }         
# of Final Z3 expressions 11
 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply hd  (, a3 )
  ###################################################
  The Choice of Function hd Was Ill Fated Try Next Choice of function
 ############################################################
  Synthesizing the Function application Pure Component length
  *************** Trying Arrow Component ************length :  Arrow ( ( x : {var_v1:Ty_list int | true} ) -> {v:int | (llen)(x) ==(v)}
  *************** Synthesizing Args ei : ti for ************length
 ##################################################################################
  Synthesizing the 1th argument for Function length
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v1:Ty_list int | true}
 
 Enumerating a Scalar Term a3
 
 Type of the Scalar Term {v1:Ty_list int | 
 	 Conj <c Negation (a1) > (llen)(v1)
 	 , Negation (a2) > (llen)(v1) >c }
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term l
 
 Type of the Scalar Term {var_v7:Ty_list int | true}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 1th Args option for length : l
 >>>>>>>>>>>>>>>>>>> 1th Args option for length : a3
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  *************** Successfully Synthesized Args ei Forall i 
 1 th Argument Options for length
 EI l
 EI a3
 # of Possible Argument Options for length 2
 # of Possible Argument Options for length 2
 Possible Arg Options 
 EI l
 Possible Arg Options 
 EI a3
 Apply Single Argument Case : f (ei) Case length
  Case : f (ei) Case length l
 Finding Already seen tree for apply length  (, l )
 Typechecking apply length  (, l )
 Against {var_v20:int | 
 	 Conj <c true
 	 , a1 > var_v20 >c }
 Typechecking the Term apply length  (, l )
 Against {var_v20:int | 
 	 Conj <c true
 	 , a1 > var_v20 >c }
 Argument l :: {var_v7:Ty_list int | true} | true
 AppType Type {v:int | (llen)(l) ==(v)}     
# of Final Z3 expressions 5
 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply length  (, l )
  Case : f (ei) Case length a3
 Finding Already seen tree for apply length  (, a3 )
 Typechecking apply length  (, a3 )
 Against {var_v20:int | 
 	 Conj <c true
 	 , a1 > var_v20 >c }
 Typechecking the Term apply length  (, a3 )
 Against {var_v20:int | 
 	 Conj <c true
 	 , a1 > var_v20 >c }
 Argument a3 :: {v1:Ty_list int | 
 	 Conj <c Negation (a1) > (llen)(v1)
 	 , Negation (a2) > (llen)(v1) >c } | 
 	 Conj <c Negation (a1) > (llen)(a3)
 	 , Negation (a2) > (llen)(a3) >c 
 AppType Type {v:int | (llen)(a3) ==(v)}     
# of Final Z3 expressions 7
 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply length  (, a3 )
  ###################################################
  The Choice of Function length Was Ill Fated Try Next Choice of function
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 Found Constructors with required return type
  
 ********************** HERE BEFORE 
 Show No more choices for ConsApp
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  , 
 last, 
 nth, 
 hd, 
 length
 ############################################################
  Synthesizing the Function application Pure Component last
  *************** Trying Arrow Component ************last :  Arrow ( ( l : {var_v16:Ty_list int | true} ) -> {v:int | (last)(l) ==(v)}
  *************** Synthesizing Args ei : ti for ************last
 ##################################################################################
  Synthesizing the 1th argument for Function last
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v16:Ty_list int | true}
 
 Enumerating a Scalar Term a3
 
 Type of the Scalar Term {v1:Ty_list int | 
 	 Conj <c Negation (a1) > (llen)(v1)
 	 , Negation (a2) > (llen)(v1) >c }
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term l
 
 Type of the Scalar Term {var_v7:Ty_list int | true}
 ################################################
 Skipping Variable l As this a  Formal Parameter to the current function Call
 Outer Function calls last
 ################################################
 
 Enumerating a Scalar Term x
 
 Type of the Scalar Term {var_v1:Ty_list int | true}
 ################################################
 Skipping Variable x as it is bound variable for Cons constructor
 ################################################
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 1th Args option for last : a3
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  *************** Successfully Synthesized Args ei Forall i 
 1 th Argument Options for last
 EI a3
 # of Possible Argument Options for last 1
 # of Possible Argument Options for last 1
 Possible Arg Options 
 EI a3
 Apply Single Argument Case : f (ei) Case last
  Case : f (ei) Case last a3
 Finding Already seen tree for apply last  (, a3 )
 Typechecking apply last  (, a3 )
 Against {var_v20:int | 
 	 Conj <c true
 	 , a1 > var_v20 >c }
 Typechecking the Term apply last  (, a3 )
 Against {var_v20:int | 
 	 Conj <c true
 	 , a1 > var_v20 >c }
 Argument a3 :: {v1:Ty_list int | 
 	 Conj <c Negation (a1) > (llen)(v1)
 	 , Negation (a2) > (llen)(v1) >c } | 
 	 Conj <c Negation (a1) > (llen)(a3)
 	 , Negation (a2) > (llen)(a3) >c 
 AppType Type {v:int | (last)(a3) ==(v)}     
# of Final Z3 expressions 7
 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply last  (, a3 )
  ###################################################
  The Choice of Function last Was Ill Fated Try Next Choice of function
 ############################################################
  Synthesizing the Function application Pure Component nth
  *************** Trying Arrow Component ************nth :  Arrow ( ( l : {var_v9:Ty_list int | true} ) ->  Arrow ( ( n : {var_v10:int | true} ) -> {v:int | 
 	 Conj <c (lmem)( , l, v ) = (true)
 	 , (nth)( , l, n ) ==(v) >c }
  *************** Synthesizing Args ei : ti for ************nth
 ##################################################################################
  Synthesizing the 1th argument for Function nth
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v9:Ty_list int | true}
 
 Enumerating a Scalar Term a3
 
 Type of the Scalar Term {v1:Ty_list int | 
 	 Conj <c Negation (a1) > (llen)(v1)
 	 , Negation (a2) > (llen)(v1) >c }
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term x
 
 Type of the Scalar Term {var_v1:Ty_list int | true}
 ################################################
 Skipping Variable x as it is bound variable for Cons constructor
 ################################################
 
 Enumerating a Scalar Term l
 
 Type of the Scalar Term {var_v16:Ty_list int | true}
 ################################################
 Skipping Variable l As this a  Formal Parameter to the current function Call
 Outer Function calls nth
 ################################################
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 1th Args option for nth : a3
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 2th argument for Function nth
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v10:int | true}
 
 Enumerating a Scalar Term ep
 
 Type of the Scalar Term {var_v0:int | true}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term a1
 
 Type of the Scalar Term {var_v20:int | true}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term a2
 
 Type of the Scalar Term {var_v21:int | true}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v10:int | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls nth
 ################################################
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 2th Args option for nth : a2
 >>>>>>>>>>>>>>>>>>> 2th Args option for nth : a1
 >>>>>>>>>>>>>>>>>>> 2th Args option for nth : ep
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  *************** Successfully Synthesized Args ei Forall i 
 1 th Argument Options for nth
 EI a3
 2 th Argument Options for nth
 EI a2
 EI a1
 EI ep
 # of Possible Argument Options for nth 3
 # of Possible Argument Options for nth 3
 Possible Arg Options 
 EI a3
 EI a2
 Possible Arg Options 
 EI a3
 EI a1
 Possible Arg Options 
 EI a3
 EI ep
 Show f (ei, e2, ....en) Case
 Finding Already seen tree for apply nth  (, a3 ), a2 )
 Typechecking apply nth  (, a3 ), a2 )
 Against {var_v20:int | 
 	 Conj <c true
 	 , a1 > var_v20 >c }
 Typechecking the Term apply nth  (, a3 ), a2 )
 Against {var_v20:int | 
 	 Conj <c true
 	 , a1 > var_v20 >c }
 Argument a3 :: {v1:Ty_list int | 
 	 Conj <c Negation (a1) > (llen)(v1)
 	 , Negation (a2) > (llen)(v1) >c } | 
 	 Conj <c Negation (a1) > (llen)(a3)
 	 , Negation (a2) > (llen)(a3) >c 
 Argument a2 :: {var_v21:int | true} | true
 AppType Type {v:int | 
 	 Conj <c (lmem)( , a3, v ) = (true)
 	 , (nth)( , a3, a2 ) ==(v) >c }         
# of Final Z3 expressions 11
 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply nth  (, a3 ), a2 )
 Finding Already seen tree for apply nth  (, a3 ), a1 )
 Typechecking apply nth  (, a3 ), a1 )
 Against {var_v20:int | 
 	 Conj <c true
 	 , a1 > var_v20 >c }
 Typechecking the Term apply nth  (, a3 ), a1 )
 Against {var_v20:int | 
 	 Conj <c true
 	 , a1 > var_v20 >c }
 Argument a3 :: {v1:Ty_list int | 
 	 Conj <c Negation (a1) > (llen)(v1)
 	 , Negation (a2) > (llen)(v1) >c } | 
 	 Conj <c Negation (a1) > (llen)(a3)
 	 , Negation (a2) > (llen)(a3) >c 
 Argument a1 :: {var_v20:int | true} | true
 AppType Type {v:int | 
 	 Conj <c (lmem)( , a3, v ) = (true)
 	 , (nth)( , a3, a1 ) ==(v) >c }         
# of Final Z3 expressions 11
 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply nth  (, a3 ), a1 )
 Finding Already seen tree for apply nth  (, a3 ), ep )
 Typechecking apply nth  (, a3 ), ep )
 Against {var_v20:int | 
 	 Conj <c true
 	 , a1 > var_v20 >c }
 Typechecking the Term apply nth  (, a3 ), ep )
 Against {var_v20:int | 
 	 Conj <c true
 	 , a1 > var_v20 >c }
 Argument a3 :: {v1:Ty_list int | 
 	 Conj <c Negation (a1) > (llen)(v1)
 	 , Negation (a2) > (llen)(v1) >c } | 
 	 Conj <c Negation (a1) > (llen)(a3)
 	 , Negation (a2) > (llen)(a3) >c 
 Argument ep :: {var_v0:int | true} | true
 AppType Type {v:int | 
 	 Conj <c (lmem)( , a3, v ) = (true)
 	 , (nth)( , a3, ep ) ==(v) >c }         
# of Final Z3 expressions 11
 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply nth  (, a3 ), ep )
  ###################################################
  The Choice of Function nth Was Ill Fated Try Next Choice of function {var_v20:int | 
 	 Conj <c true
 	 , a1 > var_v20 >c }
 ############################################################
  Synthesizing the Function application Pure Component hd
  *************** Trying Arrow Component ************hd :  Arrow ( ( l : {var_v7:Ty_list int | true} ) -> {v:int | 
 	 Conj <c (lmem)( , l, v ) = (true)
 	 , (lhd)(l) ==(v) >c }
  *************** Synthesizing Args ei : ti for ************hd
 ##################################################################################
  Synthesizing the 1th argument for Function hd
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v7:Ty_list int | true}
 
 Enumerating a Scalar Term a3
 
 Type of the Scalar Term {v1:Ty_list int | 
 	 Conj <c Negation (a1) > (llen)(v1)
 	 , Negation (a2) > (llen)(v1) >c }
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term x
 
 Type of the Scalar Term {var_v1:Ty_list int | true}
 ################################################
 Skipping Variable x as it is bound variable for Cons constructor
 ################################################
 
 Enumerating a Scalar Term l
 
 Type of the Scalar Term {var_v9:Ty_list int | true}
 ################################################
 Skipping Variable l As this a  Formal Parameter to the current function Call
 Outer Function calls hd
 ################################################
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 1th Args option for hd : a3
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  *************** Successfully Synthesized Args ei Forall i 
 1 th Argument Options for hd
 EI a3
 # of Possible Argument Options for hd 1
 # of Possible Argument Options for hd 1
 Possible Arg Options 
 EI a3
 Apply Single Argument Case : f (ei) Case hd
  Case : f (ei) Case hd a3
 Finding Already seen tree for apply hd  (, a3 )
 Typechecking apply hd  (, a3 )
 Against {var_v20:int | 
 	 Conj <c true
 	 , a1 > var_v20 >c }
 Typechecking the Term apply hd  (, a3 )
 Against {var_v20:int | 
 	 Conj <c true
 	 , a1 > var_v20 >c }
 Argument a3 :: {v1:Ty_list int | 
 	 Conj <c Negation (a1) > (llen)(v1)
 	 , Negation (a2) > (llen)(v1) >c } | 
 	 Conj <c Negation (a1) > (llen)(a3)
 	 , Negation (a2) > (llen)(a3) >c 
 AppType Type {v:int | 
 	 Conj <c (lmem)( , a3, v ) = (true)
 	 , (lhd)(a3) ==(v) >c }         
# of Final Z3 expressions 11
 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply hd  (, a3 )
  ###################################################
  The Choice of Function hd Was Ill Fated Try Next Choice of function
 ############################################################
  Synthesizing the Function application Pure Component length
  *************** Trying Arrow Component ************length :  Arrow ( ( x : {var_v1:Ty_list int | true} ) -> {v:int | (llen)(x) ==(v)}
  *************** Synthesizing Args ei : ti for ************length
 ##################################################################################
  Synthesizing the 1th argument for Function length
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v1:Ty_list int | true}
 
 Enumerating a Scalar Term a3
 
 Type of the Scalar Term {v1:Ty_list int | 
 	 Conj <c Negation (a1) > (llen)(v1)
 	 , Negation (a2) > (llen)(v1) >c }
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term x
 
 Type of the Scalar Term {var_v1:Ty_list int | true}
 ################################################
 Skipping Variable x As this a  Formal Parameter to the current function Call
 Outer Function calls length
 ################################################
 
 Enumerating a Scalar Term l
 
 Type of the Scalar Term {var_v7:Ty_list int | true}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 1th Args option for length : l
 >>>>>>>>>>>>>>>>>>> 1th Args option for length : a3
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  *************** Successfully Synthesized Args ei Forall i 
 1 th Argument Options for length
 EI l
 EI a3
 # of Possible Argument Options for length 2
 # of Possible Argument Options for length 2
 Possible Arg Options 
 EI l
 Possible Arg Options 
 EI a3
 Apply Single Argument Case : f (ei) Case length
  Case : f (ei) Case length l
 Finding Already seen tree for apply length  (, l )
 Typechecking apply length  (, l )
 Against {var_v20:int | 
 	 Conj <c true
 	 , a1 > var_v20 >c }
 Typechecking the Term apply length  (, l )
 Against {var_v20:int | 
 	 Conj <c true
 	 , a1 > var_v20 >c }
 Argument l :: {var_v7:Ty_list int | true} | true
 AppType Type {v:int | (llen)(l) ==(v)}     
# of Final Z3 expressions 5
 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply length  (, l )
  Case : f (ei) Case length a3
 Finding Already seen tree for apply length  (, a3 )
 Typechecking apply length  (, a3 )
 Against {var_v20:int | 
 	 Conj <c true
 	 , a1 > var_v20 >c }
 Typechecking the Term apply length  (, a3 )
 Against {var_v20:int | 
 	 Conj <c true
 	 , a1 > var_v20 >c }
 Argument a3 :: {v1:Ty_list int | 
 	 Conj <c Negation (a1) > (llen)(v1)
 	 , Negation (a2) > (llen)(v1) >c } | 
 	 Conj <c Negation (a1) > (llen)(a3)
 	 , Negation (a2) > (llen)(a3) >c 
 AppType Type {v:int | (llen)(a3) ==(v)}     
# of Final Z3 expressions 7
 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply length  (, a3 )
  ###################################################
  The Choice of Function length Was Ill Fated Try Next Choice of function
  DEPTH vs MAX  0 vs 2
 ##################################################################################
  Synthesizing the 2th argument for Function goal
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v21:int | true}
 
 Enumerating a Scalar Term ep
 
 Type of the Scalar Term {var_v0:int | true}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term a1
 
 Type of the Scalar Term {var_v20:int | true}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term a2
 
 Type of the Scalar Term {var_v21:int | true}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v10:int | true}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term a11
 
 Type of the Scalar Term {var_v20:int | 
 	 Conj <c true
 	 , a1 > var_v20 >c }
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  , 
 last, 
 nth, 
 hd, 
 length
 ############################################################
  Synthesizing the Function application Pure Component last
  *************** Trying Arrow Component ************last :  Arrow ( ( l : {var_v16:Ty_list int | true} ) -> {v:int | (last)(l) ==(v)}
  *************** Synthesizing Args ei : ti for ************last
 ##################################################################################
  Synthesizing the 1th argument for Function last
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v16:Ty_list int | true}
 
 Enumerating a Scalar Term a3
 
 Type of the Scalar Term {v1:Ty_list int | 
 	 Conj <c Negation (a1) > (llen)(v1)
 	 , Negation (a2) > (llen)(v1) >c }
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term l
 
 Type of the Scalar Term {var_v7:Ty_list int | true}
 ################################################
 Skipping Variable l As this a  Formal Parameter to the current function Call
 Outer Function calls last
 ################################################
 
 Enumerating a Scalar Term x
 
 Type of the Scalar Term {var_v1:Ty_list int | true}
 ################################################
 Skipping Variable x as it is bound variable for Cons constructor
 ################################################
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 1th Args option for last : a3
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  *************** Successfully Synthesized Args ei Forall i 
 1 th Argument Options for last
 EI a3
 # of Possible Argument Options for last 1
 # of Possible Argument Options for last 1
 Possible Arg Options 
 EI a3
 Apply Single Argument Case : f (ei) Case last
  Case : f (ei) Case last a3
 Finding Already seen tree for apply last  (, a3 )
 Typechecking apply last  (, a3 )
 Against {var_v21:int | true}
 Typechecking the Term apply last  (, a3 )
 Against {var_v21:int | true}
 Argument a3 :: {v1:Ty_list int | 
 	 Conj <c Negation (a1) > (llen)(v1)
 	 , Negation (a2) > (llen)(v1) >c } | 
 	 Conj <c Negation (a1) > (llen)(a3)
 	 , Negation (a2) > (llen)(a3) >c 
 AppType Type {v:int | (last)(a3) ==(v)}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
  Show *************** TypeChecking Succsessful {v:int | (last)(a3) ==(v)}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 let _lbv0 = apply last  (, a3 )
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  ###################################################
  The Choice of Function last Was Succefull for {var_v21:int | true} Continuing for completeness
  ###################################################
 >>>>>>>>>>>>>>>>>>> 2th Args option for goal : a11
 >>>>>>>>>>>>>>>>>>> 2th Args option for goal : n
 >>>>>>>>>>>>>>>>>>> 2th Args option for goal : a2
 >>>>>>>>>>>>>>>>>>> 2th Args option for goal : a1
 >>>>>>>>>>>>>>>>>>> 2th Args option for goal : ep
 >>>>>>>>>>>>>>>>>>> 2th Args option for goal : apply last  (, a3 )
  DEPTH vs MAX  0 vs 2
 ##################################################################################
  Synthesizing the 3th argument for Function goal
  Trying Arguments in Scalars 
 esynthesizeScalar for {v1:Ty_list int | 
 	 Conj <c Negation (a11) > (llen)(v1)
 	 , Negation (a2) > (llen)(v1) >c }
 
 Enumerating a Scalar Term a3
 
 Type of the Scalar Term {v1:Ty_list int | 
 	 Conj <c Negation (a1) > (llen)(v1)
 	 , Negation (a2) > (llen)(v1) >c }     
# of Final Z3 expressions 7
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term x
 
 Type of the Scalar Term {var_v1:Ty_list int | true}
 ################################################
 Skipping Variable x as it is bound variable for Cons constructor
 ################################################
 
 Enumerating a Scalar Term l
 
 Type of the Scalar Term {var_v16:Ty_list int | true}     
# of Final Z3 expressions 5
 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 
 FaileD the subtype check T_vi <: T_goal
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  , 
 goal, 
 take, 
 init, 
 append, 
 tl, 
 cons, 
 rev
 ############################################################
  Synthesizing the Function application Pure Component goal
 ################################################
 Skipping Variable goal As Outer Function Call is goal
 ################################################
 ############################################################
  Synthesizing the Function application Pure Component take
  *************** Trying Arrow Component ************take :  Arrow ( ( n : {var_v18:int | true} ) ->  Arrow ( ( l : {var_v19:Ty_list int | true} ) -> {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c (llen)(v) ==(n)
 	 , 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , l, u ) = (true) > >c  }}
  *************** Synthesizing Args ei : ti for ************take
 ##################################################################################
  Synthesizing the 1th argument for Function take
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v18:int | true}
 
 Enumerating a Scalar Term ep
 
 Type of the Scalar Term {var_v0:int | true}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term a1
 
 Type of the Scalar Term {var_v20:int | true}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v10:int | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls take
 ################################################
 
 Enumerating a Scalar Term a11
 
 Type of the Scalar Term {var_v20:int | 
 	 Conj <c true
 	 , a1 > var_v20 >c }
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term _lbv0
 
 Type of the Scalar Term {v:int | (last)(a3) ==(v)}
 standardized VC STANDARD VC_BEGIN TyDBINDS  

 	 ANTE False 
 	 ------------------------

	 CONS True
 
VC_END
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term a2
 
 Type of the Scalar Term {var_v21:int | true}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 1th Args option for take : a2
 >>>>>>>>>>>>>>>>>>> 1th Args option for take : apply last  (, a3 )
 >>>>>>>>>>>>>>>>>>> 1th Args option for take : a11
 >>>>>>>>>>>>>>>>>>> 1th Args option for take : a1
 >>>>>>>>>>>>>>>>>>> 1th Args option for take : ep
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 2th argument for Function take
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v19:Ty_list int | true}
 
 Enumerating a Scalar Term a3
 
 Type of the Scalar Term {v1:Ty_list int | 
 	 Conj <c Negation (a1) > (llen)(v1)
 	 , Negation (a2) > (llen)(v1) >c }
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term x
 
 Type of the Scalar Term {var_v1:Ty_list int | true}
 ################################################
 Skipping Variable x as it is bound variable for Cons constructor
 ################################################
 
 Enumerating a Scalar Term l
 
 Type of the Scalar Term {var_v16:Ty_list int | true}
 ################################################
 Skipping Variable l As this a  Formal Parameter to the current function Call
 Outer Function calls take
 ################################################
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 2th Args option for take : a3
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  *************** Successfully Synthesized Args ei Forall i 
 1 th Argument Options for take
 EI a2
 EI apply last  (, a3 )
 EI a11
 EI a1
 EI ep
 2 th Argument Options for take
 EI a3
 # of Possible Argument Options for take 5
 # of Possible Argument Options for take 5
 Possible Arg Options 
 EI a2
 EI a3
 Possible Arg Options 
 EI apply last  (, a3 )
 EI a3
 Possible Arg Options 
 EI a11
 EI a3
 Possible Arg Options 
 EI a1
 EI a3
 Possible Arg Options 
 EI ep
 EI a3
 Show f (ei, e2, ....en) Case
 Finding Already seen tree for apply take  (, a2 ), a3 )
 Typechecking apply take  (, a2 ), a3 )
 Against {v1:Ty_list int | 
 	 Conj <c Negation (a11) > (llen)(v1)
 	 , Negation (a2) > (llen)(v1) >c }
 Typechecking the Term apply take  (, a2 ), a3 )
 Against {v1:Ty_list int | 
 	 Conj <c Negation (a11) > (llen)(v1)
 	 , Negation (a2) > (llen)(v1) >c }
 Argument a2 :: {var_v21:int | true} | true
 Argument a3 :: {v1:Ty_list int | 
 	 Conj <c Negation (a1) > (llen)(v1)
 	 , Negation (a2) > (llen)(v1) >c } | 
 	 Conj <c Negation (a1) > (llen)(a3)
 	 , Negation (a2) > (llen)(a3) >c 
 AppType Type {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c (llen)(v) ==(a2)
 	 , 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , a3, u ) = (true) > >c  }}             
# of Final Z3 expressions 6
 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply take  (, a2 ), a3 )
 Finding Already seen tree for apply take  (, _lbv0 ), a3 )
 Typechecking apply take  (, apply last  (, a3 ) ), a3 )
 Against {v1:Ty_list int | 
 	 Conj <c Negation (a11) > (llen)(v1)
 	 , Negation (a2) > (llen)(v1) >c }
 Typechecking the Term apply take  (, _lbv0 ), a3 )
 Against {v1:Ty_list int | 
 	 Conj <c Negation (a11) > (llen)(v1)
 	 , Negation (a2) > (llen)(v1) >c }
 Argument _lbv0 :: {v:int | (last)(a3) ==(v)} | (last)(a3) ==(_lbv0)
 Argument a3 :: {v1:Ty_list int | 
 	 Conj <c Negation (a1) > (llen)(v1)
 	 , Negation (a2) > (llen)(v1) >c } | 
 	 Conj <c Negation (a1) > (llen)(a3)
 	 , Negation (a2) > (llen)(a3) >c 
 AppType Type {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c (llen)(v) ==(_lbv0)
 	 , 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , a3, u ) = (true) > >c  }}             
# of Final Z3 expressions 6
 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply take  (, _lbv0 ), a3 )
 Finding Already seen tree for apply take  (, a11 ), a3 )
 Typechecking apply take  (, a11 ), a3 )
 Against {v1:Ty_list int | 
 	 Conj <c Negation (a11) > (llen)(v1)
 	 , Negation (a2) > (llen)(v1) >c }
 Typechecking the Term apply take  (, a11 ), a3 )
 Against {v1:Ty_list int | 
 	 Conj <c Negation (a11) > (llen)(v1)
 	 , Negation (a2) > (llen)(v1) >c }
 Argument a11 :: {var_v20:int | 
 	 Conj <c true
 	 , a1 > var_v20 >c } | 
 	 Conj <c true
 	 , a1 > a11 >c 
 Argument a3 :: {v1:Ty_list int | 
 	 Conj <c Negation (a1) > (llen)(v1)
 	 , Negation (a2) > (llen)(v1) >c } | 
 	 Conj <c Negation (a1) > (llen)(a3)
 	 , Negation (a2) > (llen)(a3) >c 
 AppType Type {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c (llen)(v) ==(a11)
 	 , 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , a3, u ) = (true) > >c  }}                  
# of Final Z3 expressions 6
 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply take  (, a11 ), a3 )
 Finding Already seen tree for apply take  (, a1 ), a3 )
 Typechecking apply take  (, a1 ), a3 )
 Against {v1:Ty_list int | 
 	 Conj <c Negation (a11) > (llen)(v1)
 	 , Negation (a2) > (llen)(v1) >c }
 Typechecking the Term apply take  (, a1 ), a3 )
 Against {v1:Ty_list int | 
 	 Conj <c Negation (a11) > (llen)(v1)
 	 , Negation (a2) > (llen)(v1) >c }
 Argument a1 :: {var_v20:int | true} | true
 Argument a3 :: {v1:Ty_list int | 
 	 Conj <c Negation (a1) > (llen)(v1)
 	 , Negation (a2) > (llen)(v1) >c } | 
 	 Conj <c Negation (a1) > (llen)(a3)
 	 , Negation (a2) > (llen)(a3) >c 
 AppType Type {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c (llen)(v) ==(a1)
 	 , 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , a3, u ) = (true) > >c  }}             
# of Final Z3 expressions 6
 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply take  (, a1 ), a3 )
 Finding Already seen tree for apply take  (, ep ), a3 )
 Typechecking apply take  (, ep ), a3 )
 Against {v1:Ty_list int | 
 	 Conj <c Negation (a11) > (llen)(v1)
 	 , Negation (a2) > (llen)(v1) >c }
 Typechecking the Term apply take  (, ep ), a3 )
 Against {v1:Ty_list int | 
 	 Conj <c Negation (a11) > (llen)(v1)
 	 , Negation (a2) > (llen)(v1) >c }
 Argument ep :: {var_v0:int | true} | true
 Argument a3 :: {v1:Ty_list int | 
 	 Conj <c Negation (a1) > (llen)(v1)
 	 , Negation (a2) > (llen)(v1) >c } | 
 	 Conj <c Negation (a1) > (llen)(a3)
 	 , Negation (a2) > (llen)(a3) >c 
 AppType Type {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c (llen)(v) ==(ep)
 	 , 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , a3, u ) = (true) > >c  }}             
# of Final Z3 expressions 6
 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply take  (, ep ), a3 )
  ###################################################
  The Choice of Function take Was Ill Fated Try Next Choice of function {v1:Ty_list int | 
 	 Conj <c Negation (a11) > (llen)(v1)
 	 , Negation (a2) > (llen)(v1) >c }
 ############################################################
  Synthesizing the Function application Pure Component init
  *************** Trying Arrow Component ************init :  Arrow ( ( l : {var_v17:Ty_list int | true} ) -> {v:Ty_list int | (llen)(v) ==((llen)(v) -- (1))}
  *************** Synthesizing Args ei : ti for ************init
 ##################################################################################
  Synthesizing the 1th argument for Function init
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v17:Ty_list int | true}
 
 Enumerating a Scalar Term a3
 
 Type of the Scalar Term {v1:Ty_list int | 
 	 Conj <c Negation (a1) > (llen)(v1)
 	 , Negation (a2) > (llen)(v1) >c }
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term x
 
 Type of the Scalar Term {var_v1:Ty_list int | true}
 ################################################
 Skipping Variable x as it is bound variable for Cons constructor
 ################################################
 
 Enumerating a Scalar Term l
 
 Type of the Scalar Term {var_v19:Ty_list int | true}
 ################################################
 Skipping Variable l As this a  Formal Parameter to the current function Call
 Outer Function calls init
 ################################################
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 1th Args option for init : a3
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  *************** Successfully Synthesized Args ei Forall i 
 1 th Argument Options for init
 EI a3
 # of Possible Argument Options for init 1
 # of Possible Argument Options for init 1
 Possible Arg Options 
 EI a3
 Apply Single Argument Case : f (ei) Case init
  Case : f (ei) Case init a3
 Finding Already seen tree for apply init  (, a3 )
 Typechecking apply init  (, a3 )
 Against {v1:Ty_list int | 
 	 Conj <c Negation (a11) > (llen)(v1)
 	 , Negation (a2) > (llen)(v1) >c }
 Typechecking the Term apply init  (, a3 )
 Against {v1:Ty_list int | 
 	 Conj <c Negation (a11) > (llen)(v1)
 	 , Negation (a2) > (llen)(v1) >c }
 Argument a3 :: {v1:Ty_list int | 
 	 Conj <c Negation (a1) > (llen)(v1)
 	 , Negation (a2) > (llen)(v1) >c } | 
 	 Conj <c Negation (a1) > (llen)(a3)
 	 , Negation (a2) > (llen)(a3) >c 
 AppType Type {v:Ty_list int | (llen)(v) ==((llen)(v) -- (1))}     
# of Final Z3 expressions 9
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
  Show *************** TypeChecking Succsessful {v:Ty_list int | (llen)(v) ==((llen)(v) -- (1))}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 let _lbv1 = apply init  (, a3 )
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  ###################################################
  The Choice of Function init Was Succefull for {v1:Ty_list int | 
 	 Conj <c Negation (a11) > (llen)(v1)
 	 , Negation (a2) > (llen)(v1) >c } Continuing for completeness
  ###################################################
 >>>>>>>>>>>>>>>>>>> 3th Args option for goal : a3
 >>>>>>>>>>>>>>>>>>> 3th Args option for goal : apply init  (, a3 )
  DEPTH vs MAX  0 vs 2
 ##################################################################################
  *************** Synthesizing Args ei : Failed for some  arg
 ############################################################
  Synthesizing the Function application Pure Component take
  *************** Trying Arrow Component ************take :  Arrow ( ( n : {var_v18:int | true} ) ->  Arrow ( ( l : {var_v19:Ty_list int | true} ) -> {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c (llen)(v) ==(n)
 	 , 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , l, u ) = (true) > >c  }}
  *************** Synthesizing Args ei : ti for ************take
 ##################################################################################
  Synthesizing the 1th argument for Function take
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v18:int | true}
 
 Enumerating a Scalar Term ep
 
 Type of the Scalar Term {var_v0:int | true}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term a1
 
 Type of the Scalar Term {var_v20:int | true}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term a11
 
 Type of the Scalar Term {var_v20:int | 
 	 Conj <c true
 	 , a1 > var_v20 >c }
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term _lbv0
 
 Type of the Scalar Term {v:int | (last)(a3) ==(v)}
 standardized VC STANDARD VC_BEGIN TyDBINDS  

 	 ANTE False 
 	 ------------------------

	 CONS True
 
VC_END
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term a2
 
 Type of the Scalar Term {var_v21:int | true}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v18:int | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 Outer Function calls take
 ################################################
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  , 
 last, 
 nth, 
 hd, 
 length
 ############################################################
  Synthesizing the Function application Pure Component last
  *************** Trying Arrow Component ************last :  Arrow ( ( l : {var_v16:Ty_list int | true} ) -> {v:int | (last)(l) ==(v)}
  *************** Synthesizing Args ei : ti for ************last
 ##################################################################################
  Synthesizing the 1th argument for Function last
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v16:Ty_list int | true}
 
 Enumerating a Scalar Term x
 
 Type of the Scalar Term {var_v1:Ty_list int | true}
 ################################################
 Skipping Variable x as it is bound variable for Cons constructor
 ################################################
 
 Enumerating a Scalar Term l
 
 Type of the Scalar Term {var_v17:Ty_list int | true}
 ################################################
 Skipping Variable l As this a  Formal Parameter to the current function Call
 Outer Function calls last
 ################################################
 
 Enumerating a Scalar Term _lbv1
 
 Type of the Scalar Term {v:Ty_list int | (llen)(v) ==((llen)(v) -- (1))}
 standardized VC STANDARD VC_BEGIN TyDBINDS  

 	 ANTE False 
 	 ------------------------

	 CONS True
 
VC_END
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term a3
 
 Type of the Scalar Term {v1:Ty_list int | 
 	 Conj <c Negation (a11) > (llen)(v1)
 	 , Negation (a2) > (llen)(v1) >c }
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 1th Args option for last : a3
 >>>>>>>>>>>>>>>>>>> 1th Args option for last : apply init  (, a3 )
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  *************** Successfully Synthesized Args ei Forall i 
 1 th Argument Options for last
 EI a3
 EI apply init  (, a3 )
 # of Possible Argument Options for last 2
 # of Possible Argument Options for last 2
 Possible Arg Options 
 EI a3
 Possible Arg Options 
 EI apply init  (, a3 )
 Apply Single Argument Case : f (ei) Case last
  Case : f (ei) Case last a3
 Finding Already seen tree for apply last  (, a3 )
 Found _lbv0
  Case : f (ei) Case last _lbv1
 Finding Already seen tree for apply last  (, _lbv1 )
 Typechecking apply last  (, apply init  (, a3 ) )
 Against {var_v18:int | true}
 Typechecking the Term apply last  (, _lbv1 )
 Against {var_v18:int | true}
 Argument _lbv1 :: {v:Ty_list int | (llen)(v) ==((llen)(v) -- (1))} | (llen)(_lbv1) ==((llen)(_lbv1) -- (1))
 AppType Type {v:int | (last)(_lbv1) ==(v)}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
  Show *************** TypeChecking Succsessful {v:int | (last)(_lbv1) ==(v)}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 let _lbv2 = apply last  (, _lbv1 )
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  ###################################################
  The Choice of Function last Was Succefull for {var_v18:int | true} Continuing for completeness
  ###################################################
 >>>>>>>>>>>>>>>>>>> 1th Args option for take : a2
 >>>>>>>>>>>>>>>>>>> 1th Args option for take : apply last  (, a3 )
 >>>>>>>>>>>>>>>>>>> 1th Args option for take : a11
 >>>>>>>>>>>>>>>>>>> 1th Args option for take : a1
 >>>>>>>>>>>>>>>>>>> 1th Args option for take : ep
 >>>>>>>>>>>>>>>>>>> 1th Args option for take : apply last  (, apply init  (, a3 ) )
 >>>>>>>>>>>>>>>>>>> 1th Args option for take : apply last  (, a3 )
  DEPTH vs MAX  0 vs 2
 ##################################################################################
  Synthesizing the 2th argument for Function take
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v19:Ty_list int | true}
 
 Enumerating a Scalar Term x
 
 Type of the Scalar Term {var_v1:Ty_list int | true}
 ################################################
 Skipping Variable x as it is bound variable for Cons constructor
 ################################################
 
 Enumerating a Scalar Term _lbv1
 
 Type of the Scalar Term {v:Ty_list int | (llen)(v) ==((llen)(v) -- (1))}
 standardized VC STANDARD VC_BEGIN TyDBINDS  

 	 ANTE False 
 	 ------------------------

	 CONS True
 
VC_END
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term a3
 
 Type of the Scalar Term {v1:Ty_list int | 
 	 Conj <c Negation (a11) > (llen)(v1)
 	 , Negation (a2) > (llen)(v1) >c }
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term l
 
 Type of the Scalar Term {var_v16:Ty_list int | true}
 ################################################
 Skipping Variable l As this a  Formal Parameter to the current function Call
 Outer Function calls take
 ################################################
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  , 
 goal, 
 take, 
 init, 
 append, 
 tl, 
 cons, 
 rev
 ############################################################
  Synthesizing the Function application Pure Component goal
  *************** Trying Arrow Component ************goal :  Arrow ( ( a11 : {var_v20:int | 
 	 Conj <c true
 	 , a1 > var_v20 >c } ) ->  Arrow ( ( a2 : {var_v21:int | true} ) ->  Arrow ( ( a3 : {v1:Ty_list int | 
 	 Conj <c Negation (a11) > (llen)(v1)
 	 , Negation (a2) > (llen)(v1) >c } ) -> {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , a3, u ) = (true) >
 	 , 
 	 Conj <c (llen)(v) ==((llen)(a3) + (2))
 	 , 
 	 Conj <c (nth)( , a3, a11 ) ==(pen)(v)
 	 , (nth)( , a3, a2 ) ==(last)(v) >c  >c  >c  }}
  *************** Synthesizing Args ei : ti for ************goal
 ##################################################################################
  Synthesizing the 1th argument for Function goal
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v20:int | 
 	 Conj <c true
 	 , a1 > var_v20 >c }
 
 Enumerating a Scalar Term ep
 
 Type of the Scalar Term {var_v0:int | true}          
# of Final Z3 expressions 7
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term a1
 
 Type of the Scalar Term {var_v20:int | true}          
# of Final Z3 expressions 7
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term a11
 
 Type of the Scalar Term {var_v20:int | 
 	 Conj <c true
 	 , a1 > var_v20 >c }               
# of Final Z3 expressions 8
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term _lbv0
 
 Type of the Scalar Term {v:int | (last)(a3) ==(v)}
 standardized VC STANDARD VC_BEGIN TyDBINDS  
 
 goal --->  Function type  
 take --->  Function type  
 init --->  Function type  
 last --->  Function type  
 null --->  Function type  
 splitAt --->  Function type  
 combine --->  Function type  
 append --->  Function type  
 nth --->  Function type  
 tl --->  Function type  
 hd --->  Function type  
 cons --->  Function type  
 compare_lengths --->  Function type  
 rev --->  Function type  
 length --->  Function type  
 ep --->  int  
 a1 --->  int  
 x --->  Ty_list int  
 a11 --->  int  
 a2 --->  int  
 _lbv1 --->  Ty_list int  
 a3 --->  Ty_list int  
 l --->  Ty_list int  
 _lbv2 --->  int  
 n --->  int  
 _lbv0 --->  int 
 	 ANTE Conj  AND 
 	 Base a1 > a11 AND 
 	 Rel (llen)(_lbv1) ==((llen)(_lbv1) -- (1)) AND 
 	 Not Rel (a11) > (llen)(a3) AND 
 	 Not Rel (a2) > (llen)(a3) AND 
 	 Rel (last)(_lbv1) ==(_lbv2) AND 
 	 Rel (last)(a3) ==(_lbv0) AND 
 	 Rel (last)(a3) ==(_lbv0) 
 	 ------------------------

	 CONS Base a1 > _lbv0
 
VC_END          
# of Final Z3 expressions 8
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term a2
 
 Type of the Scalar Term {var_v21:int | true}          
# of Final Z3 expressions 7
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term _lbv2
 
 Type of the Scalar Term {v:int | (last)(_lbv1) ==(v)}
 standardized VC STANDARD VC_BEGIN TyDBINDS  
 
 goal --->  Function type  
 take --->  Function type  
 init --->  Function type  
 last --->  Function type  
 null --->  Function type  
 splitAt --->  Function type  
 combine --->  Function type  
 append --->  Function type  
 nth --->  Function type  
 tl --->  Function type  
 hd --->  Function type  
 cons --->  Function type  
 compare_lengths --->  Function type  
 rev --->  Function type  
 length --->  Function type  
 ep --->  int  
 a1 --->  int  
 x --->  Ty_list int  
 a11 --->  int  
 _lbv0 --->  int  
 a2 --->  int  
 _lbv1 --->  Ty_list int  
 a3 --->  Ty_list int  
 l --->  Ty_list int  
 n --->  int  
 _lbv2 --->  int 
 	 ANTE Conj  AND 
 	 Base a1 > a11 AND 
 	 Rel (last)(a3) ==(_lbv0) AND 
 	 Rel (llen)(_lbv1) ==((llen)(_lbv1) -- (1)) AND 
 	 Not Rel (a11) > (llen)(a3) AND 
 	 Not Rel (a2) > (llen)(a3) AND 
 	 Rel (last)(_lbv1) ==(_lbv2) AND 
 	 Rel (last)(_lbv1) ==(_lbv2) 
 	 ------------------------

	 CONS Base a1 > _lbv2
 
VC_END          
# of Final Z3 expressions 8
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v18:int | true}          
# of Final Z3 expressions 7
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 1th Args option for goal : n
 >>>>>>>>>>>>>>>>>>> 1th Args option for goal : apply last  (, apply init  (, a3 ) )
 >>>>>>>>>>>>>>>>>>> 1th Args option for goal : a2
 >>>>>>>>>>>>>>>>>>> 1th Args option for goal : apply last  (, a3 )
 >>>>>>>>>>>>>>>>>>> 1th Args option for goal : a11
 >>>>>>>>>>>>>>>>>>> 1th Args option for goal : a1
 >>>>>>>>>>>>>>>>>>> 1th Args option for goal : ep
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 2th argument for Function goal
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v21:int | true}
 
 Enumerating a Scalar Term ep
 
 Type of the Scalar Term {var_v0:int | true}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term a1
 
 Type of the Scalar Term {var_v20:int | true}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term _lbv0
 
 Type of the Scalar Term {v:int | (last)(a3) ==(v)}
 standardized VC STANDARD VC_BEGIN TyDBINDS  

 	 ANTE False 
 	 ------------------------

	 CONS True
 
VC_END
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term a2
 
 Type of the Scalar Term {var_v21:int | true}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term _lbv2
 
 Type of the Scalar Term {v:int | (last)(_lbv1) ==(v)}
 standardized VC STANDARD VC_BEGIN TyDBINDS  

 	 ANTE False 
 	 ------------------------

	 CONS True
 
VC_END
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {var_v18:int | true}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term a11
 
 Type of the Scalar Term {var_v20:int | 
 	 Conj <c true
 	 , a1 > var_v20 >c }
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 2th Args option for goal : a11
 >>>>>>>>>>>>>>>>>>> 2th Args option for goal : n
 >>>>>>>>>>>>>>>>>>> 2th Args option for goal : apply last  (, apply init  (, a3 ) )
 >>>>>>>>>>>>>>>>>>> 2th Args option for goal : a2
 >>>>>>>>>>>>>>>>>>> 2th Args option for goal : apply last  (, a3 )
 >>>>>>>>>>>>>>>>>>> 2th Args option for goal : a1
 >>>>>>>>>>>>>>>>>>> 2th Args option for goal : ep
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 3th argument for Function goal
  Trying Arguments in Scalars 
 esynthesizeScalar for {v1:Ty_list int | 
 	 Conj <c Negation (a11) > (llen)(v1)
 	 , Negation (a2) > (llen)(v1) >c }
 
 Enumerating a Scalar Term x
 
 Type of the Scalar Term {var_v1:Ty_list int | true}
 ################################################
 Skipping Variable x as it is bound variable for Cons constructor
 ################################################
 
 Enumerating a Scalar Term _lbv1
 
 Type of the Scalar Term {v:Ty_list int | (llen)(v) ==((llen)(v) -- (1))}
 standardized VC STANDARD VC_BEGIN TyDBINDS  
 
 goal --->  Function type  
 take --->  Function type  
 init --->  Function type  
 last --->  Function type  
 null --->  Function type  
 splitAt --->  Function type  
 combine --->  Function type  
 append --->  Function type  
 nth --->  Function type  
 tl --->  Function type  
 hd --->  Function type  
 cons --->  Function type  
 compare_lengths --->  Function type  
 rev --->  Function type  
 length --->  Function type  
 ep --->  int  
 a1 --->  int  
 x --->  Ty_list int  
 _lbv0 --->  int  
 a3 --->  Ty_list int  
 l --->  Ty_list int  
 _lbv2 --->  int  
 n --->  int  
 a11 --->  int  
 a2 --->  int  
 _lbv1 --->  Ty_list int 
 	 ANTE Conj  AND 
 	 Rel (last)(a3) ==(_lbv0) AND 
 	 Not Rel (a11) > (llen)(a3) AND 
 	 Not Rel (a2) > (llen)(a3) AND 
 	 Rel (last)(_lbv1) ==(_lbv2) AND 
 	 Base a1 > a11 AND 
 	 Rel (llen)(_lbv1) ==((llen)(_lbv1) -- (1)) AND 
 	 Rel (llen)(_lbv1) ==((llen)(_lbv1) -- (1)) 
 	 ------------------------

	 CONS Conj  AND 
 	 Not Rel (a11) > (llen)(_lbv1) AND 
 	 Not Rel (a2) > (llen)(_lbv1)
 
VC_END     
# of Final Z3 expressions 8
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term a3
 
 Type of the Scalar Term {v1:Ty_list int | 
 	 Conj <c Negation (a11) > (llen)(v1)
 	 , Negation (a2) > (llen)(v1) >c }     
# of Final Z3 expressions 9
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term l
 
 Type of the Scalar Term {var_v16:Ty_list int | true}     
# of Final Z3 expressions 7
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 3th Args option for goal : l
 >>>>>>>>>>>>>>>>>>> 3th Args option for goal : a3
 >>>>>>>>>>>>>>>>>>> 3th Args option for goal : apply init  (, a3 )
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  *************** Successfully Synthesized Args ei Forall i 
 1 th Argument Options for goal
 EI n
 EI apply last  (, apply init  (, a3 ) )
 EI a2
 EI apply last  (, a3 )
 EI a11
 EI a1
 EI ep
 2 th Argument Options for goal
 EI a11
 EI n
 EI apply last  (, apply init  (, a3 ) )
 EI a2
 EI apply last  (, a3 )
 EI a1
 EI ep
 3 th Argument Options for goal
 EI l
 EI a3
 EI apply init  (, a3 )
 # of Possible Argument Options for goal 147
 # of Possible Argument Options for goal 20
 Possible Arg Options 
 EI n
 EI apply last  (, apply init  (, a3 ) )
 EI a3
 Possible Arg Options 
 EI apply last  (, a3 )
 EI apply last  (, apply init  (, a3 ) )
 EI apply init  (, a3 )
 Possible Arg Options 
 EI a1
 EI ep
 EI a3
 Possible Arg Options 
 EI apply last  (, apply init  (, a3 ) )
 EI apply last  (, apply init  (, a3 ) )
 EI l
 Possible Arg Options 
 EI a1
 EI apply last  (, apply init  (, a3 ) )
 EI a3
 Possible Arg Options 
 EI apply last  (, apply init  (, a3 ) )
 EI apply last  (, apply init  (, a3 ) )
 EI apply init  (, a3 )
 Possible Arg Options 
 EI apply last  (, a3 )
 EI apply last  (, a3 )
 EI a3
 Possible Arg Options 
 EI a2
 EI a2
 EI a3
 Possible Arg Options 
 EI a2
 EI n
 EI l
 Possible Arg Options 
 EI ep
 EI apply last  (, apply init  (, a3 ) )
 EI l
 Possible Arg Options 
 EI ep
 EI a11
 EI apply init  (, a3 )
 Possible Arg Options 
 EI a11
 EI a2
 EI apply init  (, a3 )
 Possible Arg Options 
 EI n
 EI apply last  (, apply init  (, a3 ) )
 EI l
 Possible Arg Options 
 EI a1
 EI a11
 EI l
 Possible Arg Options 
 EI apply last  (, apply init  (, a3 ) )
 EI a2
 EI apply init  (, a3 )
 Possible Arg Options 
 EI n
 EI a1
 EI l
 Possible Arg Options 
 EI ep
 EI apply last  (, a3 )
 EI apply init  (, a3 )
 Possible Arg Options 
 EI a1
 EI apply last  (, a3 )
 EI a3
 Possible Arg Options 
 EI apply last  (, apply init  (, a3 ) )
 EI n
 EI a3
 Possible Arg Options 
 EI ep
 EI a2
 EI l
 Show f (ei, e2, ....en) Case
 Finding Already seen tree for apply goal  (, n ), _lbv2 ), a3 )
 Typechecking apply goal  (, n ), apply last  (, apply init  (, a3 ) ) ), a3 )
 Against {var_v19:Ty_list int | true}
 Typechecking the Term apply goal  (, n ), _lbv2 ), a3 )
 Against {var_v19:Ty_list int | true}
 Argument n :: {var_v18:int | true} | true
 Argument _lbv2 :: {v:int | (last)(_lbv1) ==(v)} | (last)(_lbv1) ==(_lbv2)
 Argument a3 :: {v1:Ty_list int | 
 	 Conj <c Negation (a11) > (llen)(v1)
 	 , Negation (a2) > (llen)(v1) >c } | 
 	 Conj <c Negation (a11) > (llen)(a3)
 	 , Negation (a2) > (llen)(a3) >c 
 AppType Type {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , a3, u ) = (true) >
 	 , 
 	 Conj <c (llen)(v) ==((llen)(a3) + (2))
 	 , 
 	 Conj <c (nth)( , a3, n ) ==(pen)(v)
 	 , (nth)( , a3, _lbv2 ) ==(last)(v) >c  >c  >c  }}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
  Show *************** TypeChecking Succsessful {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , a3, u ) = (true) >
 	 , 
 	 Conj <c (llen)(v) ==((llen)(a3) + (2))
 	 , 
 	 Conj <c (nth)( , a3, n ) ==(pen)(v)
 	 , (nth)( , a3, _lbv2 ) ==(last)(v) >c  >c  >c  }}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 let _lbv3 = apply goal  (, n ), _lbv2 ), a3 )
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 Finding Already seen tree for apply goal  (, _lbv0 ), _lbv2 ), _lbv1 )
 Typechecking apply goal  (, apply last  (, a3 ) ), apply last  (, apply init  (, a3 ) ) ), apply init  (, a3 ) )
 Against {var_v19:Ty_list int | true}
 Typechecking the Term apply goal  (, _lbv0 ), _lbv2 ), _lbv1 )
 Against {var_v19:Ty_list int | true}
 Argument _lbv0 :: {v:int | (last)(a3) ==(v)} | (last)(a3) ==(_lbv0)
 Argument _lbv2 :: {v:int | (last)(_lbv1) ==(v)} | (last)(_lbv1) ==(_lbv2)
 Argument _lbv1 :: {v:Ty_list int | (llen)(v) ==((llen)(v) -- (1))} | (llen)(_lbv1) ==((llen)(_lbv1) -- (1))
 AppType Type {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , _lbv1, u ) = (true) >
 	 , 
 	 Conj <c (llen)(v) ==((llen)(_lbv1) + (2))
 	 , 
 	 Conj <c (nth)( , _lbv1, _lbv0 ) ==(pen)(v)
 	 , (nth)( , _lbv1, _lbv2 ) ==(last)(v) >c  >c  >c  }}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
  Show *************** TypeChecking Succsessful {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , _lbv1, u ) = (true) >
 	 , 
 	 Conj <c (llen)(v) ==((llen)(_lbv1) + (2))
 	 , 
 	 Conj <c (nth)( , _lbv1, _lbv0 ) ==(pen)(v)
 	 , (nth)( , _lbv1, _lbv2 ) ==(last)(v) >c  >c  >c  }}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 let _lbv4 = apply goal  (, _lbv0 ), _lbv2 ), _lbv1 )
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 Finding Already seen tree for apply goal  (, a1 ), ep ), a3 )
 Typechecking apply goal  (, a1 ), ep ), a3 )
 Against {var_v19:Ty_list int | true}
 Typechecking the Term apply goal  (, a1 ), ep ), a3 )
 Against {var_v19:Ty_list int | true}
 Argument a1 :: {var_v20:int | true} | true
 Argument ep :: {var_v0:int | true} | true
 Argument a3 :: {v1:Ty_list int | 
 	 Conj <c Negation (a11) > (llen)(v1)
 	 , Negation (a2) > (llen)(v1) >c } | 
 	 Conj <c Negation (a11) > (llen)(a3)
 	 , Negation (a2) > (llen)(a3) >c 
 AppType Type {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , a3, u ) = (true) >
 	 , 
 	 Conj <c (llen)(v) ==((llen)(a3) + (2))
 	 , 
 	 Conj <c (nth)( , a3, a1 ) ==(pen)(v)
 	 , (nth)( , a3, ep ) ==(last)(v) >c  >c  >c  }}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
  Show *************** TypeChecking Succsessful {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , a3, u ) = (true) >
 	 , 
 	 Conj <c (llen)(v) ==((llen)(a3) + (2))
 	 , 
 	 Conj <c (nth)( , a3, a1 ) ==(pen)(v)
 	 , (nth)( , a3, ep ) ==(last)(v) >c  >c  >c  }}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 let _lbv5 = apply goal  (, a1 ), ep ), a3 )
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 Finding Already seen tree for apply goal  (, _lbv2 ), _lbv2 ), l )
 Typechecking apply goal  (, apply last  (, apply init  (, a3 ) ) ), apply last  (, apply init  (, a3 ) ) ), l )
 Against {var_v19:Ty_list int | true}
 Typechecking the Term apply goal  (, _lbv2 ), _lbv2 ), l )
 Against {var_v19:Ty_list int | true}
 Argument _lbv2 :: {v:int | (last)(_lbv1) ==(v)} | (last)(_lbv1) ==(_lbv2)
 Argument _lbv2 :: {v:int | (last)(_lbv1) ==(v)} | (last)(_lbv1) ==(_lbv2)
 Argument l :: {var_v16:Ty_list int | true} | true
 AppType Type {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , l, u ) = (true) >
 	 , 
 	 Conj <c (llen)(v) ==((llen)(l) + (2))
 	 , 
 	 Conj <c (nth)( , l, _lbv2 ) ==(pen)(v)
 	 , (nth)( , l, _lbv2 ) ==(last)(v) >c  >c  >c  }}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
  Show *************** TypeChecking Succsessful {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , l, u ) = (true) >
 	 , 
 	 Conj <c (llen)(v) ==((llen)(l) + (2))
 	 , 
 	 Conj <c (nth)( , l, _lbv2 ) ==(pen)(v)
 	 , (nth)( , l, _lbv2 ) ==(last)(v) >c  >c  >c  }}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 let _lbv6 = apply goal  (, _lbv2 ), _lbv2 ), l )
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 Finding Already seen tree for apply goal  (, a1 ), _lbv2 ), a3 )
 Typechecking apply goal  (, a1 ), apply last  (, apply init  (, a3 ) ) ), a3 )
 Against {var_v19:Ty_list int | true}
 Typechecking the Term apply goal  (, a1 ), _lbv2 ), a3 )
 Against {var_v19:Ty_list int | true}
 Argument a1 :: {var_v20:int | true} | true
 Argument _lbv2 :: {v:int | (last)(_lbv1) ==(v)} | (last)(_lbv1) ==(_lbv2)
 Argument a3 :: {v1:Ty_list int | 
 	 Conj <c Negation (a11) > (llen)(v1)
 	 , Negation (a2) > (llen)(v1) >c } | 
 	 Conj <c Negation (a11) > (llen)(a3)
 	 , Negation (a2) > (llen)(a3) >c 
 AppType Type {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , a3, u ) = (true) >
 	 , 
 	 Conj <c (llen)(v) ==((llen)(a3) + (2))
 	 , 
 	 Conj <c (nth)( , a3, a1 ) ==(pen)(v)
 	 , (nth)( , a3, _lbv2 ) ==(last)(v) >c  >c  >c  }}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
  Show *************** TypeChecking Succsessful {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , a3, u ) = (true) >
 	 , 
 	 Conj <c (llen)(v) ==((llen)(a3) + (2))
 	 , 
 	 Conj <c (nth)( , a3, a1 ) ==(pen)(v)
 	 , (nth)( , a3, _lbv2 ) ==(last)(v) >c  >c  >c  }}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 let _lbv7 = apply goal  (, a1 ), _lbv2 ), a3 )
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 Finding Already seen tree for apply goal  (, _lbv2 ), _lbv2 ), _lbv1 )
 Typechecking apply goal  (, apply last  (, apply init  (, a3 ) ) ), apply last  (, apply init  (, a3 ) ) ), apply init  (, a3 ) )
 Against {var_v19:Ty_list int | true}
 Typechecking the Term apply goal  (, _lbv2 ), _lbv2 ), _lbv1 )
 Against {var_v19:Ty_list int | true}
 Argument _lbv2 :: {v:int | (last)(_lbv1) ==(v)} | (last)(_lbv1) ==(_lbv2)
 Argument _lbv2 :: {v:int | (last)(_lbv1) ==(v)} | (last)(_lbv1) ==(_lbv2)
 Argument _lbv1 :: {v:Ty_list int | (llen)(v) ==((llen)(v) -- (1))} | (llen)(_lbv1) ==((llen)(_lbv1) -- (1))
 AppType Type {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , _lbv1, u ) = (true) >
 	 , 
 	 Conj <c (llen)(v) ==((llen)(_lbv1) + (2))
 	 , 
 	 Conj <c (nth)( , _lbv1, _lbv2 ) ==(pen)(v)
 	 , (nth)( , _lbv1, _lbv2 ) ==(last)(v) >c  >c  >c  }}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
  Show *************** TypeChecking Succsessful {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , _lbv1, u ) = (true) >
 	 , 
 	 Conj <c (llen)(v) ==((llen)(_lbv1) + (2))
 	 , 
 	 Conj <c (nth)( , _lbv1, _lbv2 ) ==(pen)(v)
 	 , (nth)( , _lbv1, _lbv2 ) ==(last)(v) >c  >c  >c  }}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 let _lbv8 = apply goal  (, _lbv2 ), _lbv2 ), _lbv1 )
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 Finding Already seen tree for apply goal  (, _lbv0 ), _lbv0 ), a3 )
 Typechecking apply goal  (, apply last  (, a3 ) ), apply last  (, a3 ) ), a3 )
 Against {var_v19:Ty_list int | true}
 Typechecking the Term apply goal  (, _lbv0 ), _lbv0 ), a3 )
 Against {var_v19:Ty_list int | true}
 Argument _lbv0 :: {v:int | (last)(a3) ==(v)} | (last)(a3) ==(_lbv0)
 Argument _lbv0 :: {v:int | (last)(a3) ==(v)} | (last)(a3) ==(_lbv0)
 Argument a3 :: {v1:Ty_list int | 
 	 Conj <c Negation (a11) > (llen)(v1)
 	 , Negation (a2) > (llen)(v1) >c } | 
 	 Conj <c Negation (a11) > (llen)(a3)
 	 , Negation (a2) > (llen)(a3) >c 
 AppType Type {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , a3, u ) = (true) >
 	 , 
 	 Conj <c (llen)(v) ==((llen)(a3) + (2))
 	 , 
 	 Conj <c (nth)( , a3, _lbv0 ) ==(pen)(v)
 	 , (nth)( , a3, _lbv0 ) ==(last)(v) >c  >c  >c  }}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
  Show *************** TypeChecking Succsessful {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , a3, u ) = (true) >
 	 , 
 	 Conj <c (llen)(v) ==((llen)(a3) + (2))
 	 , 
 	 Conj <c (nth)( , a3, _lbv0 ) ==(pen)(v)
 	 , (nth)( , a3, _lbv0 ) ==(last)(v) >c  >c  >c  }}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 let _lbv9 = apply goal  (, _lbv0 ), _lbv0 ), a3 )
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 Finding Already seen tree for apply goal  (, a2 ), a2 ), a3 )
 Typechecking apply goal  (, a2 ), a2 ), a3 )
 Against {var_v19:Ty_list int | true}
 Typechecking the Term apply goal  (, a2 ), a2 ), a3 )
 Against {var_v19:Ty_list int | true}
 Argument a2 :: {var_v21:int | true} | true
 Argument a2 :: {var_v21:int | true} | true
 Argument a3 :: {v1:Ty_list int | 
 	 Conj <c Negation (a11) > (llen)(v1)
 	 , Negation (a2) > (llen)(v1) >c } | 
 	 Conj <c Negation (a11) > (llen)(a3)
 	 , Negation (a2) > (llen)(a3) >c 
 AppType Type {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , a3, u ) = (true) >
 	 , 
 	 Conj <c (llen)(v) ==((llen)(a3) + (2))
 	 , 
 	 Conj <c (nth)( , a3, a2 ) ==(pen)(v)
 	 , (nth)( , a3, a2 ) ==(last)(v) >c  >c  >c  }}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
  Show *************** TypeChecking Succsessful {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , a3, u ) = (true) >
 	 , 
 	 Conj <c (llen)(v) ==((llen)(a3) + (2))
 	 , 
 	 Conj <c (nth)( , a3, a2 ) ==(pen)(v)
 	 , (nth)( , a3, a2 ) ==(last)(v) >c  >c  >c  }}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 let _lbv10 = apply goal  (, a2 ), a2 ), a3 )
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 Finding Already seen tree for apply goal  (, a2 ), n ), l )
 Typechecking apply goal  (, a2 ), n ), l )
 Against {var_v19:Ty_list int | true}
 Typechecking the Term apply goal  (, a2 ), n ), l )
 Against {var_v19:Ty_list int | true}
 Argument a2 :: {var_v21:int | true} | true
 Argument n :: {var_v18:int | true} | true
 Argument l :: {var_v16:Ty_list int | true} | true
 AppType Type {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , l, u ) = (true) >
 	 , 
 	 Conj <c (llen)(v) ==((llen)(l) + (2))
 	 , 
 	 Conj <c (nth)( , l, a2 ) ==(pen)(v)
 	 , (nth)( , l, n ) ==(last)(v) >c  >c  >c  }}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
  Show *************** TypeChecking Succsessful {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , l, u ) = (true) >
 	 , 
 	 Conj <c (llen)(v) ==((llen)(l) + (2))
 	 , 
 	 Conj <c (nth)( , l, a2 ) ==(pen)(v)
 	 , (nth)( , l, n ) ==(last)(v) >c  >c  >c  }}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 let _lbv11 = apply goal  (, a2 ), n ), l )
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 Finding Already seen tree for apply goal  (, ep ), _lbv2 ), l )
 Typechecking apply goal  (, ep ), apply last  (, apply init  (, a3 ) ) ), l )
 Against {var_v19:Ty_list int | true}
 Typechecking the Term apply goal  (, ep ), _lbv2 ), l )
 Against {var_v19:Ty_list int | true}
 Argument ep :: {var_v0:int | true} | true
 Argument _lbv2 :: {v:int | (last)(_lbv1) ==(v)} | (last)(_lbv1) ==(_lbv2)
 Argument l :: {var_v16:Ty_list int | true} | true
 AppType Type {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , l, u ) = (true) >
 	 , 
 	 Conj <c (llen)(v) ==((llen)(l) + (2))
 	 , 
 	 Conj <c (nth)( , l, ep ) ==(pen)(v)
 	 , (nth)( , l, _lbv2 ) ==(last)(v) >c  >c  >c  }}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
  Show *************** TypeChecking Succsessful {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , l, u ) = (true) >
 	 , 
 	 Conj <c (llen)(v) ==((llen)(l) + (2))
 	 , 
 	 Conj <c (nth)( , l, ep ) ==(pen)(v)
 	 , (nth)( , l, _lbv2 ) ==(last)(v) >c  >c  >c  }}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 let _lbv12 = apply goal  (, ep ), _lbv2 ), l )
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 Finding Already seen tree for apply goal  (, ep ), a11 ), _lbv1 )
 Typechecking apply goal  (, ep ), a11 ), apply init  (, a3 ) )
 Against {var_v19:Ty_list int | true}
 Typechecking the Term apply goal  (, ep ), a11 ), _lbv1 )
 Against {var_v19:Ty_list int | true}
 Argument ep :: {var_v0:int | true} | true
 Argument a11 :: {var_v20:int | 
 	 Conj <c true
 	 , a1 > var_v20 >c } | 
 	 Conj <c true
 	 , a1 > a11 >c 
 Argument _lbv1 :: {v:Ty_list int | (llen)(v) ==((llen)(v) -- (1))} | (llen)(_lbv1) ==((llen)(_lbv1) -- (1))
 AppType Type {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , _lbv1, u ) = (true) >
 	 , 
 	 Conj <c (llen)(v) ==((llen)(_lbv1) + (2))
 	 , 
 	 Conj <c (nth)( , _lbv1, ep ) ==(pen)(v)
 	 , (nth)( , _lbv1, ep ) ==(last)(v) >c  >c  >c  }}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
  Show *************** TypeChecking Succsessful {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , _lbv1, u ) = (true) >
 	 , 
 	 Conj <c (llen)(v) ==((llen)(_lbv1) + (2))
 	 , 
 	 Conj <c (nth)( , _lbv1, ep ) ==(pen)(v)
 	 , (nth)( , _lbv1, ep ) ==(last)(v) >c  >c  >c  }}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 let _lbv13 = apply goal  (, ep ), a11 ), _lbv1 )
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 Finding Already seen tree for apply goal  (, a11 ), a2 ), _lbv1 )
 Typechecking apply goal  (, a11 ), a2 ), apply init  (, a3 ) )
 Against {var_v19:Ty_list int | true}
 Typechecking the Term apply goal  (, a11 ), a2 ), _lbv1 )
 Against {var_v19:Ty_list int | true}
 Argument a11 :: {var_v20:int | 
 	 Conj <c true
 	 , a1 > var_v20 >c } | 
 	 Conj <c true
 	 , a1 > a11 >c 
 Argument a2 :: {var_v21:int | true} | true
 Argument _lbv1 :: {v:Ty_list int | (llen)(v) ==((llen)(v) -- (1))} | (llen)(_lbv1) ==((llen)(_lbv1) -- (1))
 AppType Type {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , _lbv1, u ) = (true) >
 	 , 
 	 Conj <c (llen)(v) ==((llen)(_lbv1) + (2))
 	 , 
 	 Conj <c (nth)( , _lbv1, a11 ) ==(pen)(v)
 	 , (nth)( , _lbv1, a2 ) ==(last)(v) >c  >c  >c  }}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
  Show *************** TypeChecking Succsessful {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , _lbv1, u ) = (true) >
 	 , 
 	 Conj <c (llen)(v) ==((llen)(_lbv1) + (2))
 	 , 
 	 Conj <c (nth)( , _lbv1, a11 ) ==(pen)(v)
 	 , (nth)( , _lbv1, a2 ) ==(last)(v) >c  >c  >c  }}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 let _lbv14 = apply goal  (, a11 ), a2 ), _lbv1 )
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 Finding Already seen tree for apply goal  (, n ), _lbv2 ), l )
 Typechecking apply goal  (, n ), apply last  (, apply init  (, a3 ) ) ), l )
 Against {var_v19:Ty_list int | true}
 Typechecking the Term apply goal  (, n ), _lbv2 ), l )
 Against {var_v19:Ty_list int | true}
 Argument n :: {var_v18:int | true} | true
 Argument _lbv2 :: {v:int | (last)(_lbv1) ==(v)} | (last)(_lbv1) ==(_lbv2)
 Argument l :: {var_v16:Ty_list int | true} | true
 AppType Type {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , l, u ) = (true) >
 	 , 
 	 Conj <c (llen)(v) ==((llen)(l) + (2))
 	 , 
 	 Conj <c (nth)( , l, n ) ==(pen)(v)
 	 , (nth)( , l, _lbv2 ) ==(last)(v) >c  >c  >c  }}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
  Show *************** TypeChecking Succsessful {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , l, u ) = (true) >
 	 , 
 	 Conj <c (llen)(v) ==((llen)(l) + (2))
 	 , 
 	 Conj <c (nth)( , l, n ) ==(pen)(v)
 	 , (nth)( , l, _lbv2 ) ==(last)(v) >c  >c  >c  }}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 let _lbv15 = apply goal  (, n ), _lbv2 ), l )
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 Finding Already seen tree for apply goal  (, a1 ), a11 ), l )
 Typechecking apply goal  (, a1 ), a11 ), l )
 Against {var_v19:Ty_list int | true}
 Typechecking the Term apply goal  (, a1 ), a11 ), l )
 Against {var_v19:Ty_list int | true}
 Argument a1 :: {var_v20:int | true} | true
 Argument a11 :: {var_v20:int | 
 	 Conj <c true
 	 , a1 > var_v20 >c } | 
 	 Conj <c true
 	 , a1 > a11 >c 
 Argument l :: {var_v16:Ty_list int | true} | true
 AppType Type {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , l, u ) = (true) >
 	 , 
 	 Conj <c (llen)(v) ==((llen)(l) + (2))
 	 , 
 	 Conj <c (nth)( , l, a1 ) ==(pen)(v)
 	 , (nth)( , l, a1 ) ==(last)(v) >c  >c  >c  }}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
  Show *************** TypeChecking Succsessful {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , l, u ) = (true) >
 	 , 
 	 Conj <c (llen)(v) ==((llen)(l) + (2))
 	 , 
 	 Conj <c (nth)( , l, a1 ) ==(pen)(v)
 	 , (nth)( , l, a1 ) ==(last)(v) >c  >c  >c  }}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 let _lbv16 = apply goal  (, a1 ), a11 ), l )
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 Finding Already seen tree for apply goal  (, _lbv2 ), a2 ), _lbv1 )
 Typechecking apply goal  (, apply last  (, apply init  (, a3 ) ) ), a2 ), apply init  (, a3 ) )
 Against {var_v19:Ty_list int | true}
 Typechecking the Term apply goal  (, _lbv2 ), a2 ), _lbv1 )
 Against {var_v19:Ty_list int | true}
 Argument _lbv2 :: {v:int | (last)(_lbv1) ==(v)} | (last)(_lbv1) ==(_lbv2)
 Argument a2 :: {var_v21:int | true} | true
 Argument _lbv1 :: {v:Ty_list int | (llen)(v) ==((llen)(v) -- (1))} | (llen)(_lbv1) ==((llen)(_lbv1) -- (1))
 AppType Type {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , _lbv1, u ) = (true) >
 	 , 
 	 Conj <c (llen)(v) ==((llen)(_lbv1) + (2))
 	 , 
 	 Conj <c (nth)( , _lbv1, _lbv2 ) ==(pen)(v)
 	 , (nth)( , _lbv1, a2 ) ==(last)(v) >c  >c  >c  }}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
  Show *************** TypeChecking Succsessful {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , _lbv1, u ) = (true) >
 	 , 
 	 Conj <c (llen)(v) ==((llen)(_lbv1) + (2))
 	 , 
 	 Conj <c (nth)( , _lbv1, _lbv2 ) ==(pen)(v)
 	 , (nth)( , _lbv1, a2 ) ==(last)(v) >c  >c  >c  }}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 let _lbv17 = apply goal  (, _lbv2 ), a2 ), _lbv1 )
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 Finding Already seen tree for apply goal  (, n ), a1 ), l )
 Typechecking apply goal  (, n ), a1 ), l )
 Against {var_v19:Ty_list int | true}
 Typechecking the Term apply goal  (, n ), a1 ), l )
 Against {var_v19:Ty_list int | true}
 Argument n :: {var_v18:int | true} | true
 Argument a1 :: {var_v20:int | true} | true
 Argument l :: {var_v16:Ty_list int | true} | true
 AppType Type {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , l, u ) = (true) >
 	 , 
 	 Conj <c (llen)(v) ==((llen)(l) + (2))
 	 , 
 	 Conj <c (nth)( , l, n ) ==(pen)(v)
 	 , (nth)( , l, a1 ) ==(last)(v) >c  >c  >c  }}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
  Show *************** TypeChecking Succsessful {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , l, u ) = (true) >
 	 , 
 	 Conj <c (llen)(v) ==((llen)(l) + (2))
 	 , 
 	 Conj <c (nth)( , l, n ) ==(pen)(v)
 	 , (nth)( , l, a1 ) ==(last)(v) >c  >c  >c  }}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 let _lbv18 = apply goal  (, n ), a1 ), l )
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 Finding Already seen tree for apply goal  (, ep ), _lbv0 ), _lbv1 )
 Typechecking apply goal  (, ep ), apply last  (, a3 ) ), apply init  (, a3 ) )
 Against {var_v19:Ty_list int | true}
 Typechecking the Term apply goal  (, ep ), _lbv0 ), _lbv1 )
 Against {var_v19:Ty_list int | true}
 Argument ep :: {var_v0:int | true} | true
 Argument _lbv0 :: {v:int | (last)(a3) ==(v)} | (last)(a3) ==(_lbv0)
 Argument _lbv1 :: {v:Ty_list int | (llen)(v) ==((llen)(v) -- (1))} | (llen)(_lbv1) ==((llen)(_lbv1) -- (1))
 AppType Type {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , _lbv1, u ) = (true) >
 	 , 
 	 Conj <c (llen)(v) ==((llen)(_lbv1) + (2))
 	 , 
 	 Conj <c (nth)( , _lbv1, ep ) ==(pen)(v)
 	 , (nth)( , _lbv1, _lbv0 ) ==(last)(v) >c  >c  >c  }}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
  Show *************** TypeChecking Succsessful {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , _lbv1, u ) = (true) >
 	 , 
 	 Conj <c (llen)(v) ==((llen)(_lbv1) + (2))
 	 , 
 	 Conj <c (nth)( , _lbv1, ep ) ==(pen)(v)
 	 , (nth)( , _lbv1, _lbv0 ) ==(last)(v) >c  >c  >c  }}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 let _lbv19 = apply goal  (, ep ), _lbv0 ), _lbv1 )
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 Finding Already seen tree for apply goal  (, a1 ), _lbv0 ), a3 )
 Typechecking apply goal  (, a1 ), apply last  (, a3 ) ), a3 )
 Against {var_v19:Ty_list int | true}
 Typechecking the Term apply goal  (, a1 ), _lbv0 ), a3 )
 Against {var_v19:Ty_list int | true}
 Argument a1 :: {var_v20:int | true} | true
 Argument _lbv0 :: {v:int | (last)(a3) ==(v)} | (last)(a3) ==(_lbv0)
 Argument a3 :: {v1:Ty_list int | 
 	 Conj <c Negation (a11) > (llen)(v1)
 	 , Negation (a2) > (llen)(v1) >c } | 
 	 Conj <c Negation (a11) > (llen)(a3)
 	 , Negation (a2) > (llen)(a3) >c 
 AppType Type {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , a3, u ) = (true) >
 	 , 
 	 Conj <c (llen)(v) ==((llen)(a3) + (2))
 	 , 
 	 Conj <c (nth)( , a3, a1 ) ==(pen)(v)
 	 , (nth)( , a3, _lbv0 ) ==(last)(v) >c  >c  >c  }}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
  Show *************** TypeChecking Succsessful {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , a3, u ) = (true) >
 	 , 
 	 Conj <c (llen)(v) ==((llen)(a3) + (2))
 	 , 
 	 Conj <c (nth)( , a3, a1 ) ==(pen)(v)
 	 , (nth)( , a3, _lbv0 ) ==(last)(v) >c  >c  >c  }}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 let _lbv20 = apply goal  (, a1 ), _lbv0 ), a3 )
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 Finding Already seen tree for apply goal  (, _lbv2 ), n ), a3 )
 Typechecking apply goal  (, apply last  (, apply init  (, a3 ) ) ), n ), a3 )
 Against {var_v19:Ty_list int | true}
 Typechecking the Term apply goal  (, _lbv2 ), n ), a3 )
 Against {var_v19:Ty_list int | true}
 Argument _lbv2 :: {v:int | (last)(_lbv1) ==(v)} | (last)(_lbv1) ==(_lbv2)
 Argument n :: {var_v18:int | true} | true
 Argument a3 :: {v1:Ty_list int | 
 	 Conj <c Negation (a11) > (llen)(v1)
 	 , Negation (a2) > (llen)(v1) >c } | 
 	 Conj <c Negation (a11) > (llen)(a3)
 	 , Negation (a2) > (llen)(a3) >c 
 AppType Type {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , a3, u ) = (true) >
 	 , 
 	 Conj <c (llen)(v) ==((llen)(a3) + (2))
 	 , 
 	 Conj <c (nth)( , a3, _lbv2 ) ==(pen)(v)
 	 , (nth)( , a3, n ) ==(last)(v) >c  >c  >c  }}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
  Show *************** TypeChecking Succsessful {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , a3, u ) = (true) >
 	 , 
 	 Conj <c (llen)(v) ==((llen)(a3) + (2))
 	 , 
 	 Conj <c (nth)( , a3, _lbv2 ) ==(pen)(v)
 	 , (nth)( , a3, n ) ==(last)(v) >c  >c  >c  }}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 let _lbv21 = apply goal  (, _lbv2 ), n ), a3 )
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 Finding Already seen tree for apply goal  (, ep ), a2 ), l )
 Typechecking apply goal  (, ep ), a2 ), l )
 Against {var_v19:Ty_list int | true}
 Typechecking the Term apply goal  (, ep ), a2 ), l )
 Against {var_v19:Ty_list int | true}
 Argument ep :: {var_v0:int | true} | true
 Argument a2 :: {var_v21:int | true} | true
 Argument l :: {var_v16:Ty_list int | true} | true
 AppType Type {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , l, u ) = (true) >
 	 , 
 	 Conj <c (llen)(v) ==((llen)(l) + (2))
 	 , 
 	 Conj <c (nth)( , l, ep ) ==(pen)(v)
 	 , (nth)( , l, a2 ) ==(last)(v) >c  >c  >c  }}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
  Show *************** TypeChecking Succsessful {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , l, u ) = (true) >
 	 , 
 	 Conj <c (llen)(v) ==((llen)(l) + (2))
 	 , 
 	 Conj <c (nth)( , l, ep ) ==(pen)(v)
 	 , (nth)( , l, a2 ) ==(last)(v) >c  >c  >c  }}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 let _lbv22 = apply goal  (, ep ), a2 ), l )
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  ###################################################
  The Choice of Function goal Was Successfull for {var_v19:Ty_list int | true} Continuing for completeness
  ###################################################
 >>>>>>>>>>>>>>>>>>> 2th Args option for take : a3
 >>>>>>>>>>>>>>>>>>> 2th Args option for take : apply init  (, a3 )
 >>>>>>>>>>>>>>>>>>> 2th Args option for take : apply goal  (, ep ), a2 ), l )
 >>>>>>>>>>>>>>>>>>> 2th Args option for take : apply goal  (, apply last  (, apply init  (, a3 ) ) ), n ), a3 )
 >>>>>>>>>>>>>>>>>>> 2th Args option for take : apply goal  (, a1 ), apply last  (, a3 ) ), a3 )
 >>>>>>>>>>>>>>>>>>> 2th Args option for take : apply goal  (, ep ), apply last  (, a3 ) ), apply init  (, a3 ) )
 >>>>>>>>>>>>>>>>>>> 2th Args option for take : apply goal  (, n ), a1 ), l )
 >>>>>>>>>>>>>>>>>>> 2th Args option for take : apply goal  (, apply last  (, apply init  (, a3 ) ) ), a2 ), apply init  (, a3 ) )
 >>>>>>>>>>>>>>>>>>> 2th Args option for take : apply goal  (, a1 ), a11 ), l )
 >>>>>>>>>>>>>>>>>>> 2th Args option for take : apply goal  (, n ), apply last  (, apply init  (, a3 ) ) ), l )
 >>>>>>>>>>>>>>>>>>> 2th Args option for take : apply goal  (, a11 ), a2 ), apply init  (, a3 ) )
 >>>>>>>>>>>>>>>>>>> 2th Args option for take : apply goal  (, ep ), a11 ), apply init  (, a3 ) )
 >>>>>>>>>>>>>>>>>>> 2th Args option for take : apply goal  (, ep ), apply last  (, apply init  (, a3 ) ) ), l )
 >>>>>>>>>>>>>>>>>>> 2th Args option for take : apply goal  (, a2 ), n ), l )
 >>>>>>>>>>>>>>>>>>> 2th Args option for take : apply goal  (, a2 ), a2 ), a3 )
 >>>>>>>>>>>>>>>>>>> 2th Args option for take : apply goal  (, apply last  (, a3 ) ), apply last  (, a3 ) ), a3 )
 >>>>>>>>>>>>>>>>>>> 2th Args option for take : apply goal  (, apply last  (, apply init  (, a3 ) ) ), apply last  (, apply init  (, a3 ) ) ), apply init  (, a3 ) )
 >>>>>>>>>>>>>>>>>>> 2th Args option for take : apply goal  (, a1 ), apply last  (, apply init  (, a3 ) ) ), a3 )
 >>>>>>>>>>>>>>>>>>> 2th Args option for take : apply goal  (, apply last  (, apply init  (, a3 ) ) ), apply last  (, apply init  (, a3 ) ) ), l )
 >>>>>>>>>>>>>>>>>>> 2th Args option for take : apply goal  (, a1 ), ep ), a3 )
 >>>>>>>>>>>>>>>>>>> 2th Args option for take : apply goal  (, apply last  (, a3 ) ), apply last  (, apply init  (, a3 ) ) ), apply init  (, a3 ) )
 >>>>>>>>>>>>>>>>>>> 2th Args option for take : apply goal  (, n ), apply last  (, apply init  (, a3 ) ) ), a3 )
  DEPTH vs MAX  0 vs 2
 ##################################################################################
  *************** Successfully Synthesized Args ei Forall i 
 1 th Argument Options for take
 EI a2
 EI apply last  (, a3 )
 EI a11
 EI a1
 EI ep
 EI apply last  (, apply init  (, a3 ) )
 EI apply last  (, a3 )
 2 th Argument Options for take
 EI a3
 EI apply init  (, a3 )
 EI apply goal  (, ep ), a2 ), l )
 EI apply goal  (, apply last  (, apply init  (, a3 ) ) ), n ), a3 )
 EI apply goal  (, a1 ), apply last  (, a3 ) ), a3 )
 EI apply goal  (, ep ), apply last  (, a3 ) ), apply init  (, a3 ) )
 EI apply goal  (, n ), a1 ), l )
 EI apply goal  (, apply last  (, apply init  (, a3 ) ) ), a2 ), apply init  (, a3 ) )
 EI apply goal  (, a1 ), a11 ), l )
 EI apply goal  (, n ), apply last  (, apply init  (, a3 ) ) ), l )
 EI apply goal  (, a11 ), a2 ), apply init  (, a3 ) )
 EI apply goal  (, ep ), a11 ), apply init  (, a3 ) )
 EI apply goal  (, ep ), apply last  (, apply init  (, a3 ) ) ), l )
 EI apply goal  (, a2 ), n ), l )
 EI apply goal  (, a2 ), a2 ), a3 )
 EI apply goal  (, apply last  (, a3 ) ), apply last  (, a3 ) ), a3 )
 EI apply goal  (, apply last  (, apply init  (, a3 ) ) ), apply last  (, apply init  (, a3 ) ) ), apply init  (, a3 ) )
 EI apply goal  (, a1 ), apply last  (, apply init  (, a3 ) ) ), a3 )
 EI apply goal  (, apply last  (, apply init  (, a3 ) ) ), apply last  (, apply init  (, a3 ) ) ), l )
 EI apply goal  (, a1 ), ep ), a3 )
 EI apply goal  (, apply last  (, a3 ) ), apply last  (, apply init  (, a3 ) ) ), apply init  (, a3 ) )
 EI apply goal  (, n ), apply last  (, apply init  (, a3 ) ) ), a3 )
 # of Possible Argument Options for take 154
 # of Possible Argument Options for take 20
 Possible Arg Options 
 EI apply last  (, a3 )
 EI apply goal  (, apply last  (, a3 ) ), apply last  (, a3 ) ), a3 )
 Possible Arg Options 
 EI apply last  (, a3 )
 EI apply goal  (, apply last  (, apply init  (, a3 ) ) ), apply last  (, apply init  (, a3 ) ) ), l )
 Possible Arg Options 
 EI apply last  (, a3 )
 EI apply goal  (, a2 ), a2 ), a3 )
 Possible Arg Options 
 EI apply last  (, a3 )
 EI apply goal  (, n ), apply last  (, apply init  (, a3 ) ) ), l )
 Possible Arg Options 
 EI apply last  (, apply init  (, a3 ) )
 EI apply goal  (, a2 ), a2 ), a3 )
 Possible Arg Options 
 EI apply last  (, a3 )
 EI apply goal  (, ep ), a11 ), apply init  (, a3 ) )
 Possible Arg Options 
 EI a1
 EI apply goal  (, apply last  (, apply init  (, a3 ) ) ), apply last  (, apply init  (, a3 ) ) ), l )
 Possible Arg Options 
 EI a11
 EI a3
 Possible Arg Options 
 EI ep
 EI apply goal  (, apply last  (, apply init  (, a3 ) ) ), n ), a3 )
 Possible Arg Options 
 EI apply last  (, a3 )
 EI apply goal  (, apply last  (, a3 ) ), apply last  (, apply init  (, a3 ) ) ), apply init  (, a3 ) )
 Possible Arg Options 
 EI a2
 EI a3
 Possible Arg Options 
 EI a1
 EI apply goal  (, ep ), a2 ), l )
 Possible Arg Options 
 EI apply last  (, a3 )
 EI apply goal  (, a2 ), n ), l )
 Possible Arg Options 
 EI a11
 EI apply goal  (, a11 ), a2 ), apply init  (, a3 ) )
 Possible Arg Options 
 EI a11
 EI apply goal  (, n ), apply last  (, apply init  (, a3 ) ) ), l )
 Possible Arg Options 
 EI ep
 EI apply init  (, a3 )
 Possible Arg Options 
 EI apply last  (, apply init  (, a3 ) )
 EI apply goal  (, a2 ), n ), l )
 Possible Arg Options 
 EI apply last  (, apply init  (, a3 ) )
 EI apply goal  (, a11 ), a2 ), apply init  (, a3 ) )
 Possible Arg Options 
 EI a2
 EI apply goal  (, a1 ), apply last  (, apply init  (, a3 ) ) ), a3 )
 Possible Arg Options 
 EI ep
 EI apply goal  (, n ), apply last  (, apply init  (, a3 ) ) ), l )
 Show f (ei, e2, ....en) Case
 Finding Already seen tree for apply take  (, _lbv0 ), _lbv9 )
 Typechecking apply take  (, apply last  (, a3 ) ), apply goal  (, apply last  (, a3 ) ), apply last  (, a3 ) ), a3 ) )
 Against {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , a3, u ) = (true) >
 	 , 
 	 Conj <c (llen)(v) ==((llen)(a3) + (2))
 	 , 
 	 Conj <c (nth)( , a3, a1 ) ==(pen)(v)
 	 , (nth)( , a3, a2 ) ==(last)(v) >c  >c  >c  }}
 Typechecking the Term apply take  (, _lbv0 ), _lbv9 )
 Against {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , a3, u ) = (true) >
 	 , 
 	 Conj <c (llen)(v) ==((llen)(a3) + (2))
 	 , 
 	 Conj <c (nth)( , a3, a1 ) ==(pen)(v)
 	 , (nth)( , a3, a2 ) ==(last)(v) >c  >c  >c  }}
 Argument _lbv0 :: {v:int | (last)(a3) ==(v)} | (last)(a3) ==(_lbv0)
 Argument _lbv9 :: {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , a3, u ) = (true) >
 	 , 
 	 Conj <c (llen)(v) ==((llen)(a3) + (2))
 	 , 
 	 Conj <c (nth)( , a3, _lbv0 ) ==(pen)(v)
 	 , (nth)( , a3, _lbv0 ) ==(last)(v) >c  >c  >c  }} | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , _lbv9, u ) = (true)
 	 (lmem)( , a3, u ) = (true) >
 	 , 
 	 Conj <c (llen)(_lbv9) ==((llen)(a3) + (2))
 	 , 
 	 Conj <c (nth)( , a3, _lbv0 ) ==(pen)(_lbv9)
 	 , (nth)( , a3, _lbv0 ) ==(last)(_lbv9) >c  >c  >c  }
 AppType Type {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c (llen)(v) ==(_lbv0)
 	 , 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , _lbv9, u ) = (true) > >c  }}                                                                                                     
# of Final Z3 expressions 50
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
  Show *************** TypeChecking Succsessful {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c (llen)(v) ==(_lbv0)
 	 , 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , _lbv9, u ) = (true) > >c  }}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 let _lbv23 = apply take  (, _lbv0 ), _lbv9 )
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 Finding Already seen tree for apply take  (, _lbv0 ), _lbv6 )
 Typechecking apply take  (, apply last  (, a3 ) ), apply goal  (, apply last  (, apply init  (, a3 ) ) ), apply last  (, apply init  (, a3 ) ) ), l ) )
 Against {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , a3, u ) = (true) >
 	 , 
 	 Conj <c (llen)(v) ==((llen)(a3) + (2))
 	 , 
 	 Conj <c (nth)( , a3, a1 ) ==(pen)(v)
 	 , (nth)( , a3, a2 ) ==(last)(v) >c  >c  >c  }}
 Typechecking the Term apply take  (, _lbv0 ), _lbv6 )
 Against {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , a3, u ) = (true) >
 	 , 
 	 Conj <c (llen)(v) ==((llen)(a3) + (2))
 	 , 
 	 Conj <c (nth)( , a3, a1 ) ==(pen)(v)
 	 , (nth)( , a3, a2 ) ==(last)(v) >c  >c  >c  }}
 Argument _lbv0 :: {v:int | (last)(a3) ==(v)} | (last)(a3) ==(_lbv0)
 Argument _lbv6 :: {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , l, u ) = (true) >
 	 , 
 	 Conj <c (llen)(v) ==((llen)(l) + (2))
 	 , 
 	 Conj <c (nth)( , l, _lbv2 ) ==(pen)(v)
 	 , (nth)( , l, _lbv2 ) ==(last)(v) >c  >c  >c  }} | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , _lbv6, u ) = (true)
 	 (lmem)( , l, u ) = (true) >
 	 , 
 	 Conj <c (llen)(_lbv6) ==((llen)(l) + (2))
 	 , 
 	 Conj <c (nth)( , l, _lbv2 ) ==(pen)(_lbv6)
 	 , (nth)( , l, _lbv2 ) ==(last)(_lbv6) >c  >c  >c  }
 AppType Type {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c (llen)(v) ==(_lbv0)
 	 , 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , _lbv6, u ) = (true) > >c  }}                                                                                                         
# of Final Z3 expressions 52
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
  Show *************** TypeChecking Succsessful {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c (llen)(v) ==(_lbv0)
 	 , 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , _lbv6, u ) = (true) > >c  }}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 let _lbv24 = apply take  (, _lbv0 ), _lbv6 )
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 Finding Already seen tree for apply take  (, _lbv0 ), _lbv10 )
 Typechecking apply take  (, apply last  (, a3 ) ), apply goal  (, a2 ), a2 ), a3 ) )
 Against {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , a3, u ) = (true) >
 	 , 
 	 Conj <c (llen)(v) ==((llen)(a3) + (2))
 	 , 
 	 Conj <c (nth)( , a3, a1 ) ==(pen)(v)
 	 , (nth)( , a3, a2 ) ==(last)(v) >c  >c  >c  }}
 Typechecking the Term apply take  (, _lbv0 ), _lbv10 )
 Against {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , a3, u ) = (true) >
 	 , 
 	 Conj <c (llen)(v) ==((llen)(a3) + (2))
 	 , 
 	 Conj <c (nth)( , a3, a1 ) ==(pen)(v)
 	 , (nth)( , a3, a2 ) ==(last)(v) >c  >c  >c  }}
 Argument _lbv0 :: {v:int | (last)(a3) ==(v)} | (last)(a3) ==(_lbv0)
 Argument _lbv10 :: {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , a3, u ) = (true) >
 	 , 
 	 Conj <c (llen)(v) ==((llen)(a3) + (2))
 	 , 
 	 Conj <c (nth)( , a3, a2 ) ==(pen)(v)
 	 , (nth)( , a3, a2 ) ==(last)(v) >c  >c  >c  }} | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , _lbv10, u ) = (true)
 	 (lmem)( , a3, u ) = (true) >
 	 , 
 	 Conj <c (llen)(_lbv10) ==((llen)(a3) + (2))
 	 , 
 	 Conj <c (nth)( , a3, a2 ) ==(pen)(_lbv10)
 	 , (nth)( , a3, a2 ) ==(last)(_lbv10) >c  >c  >c  }
 AppType Type {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c (llen)(v) ==(_lbv0)
 	 , 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , _lbv10, u ) = (true) > >c  }}                                                                                                             
# of Final Z3 expressions 54
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
  Show *************** TypeChecking Succsessful {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c (llen)(v) ==(_lbv0)
 	 , 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , _lbv10, u ) = (true) > >c  }}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 let _lbv25 = apply take  (, _lbv0 ), _lbv10 )
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 Finding Already seen tree for apply take  (, _lbv0 ), _lbv15 )
 Typechecking apply take  (, apply last  (, a3 ) ), apply goal  (, n ), apply last  (, apply init  (, a3 ) ) ), l ) )
 Against {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , a3, u ) = (true) >
 	 , 
 	 Conj <c (llen)(v) ==((llen)(a3) + (2))
 	 , 
 	 Conj <c (nth)( , a3, a1 ) ==(pen)(v)
 	 , (nth)( , a3, a2 ) ==(last)(v) >c  >c  >c  }}
 Typechecking the Term apply take  (, _lbv0 ), _lbv15 )
 Against {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , a3, u ) = (true) >
 	 , 
 	 Conj <c (llen)(v) ==((llen)(a3) + (2))
 	 , 
 	 Conj <c (nth)( , a3, a1 ) ==(pen)(v)
 	 , (nth)( , a3, a2 ) ==(last)(v) >c  >c  >c  }}
 Argument _lbv0 :: {v:int | (last)(a3) ==(v)} | (last)(a3) ==(_lbv0)
 Argument _lbv15 :: {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , l, u ) = (true) >
 	 , 
 	 Conj <c (llen)(v) ==((llen)(l) + (2))
 	 , 
 	 Conj <c (nth)( , l, n ) ==(pen)(v)
 	 , (nth)( , l, _lbv2 ) ==(last)(v) >c  >c  >c  }} | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , _lbv15, u ) = (true)
 	 (lmem)( , l, u ) = (true) >
 	 , 
 	 Conj <c (llen)(_lbv15) ==((llen)(l) + (2))
 	 , 
 	 Conj <c (nth)( , l, n ) ==(pen)(_lbv15)
 	 , (nth)( , l, _lbv2 ) ==(last)(_lbv15) >c  >c  >c  }
 AppType Type {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c (llen)(v) ==(_lbv0)
 	 , 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , _lbv15, u ) = (true) > >c  }}                                                                                                                 
# of Final Z3 expressions 56
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
  Show *************** TypeChecking Succsessful {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c (llen)(v) ==(_lbv0)
 	 , 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , _lbv15, u ) = (true) > >c  }}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 let _lbv26 = apply take  (, _lbv0 ), _lbv15 )
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 Finding Already seen tree for apply take  (, _lbv2 ), _lbv10 )
 Typechecking apply take  (, apply last  (, apply init  (, a3 ) ) ), apply goal  (, a2 ), a2 ), a3 ) )
 Against {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , a3, u ) = (true) >
 	 , 
 	 Conj <c (llen)(v) ==((llen)(a3) + (2))
 	 , 
 	 Conj <c (nth)( , a3, a1 ) ==(pen)(v)
 	 , (nth)( , a3, a2 ) ==(last)(v) >c  >c  >c  }}
 Typechecking the Term apply take  (, _lbv2 ), _lbv10 )
 Against {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , a3, u ) = (true) >
 	 , 
 	 Conj <c (llen)(v) ==((llen)(a3) + (2))
 	 , 
 	 Conj <c (nth)( , a3, a1 ) ==(pen)(v)
 	 , (nth)( , a3, a2 ) ==(last)(v) >c  >c  >c  }}
 Argument _lbv2 :: {v:int | (last)(_lbv1) ==(v)} | (last)(_lbv1) ==(_lbv2)
 Argument _lbv10 :: {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , a3, u ) = (true) >
 	 , 
 	 Conj <c (llen)(v) ==((llen)(a3) + (2))
 	 , 
 	 Conj <c (nth)( , a3, a2 ) ==(pen)(v)
 	 , (nth)( , a3, a2 ) ==(last)(v) >c  >c  >c  }} | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , _lbv10, u ) = (true)
 	 (lmem)( , a3, u ) = (true) >
 	 , 
 	 Conj <c (llen)(_lbv10) ==((llen)(a3) + (2))
 	 , 
 	 Conj <c (nth)( , a3, a2 ) ==(pen)(_lbv10)
 	 , (nth)( , a3, a2 ) ==(last)(_lbv10) >c  >c  >c  }
 AppType Type {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c (llen)(v) ==(_lbv2)
 	 , 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , _lbv10, u ) = (true) > >c  }}                                                                                                                     
# of Final Z3 expressions 58
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
  Show *************** TypeChecking Succsessful {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c (llen)(v) ==(_lbv2)
 	 , 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , _lbv10, u ) = (true) > >c  }}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 let _lbv27 = apply take  (, _lbv2 ), _lbv10 )
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 Finding Already seen tree for apply take  (, _lbv0 ), _lbv13 )
 Typechecking apply take  (, apply last  (, a3 ) ), apply goal  (, ep ), a11 ), apply init  (, a3 ) ) )
 Against {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , a3, u ) = (true) >
 	 , 
 	 Conj <c (llen)(v) ==((llen)(a3) + (2))
 	 , 
 	 Conj <c (nth)( , a3, a1 ) ==(pen)(v)
 	 , (nth)( , a3, a2 ) ==(last)(v) >c  >c  >c  }}
 Typechecking the Term apply take  (, _lbv0 ), _lbv13 )
 Against {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , a3, u ) = (true) >
 	 , 
 	 Conj <c (llen)(v) ==((llen)(a3) + (2))
 	 , 
 	 Conj <c (nth)( , a3, a1 ) ==(pen)(v)
 	 , (nth)( , a3, a2 ) ==(last)(v) >c  >c  >c  }}
 Argument _lbv0 :: {v:int | (last)(a3) ==(v)} | (last)(a3) ==(_lbv0)
 Argument _lbv13 :: {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , _lbv1, u ) = (true) >
 	 , 
 	 Conj <c (llen)(v) ==((llen)(_lbv1) + (2))
 	 , 
 	 Conj <c (nth)( , _lbv1, ep ) ==(pen)(v)
 	 , (nth)( , _lbv1, ep ) ==(last)(v) >c  >c  >c  }} | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , _lbv13, u ) = (true)
 	 (lmem)( , _lbv1, u ) = (true) >
 	 , 
 	 Conj <c (llen)(_lbv13) ==((llen)(_lbv1) + (2))
 	 , 
 	 Conj <c (nth)( , _lbv1, ep ) ==(pen)(_lbv13)
 	 , (nth)( , _lbv1, ep ) ==(last)(_lbv13) >c  >c  >c  }
 AppType Type {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c (llen)(v) ==(_lbv0)
 	 , 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , _lbv13, u ) = (true) > >c  }}                                                                                                                         
# of Final Z3 expressions 60
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
  Show *************** TypeChecking Succsessful {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c (llen)(v) ==(_lbv0)
 	 , 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , _lbv13, u ) = (true) > >c  }}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 let _lbv28 = apply take  (, _lbv0 ), _lbv13 )
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 Finding Already seen tree for apply take  (, a1 ), _lbv6 )
 Typechecking apply take  (, a1 ), apply goal  (, apply last  (, apply init  (, a3 ) ) ), apply last  (, apply init  (, a3 ) ) ), l ) )
 Against {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , a3, u ) = (true) >
 	 , 
 	 Conj <c (llen)(v) ==((llen)(a3) + (2))
 	 , 
 	 Conj <c (nth)( , a3, a1 ) ==(pen)(v)
 	 , (nth)( , a3, a2 ) ==(last)(v) >c  >c  >c  }}
 Typechecking the Term apply take  (, a1 ), _lbv6 )
 Against {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , a3, u ) = (true) >
 	 , 
 	 Conj <c (llen)(v) ==((llen)(a3) + (2))
 	 , 
 	 Conj <c (nth)( , a3, a1 ) ==(pen)(v)
 	 , (nth)( , a3, a2 ) ==(last)(v) >c  >c  >c  }}
 Argument a1 :: {var_v20:int | true} | true
 Argument _lbv6 :: {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , l, u ) = (true) >
 	 , 
 	 Conj <c (llen)(v) ==((llen)(l) + (2))
 	 , 
 	 Conj <c (nth)( , l, _lbv2 ) ==(pen)(v)
 	 , (nth)( , l, _lbv2 ) ==(last)(v) >c  >c  >c  }} | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , _lbv6, u ) = (true)
 	 (lmem)( , l, u ) = (true) >
 	 , 
 	 Conj <c (llen)(_lbv6) ==((llen)(l) + (2))
 	 , 
 	 Conj <c (nth)( , l, _lbv2 ) ==(pen)(_lbv6)
 	 , (nth)( , l, _lbv2 ) ==(last)(_lbv6) >c  >c  >c  }
 AppType Type {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c (llen)(v) ==(a1)
 	 , 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , _lbv6, u ) = (true) > >c  }}                                                                                                                             
# of Final Z3 expressions 62
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
  Show *************** TypeChecking Succsessful {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c (llen)(v) ==(a1)
 	 , 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , _lbv6, u ) = (true) > >c  }}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 let _lbv29 = apply take  (, a1 ), _lbv6 )
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 Finding Already seen tree for apply take  (, a11 ), a3 )
 Typechecking apply take  (, a11 ), a3 )
 Against {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , a3, u ) = (true) >
 	 , 
 	 Conj <c (llen)(v) ==((llen)(a3) + (2))
 	 , 
 	 Conj <c (nth)( , a3, a1 ) ==(pen)(v)
 	 , (nth)( , a3, a2 ) ==(last)(v) >c  >c  >c  }}
 Typechecking the Term apply take  (, a11 ), a3 )
 Against {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , a3, u ) = (true) >
 	 , 
 	 Conj <c (llen)(v) ==((llen)(a3) + (2))
 	 , 
 	 Conj <c (nth)( , a3, a1 ) ==(pen)(v)
 	 , (nth)( , a3, a2 ) ==(last)(v) >c  >c  >c  }}
 Argument a11 :: {var_v20:int | 
 	 Conj <c true
 	 , a1 > var_v20 >c } | 
 	 Conj <c true
 	 , a1 > a11 >c 
 Argument a3 :: {v1:Ty_list int | 
 	 Conj <c Negation (a11) > (llen)(v1)
 	 , Negation (a2) > (llen)(v1) >c } | 
 	 Conj <c Negation (a11) > (llen)(a3)
 	 , Negation (a2) > (llen)(a3) >c 
 AppType Type {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c (llen)(v) ==(a11)
 	 , 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , a3, u ) = (true) > >c  }}                                                                                                                                  
# of Final Z3 expressions 62
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
  Show *************** TypeChecking Succsessful {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c (llen)(v) ==(a11)
 	 , 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , a3, u ) = (true) > >c  }}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 let _lbv30 = apply take  (, a11 ), a3 )
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 Finding Already seen tree for apply take  (, ep ), _lbv21 )
 Typechecking apply take  (, ep ), apply goal  (, apply last  (, apply init  (, a3 ) ) ), n ), a3 ) )
 Against {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , a3, u ) = (true) >
 	 , 
 	 Conj <c (llen)(v) ==((llen)(a3) + (2))
 	 , 
 	 Conj <c (nth)( , a3, a1 ) ==(pen)(v)
 	 , (nth)( , a3, a2 ) ==(last)(v) >c  >c  >c  }}
 Typechecking the Term apply take  (, ep ), _lbv21 )
 Against {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , a3, u ) = (true) >
 	 , 
 	 Conj <c (llen)(v) ==((llen)(a3) + (2))
 	 , 
 	 Conj <c (nth)( , a3, a1 ) ==(pen)(v)
 	 , (nth)( , a3, a2 ) ==(last)(v) >c  >c  >c  }}
 Argument ep :: {var_v0:int | true} | true
 Argument _lbv21 :: {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , a3, u ) = (true) >
 	 , 
 	 Conj <c (llen)(v) ==((llen)(a3) + (2))
 	 , 
 	 Conj <c (nth)( , a3, _lbv2 ) ==(pen)(v)
 	 , (nth)( , a3, n ) ==(last)(v) >c  >c  >c  }} | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , _lbv21, u ) = (true)
 	 (lmem)( , a3, u ) = (true) >
 	 , 
 	 Conj <c (llen)(_lbv21) ==((llen)(a3) + (2))
 	 , 
 	 Conj <c (nth)( , a3, _lbv2 ) ==(pen)(_lbv21)
 	 , (nth)( , a3, n ) ==(last)(_lbv21) >c  >c  >c  }
 AppType Type {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c (llen)(v) ==(ep)
 	 , 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , _lbv21, u ) = (true) > >c  }}                                                                                                                                     
# of Final Z3 expressions 66
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
  Show *************** TypeChecking Succsessful {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c (llen)(v) ==(ep)
 	 , 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , _lbv21, u ) = (true) > >c  }}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 let _lbv31 = apply take  (, ep ), _lbv21 )
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 Finding Already seen tree for apply take  (, _lbv0 ), _lbv4 )
 Typechecking apply take  (, apply last  (, a3 ) ), apply goal  (, apply last  (, a3 ) ), apply last  (, apply init  (, a3 ) ) ), apply init  (, a3 ) ) )
 Against {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , a3, u ) = (true) >
 	 , 
 	 Conj <c (llen)(v) ==((llen)(a3) + (2))
 	 , 
 	 Conj <c (nth)( , a3, a1 ) ==(pen)(v)
 	 , (nth)( , a3, a2 ) ==(last)(v) >c  >c  >c  }}
 Typechecking the Term apply take  (, _lbv0 ), _lbv4 )
 Against {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , a3, u ) = (true) >
 	 , 
 	 Conj <c (llen)(v) ==((llen)(a3) + (2))
 	 , 
 	 Conj <c (nth)( , a3, a1 ) ==(pen)(v)
 	 , (nth)( , a3, a2 ) ==(last)(v) >c  >c  >c  }}
 Argument _lbv0 :: {v:int | (last)(a3) ==(v)} | (last)(a3) ==(_lbv0)
 Argument _lbv4 :: {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , _lbv1, u ) = (true) >
 	 , 
 	 Conj <c (llen)(v) ==((llen)(_lbv1) + (2))
 	 , 
 	 Conj <c (nth)( , _lbv1, _lbv0 ) ==(pen)(v)
 	 , (nth)( , _lbv1, _lbv2 ) ==(last)(v) >c  >c  >c  }} | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , _lbv4, u ) = (true)
 	 (lmem)( , _lbv1, u ) = (true) >
 	 , 
 	 Conj <c (llen)(_lbv4) ==((llen)(_lbv1) + (2))
 	 , 
 	 Conj <c (nth)( , _lbv1, _lbv0 ) ==(pen)(_lbv4)
 	 , (nth)( , _lbv1, _lbv2 ) ==(last)(_lbv4) >c  >c  >c  }
 AppType Type {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c (llen)(v) ==(_lbv0)
 	 , 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , _lbv4, u ) = (true) > >c  }}                                                                                                                                         
# of Final Z3 expressions 68
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
  Show *************** TypeChecking Succsessful {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c (llen)(v) ==(_lbv0)
 	 , 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , _lbv4, u ) = (true) > >c  }}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 let _lbv32 = apply take  (, _lbv0 ), _lbv4 )
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 Finding Already seen tree for apply take  (, a2 ), a3 )
 Typechecking apply take  (, a2 ), a3 )
 Against {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , a3, u ) = (true) >
 	 , 
 	 Conj <c (llen)(v) ==((llen)(a3) + (2))
 	 , 
 	 Conj <c (nth)( , a3, a1 ) ==(pen)(v)
 	 , (nth)( , a3, a2 ) ==(last)(v) >c  >c  >c  }}
 Typechecking the Term apply take  (, a2 ), a3 )
 Against {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , a3, u ) = (true) >
 	 , 
 	 Conj <c (llen)(v) ==((llen)(a3) + (2))
 	 , 
 	 Conj <c (nth)( , a3, a1 ) ==(pen)(v)
 	 , (nth)( , a3, a2 ) ==(last)(v) >c  >c  >c  }}
 Argument a2 :: {var_v21:int | true} | true
 Argument a3 :: {v1:Ty_list int | 
 	 Conj <c Negation (a11) > (llen)(v1)
 	 , Negation (a2) > (llen)(v1) >c } | 
 	 Conj <c Negation (a11) > (llen)(a3)
 	 , Negation (a2) > (llen)(a3) >c 
 AppType Type {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c (llen)(v) ==(a2)
 	 , 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , a3, u ) = (true) > >c  }}                                                                                                                                         
# of Final Z3 expressions 68
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
  Show *************** TypeChecking Succsessful {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c (llen)(v) ==(a2)
 	 , 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , a3, u ) = (true) > >c  }}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 let _lbv33 = apply take  (, a2 ), a3 )
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 Finding Already seen tree for apply take  (, a1 ), _lbv22 )
 Typechecking apply take  (, a1 ), apply goal  (, ep ), a2 ), l ) )
 Against {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , a3, u ) = (true) >
 	 , 
 	 Conj <c (llen)(v) ==((llen)(a3) + (2))
 	 , 
 	 Conj <c (nth)( , a3, a1 ) ==(pen)(v)
 	 , (nth)( , a3, a2 ) ==(last)(v) >c  >c  >c  }}
 Typechecking the Term apply take  (, a1 ), _lbv22 )
 Against {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , a3, u ) = (true) >
 	 , 
 	 Conj <c (llen)(v) ==((llen)(a3) + (2))
 	 , 
 	 Conj <c (nth)( , a3, a1 ) ==(pen)(v)
 	 , (nth)( , a3, a2 ) ==(last)(v) >c  >c  >c  }}
 Argument a1 :: {var_v20:int | true} | true
 Argument _lbv22 :: {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , l, u ) = (true) >
 	 , 
 	 Conj <c (llen)(v) ==((llen)(l) + (2))
 	 , 
 	 Conj <c (nth)( , l, ep ) ==(pen)(v)
 	 , (nth)( , l, a2 ) ==(last)(v) >c  >c  >c  }} | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , _lbv22, u ) = (true)
 	 (lmem)( , l, u ) = (true) >
 	 , 
 	 Conj <c (llen)(_lbv22) ==((llen)(l) + (2))
 	 , 
 	 Conj <c (nth)( , l, ep ) ==(pen)(_lbv22)
 	 , (nth)( , l, a2 ) ==(last)(_lbv22) >c  >c  >c  }
 AppType Type {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c (llen)(v) ==(a1)
 	 , 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , _lbv22, u ) = (true) > >c  }}                                                                                                                                                 
# of Final Z3 expressions 72
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
  Show *************** TypeChecking Succsessful {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c (llen)(v) ==(a1)
 	 , 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , _lbv22, u ) = (true) > >c  }}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 let _lbv34 = apply take  (, a1 ), _lbv22 )
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 Finding Already seen tree for apply take  (, _lbv0 ), _lbv11 )
 Typechecking apply take  (, apply last  (, a3 ) ), apply goal  (, a2 ), n ), l ) )
 Against {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , a3, u ) = (true) >
 	 , 
 	 Conj <c (llen)(v) ==((llen)(a3) + (2))
 	 , 
 	 Conj <c (nth)( , a3, a1 ) ==(pen)(v)
 	 , (nth)( , a3, a2 ) ==(last)(v) >c  >c  >c  }}
 Typechecking the Term apply take  (, _lbv0 ), _lbv11 )
 Against {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , a3, u ) = (true) >
 	 , 
 	 Conj <c (llen)(v) ==((llen)(a3) + (2))
 	 , 
 	 Conj <c (nth)( , a3, a1 ) ==(pen)(v)
 	 , (nth)( , a3, a2 ) ==(last)(v) >c  >c  >c  }}
 Argument _lbv0 :: {v:int | (last)(a3) ==(v)} | (last)(a3) ==(_lbv0)
 Argument _lbv11 :: {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , l, u ) = (true) >
 	 , 
 	 Conj <c (llen)(v) ==((llen)(l) + (2))
 	 , 
 	 Conj <c (nth)( , l, a2 ) ==(pen)(v)
 	 , (nth)( , l, n ) ==(last)(v) >c  >c  >c  }} | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , _lbv11, u ) = (true)
 	 (lmem)( , l, u ) = (true) >
 	 , 
 	 Conj <c (llen)(_lbv11) ==((llen)(l) + (2))
 	 , 
 	 Conj <c (nth)( , l, a2 ) ==(pen)(_lbv11)
 	 , (nth)( , l, n ) ==(last)(_lbv11) >c  >c  >c  }
 AppType Type {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c (llen)(v) ==(_lbv0)
 	 , 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , _lbv11, u ) = (true) > >c  }}                                                                                                                                                     
# of Final Z3 expressions 74
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
  Show *************** TypeChecking Succsessful {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c (llen)(v) ==(_lbv0)
 	 , 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , _lbv11, u ) = (true) > >c  }}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 let _lbv35 = apply take  (, _lbv0 ), _lbv11 )
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 Finding Already seen tree for apply take  (, a11 ), _lbv14 )
 Typechecking apply take  (, a11 ), apply goal  (, a11 ), a2 ), apply init  (, a3 ) ) )
 Against {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , a3, u ) = (true) >
 	 , 
 	 Conj <c (llen)(v) ==((llen)(a3) + (2))
 	 , 
 	 Conj <c (nth)( , a3, a1 ) ==(pen)(v)
 	 , (nth)( , a3, a2 ) ==(last)(v) >c  >c  >c  }}
 Typechecking the Term apply take  (, a11 ), _lbv14 )
 Against {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , a3, u ) = (true) >
 	 , 
 	 Conj <c (llen)(v) ==((llen)(a3) + (2))
 	 , 
 	 Conj <c (nth)( , a3, a1 ) ==(pen)(v)
 	 , (nth)( , a3, a2 ) ==(last)(v) >c  >c  >c  }}
 Argument a11 :: {var_v20:int | 
 	 Conj <c true
 	 , a1 > var_v20 >c } | 
 	 Conj <c true
 	 , a1 > a11 >c 
 Argument _lbv14 :: {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , _lbv1, u ) = (true) >
 	 , 
 	 Conj <c (llen)(v) ==((llen)(_lbv1) + (2))
 	 , 
 	 Conj <c (nth)( , _lbv1, a11 ) ==(pen)(v)
 	 , (nth)( , _lbv1, a2 ) ==(last)(v) >c  >c  >c  }} | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , _lbv14, u ) = (true)
 	 (lmem)( , _lbv1, u ) = (true) >
 	 , 
 	 Conj <c (llen)(_lbv14) ==((llen)(_lbv1) + (2))
 	 , 
 	 Conj <c (nth)( , _lbv1, a11 ) ==(pen)(_lbv14)
 	 , (nth)( , _lbv1, a2 ) ==(last)(_lbv14) >c  >c  >c  }
 AppType Type {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c (llen)(v) ==(a11)
 	 , 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , _lbv14, u ) = (true) > >c  }}                                                                                                                                                              
# of Final Z3 expressions 76
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
  Show *************** TypeChecking Succsessful {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c (llen)(v) ==(a11)
 	 , 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , _lbv14, u ) = (true) > >c  }}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 let _lbv36 = apply take  (, a11 ), _lbv14 )
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 Finding Already seen tree for apply take  (, a11 ), _lbv15 )
 Typechecking apply take  (, a11 ), apply goal  (, n ), apply last  (, apply init  (, a3 ) ) ), l ) )
 Against {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , a3, u ) = (true) >
 	 , 
 	 Conj <c (llen)(v) ==((llen)(a3) + (2))
 	 , 
 	 Conj <c (nth)( , a3, a1 ) ==(pen)(v)
 	 , (nth)( , a3, a2 ) ==(last)(v) >c  >c  >c  }}
 Typechecking the Term apply take  (, a11 ), _lbv15 )
 Against {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , a3, u ) = (true) >
 	 , 
 	 Conj <c (llen)(v) ==((llen)(a3) + (2))
 	 , 
 	 Conj <c (nth)( , a3, a1 ) ==(pen)(v)
 	 , (nth)( , a3, a2 ) ==(last)(v) >c  >c  >c  }}
 Argument a11 :: {var_v20:int | 
 	 Conj <c true
 	 , a1 > var_v20 >c } | 
 	 Conj <c true
 	 , a1 > a11 >c 
 Argument _lbv15 :: {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , l, u ) = (true) >
 	 , 
 	 Conj <c (llen)(v) ==((llen)(l) + (2))
 	 , 
 	 Conj <c (nth)( , l, n ) ==(pen)(v)
 	 , (nth)( , l, _lbv2 ) ==(last)(v) >c  >c  >c  }} | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , _lbv15, u ) = (true)
 	 (lmem)( , l, u ) = (true) >
 	 , 
 	 Conj <c (llen)(_lbv15) ==((llen)(l) + (2))
 	 , 
 	 Conj <c (nth)( , l, n ) ==(pen)(_lbv15)
 	 , (nth)( , l, _lbv2 ) ==(last)(_lbv15) >c  >c  >c  }
 AppType Type {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c (llen)(v) ==(a11)
 	 , 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , _lbv15, u ) = (true) > >c  }}                                                                                                                                                                  
# of Final Z3 expressions 78
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
  Show *************** TypeChecking Succsessful {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c (llen)(v) ==(a11)
 	 , 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , _lbv15, u ) = (true) > >c  }}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 let _lbv37 = apply take  (, a11 ), _lbv15 )
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 Finding Already seen tree for apply take  (, ep ), _lbv1 )
 Typechecking apply take  (, ep ), apply init  (, a3 ) )
 Against {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , a3, u ) = (true) >
 	 , 
 	 Conj <c (llen)(v) ==((llen)(a3) + (2))
 	 , 
 	 Conj <c (nth)( , a3, a1 ) ==(pen)(v)
 	 , (nth)( , a3, a2 ) ==(last)(v) >c  >c  >c  }}
 Typechecking the Term apply take  (, ep ), _lbv1 )
 Against {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , a3, u ) = (true) >
 	 , 
 	 Conj <c (llen)(v) ==((llen)(a3) + (2))
 	 , 
 	 Conj <c (nth)( , a3, a1 ) ==(pen)(v)
 	 , (nth)( , a3, a2 ) ==(last)(v) >c  >c  >c  }}
 Argument ep :: {var_v0:int | true} | true
 Argument _lbv1 :: {v:Ty_list int | (llen)(v) ==((llen)(v) -- (1))} | (llen)(_lbv1) ==((llen)(_lbv1) -- (1))
 AppType Type {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c (llen)(v) ==(ep)
 	 , 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , _lbv1, u ) = (true) > >c  }}                                                                                                                                                             
# of Final Z3 expressions 78
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
  Show *************** TypeChecking Succsessful {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c (llen)(v) ==(ep)
 	 , 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , _lbv1, u ) = (true) > >c  }}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 let _lbv38 = apply take  (, ep ), _lbv1 )
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 Finding Already seen tree for apply take  (, _lbv2 ), _lbv11 )
 Typechecking apply take  (, apply last  (, apply init  (, a3 ) ) ), apply goal  (, a2 ), n ), l ) )
 Against {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , a3, u ) = (true) >
 	 , 
 	 Conj <c (llen)(v) ==((llen)(a3) + (2))
 	 , 
 	 Conj <c (nth)( , a3, a1 ) ==(pen)(v)
 	 , (nth)( , a3, a2 ) ==(last)(v) >c  >c  >c  }}
 Typechecking the Term apply take  (, _lbv2 ), _lbv11 )
 Against {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , a3, u ) = (true) >
 	 , 
 	 Conj <c (llen)(v) ==((llen)(a3) + (2))
 	 , 
 	 Conj <c (nth)( , a3, a1 ) ==(pen)(v)
 	 , (nth)( , a3, a2 ) ==(last)(v) >c  >c  >c  }}
 Argument _lbv2 :: {v:int | (last)(_lbv1) ==(v)} | (last)(_lbv1) ==(_lbv2)
 Argument _lbv11 :: {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , l, u ) = (true) >
 	 , 
 	 Conj <c (llen)(v) ==((llen)(l) + (2))
 	 , 
 	 Conj <c (nth)( , l, a2 ) ==(pen)(v)
 	 , (nth)( , l, n ) ==(last)(v) >c  >c  >c  }} | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , _lbv11, u ) = (true)
 	 (lmem)( , l, u ) = (true) >
 	 , 
 	 Conj <c (llen)(_lbv11) ==((llen)(l) + (2))
 	 , 
 	 Conj <c (nth)( , l, a2 ) ==(pen)(_lbv11)
 	 , (nth)( , l, n ) ==(last)(_lbv11) >c  >c  >c  }
 AppType Type {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c (llen)(v) ==(_lbv2)
 	 , 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , _lbv11, u ) = (true) > >c  }}                                                                                                                                                                     
# of Final Z3 expressions 82
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
  Show *************** TypeChecking Succsessful {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c (llen)(v) ==(_lbv2)
 	 , 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , _lbv11, u ) = (true) > >c  }}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 let _lbv39 = apply take  (, _lbv2 ), _lbv11 )
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 Finding Already seen tree for apply take  (, _lbv2 ), _lbv14 )
 Typechecking apply take  (, apply last  (, apply init  (, a3 ) ) ), apply goal  (, a11 ), a2 ), apply init  (, a3 ) ) )
 Against {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , a3, u ) = (true) >
 	 , 
 	 Conj <c (llen)(v) ==((llen)(a3) + (2))
 	 , 
 	 Conj <c (nth)( , a3, a1 ) ==(pen)(v)
 	 , (nth)( , a3, a2 ) ==(last)(v) >c  >c  >c  }}
 Typechecking the Term apply take  (, _lbv2 ), _lbv14 )
 Against {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , a3, u ) = (true) >
 	 , 
 	 Conj <c (llen)(v) ==((llen)(a3) + (2))
 	 , 
 	 Conj <c (nth)( , a3, a1 ) ==(pen)(v)
 	 , (nth)( , a3, a2 ) ==(last)(v) >c  >c  >c  }}
 Argument _lbv2 :: {v:int | (last)(_lbv1) ==(v)} | (last)(_lbv1) ==(_lbv2)
 Argument _lbv14 :: {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , _lbv1, u ) = (true) >
 	 , 
 	 Conj <c (llen)(v) ==((llen)(_lbv1) + (2))
 	 , 
 	 Conj <c (nth)( , _lbv1, a11 ) ==(pen)(v)
 	 , (nth)( , _lbv1, a2 ) ==(last)(v) >c  >c  >c  }} | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , _lbv14, u ) = (true)
 	 (lmem)( , _lbv1, u ) = (true) >
 	 , 
 	 Conj <c (llen)(_lbv14) ==((llen)(_lbv1) + (2))
 	 , 
 	 Conj <c (nth)( , _lbv1, a11 ) ==(pen)(_lbv14)
 	 , (nth)( , _lbv1, a2 ) ==(last)(_lbv14) >c  >c  >c  }
 AppType Type {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c (llen)(v) ==(_lbv2)
 	 , 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , _lbv14, u ) = (true) > >c  }}                                                                                                                                                                         
# of Final Z3 expressions 84
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
  Show *************** TypeChecking Succsessful {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c (llen)(v) ==(_lbv2)
 	 , 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , _lbv14, u ) = (true) > >c  }}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 let _lbv40 = apply take  (, _lbv2 ), _lbv14 )
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 Finding Already seen tree for apply take  (, a2 ), _lbv7 )
 Typechecking apply take  (, a2 ), apply goal  (, a1 ), apply last  (, apply init  (, a3 ) ) ), a3 ) )
 Against {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , a3, u ) = (true) >
 	 , 
 	 Conj <c (llen)(v) ==((llen)(a3) + (2))
 	 , 
 	 Conj <c (nth)( , a3, a1 ) ==(pen)(v)
 	 , (nth)( , a3, a2 ) ==(last)(v) >c  >c  >c  }}
 Typechecking the Term apply take  (, a2 ), _lbv7 )
 Against {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , a3, u ) = (true) >
 	 , 
 	 Conj <c (llen)(v) ==((llen)(a3) + (2))
 	 , 
 	 Conj <c (nth)( , a3, a1 ) ==(pen)(v)
 	 , (nth)( , a3, a2 ) ==(last)(v) >c  >c  >c  }}
 Argument a2 :: {var_v21:int | true} | true
 Argument _lbv7 :: {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , a3, u ) = (true) >
 	 , 
 	 Conj <c (llen)(v) ==((llen)(a3) + (2))
 	 , 
 	 Conj <c (nth)( , a3, a1 ) ==(pen)(v)
 	 , (nth)( , a3, _lbv2 ) ==(last)(v) >c  >c  >c  }} | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , _lbv7, u ) = (true)
 	 (lmem)( , a3, u ) = (true) >
 	 , 
 	 Conj <c (llen)(_lbv7) ==((llen)(a3) + (2))
 	 , 
 	 Conj <c (nth)( , a3, a1 ) ==(pen)(_lbv7)
 	 , (nth)( , a3, _lbv2 ) ==(last)(_lbv7) >c  >c  >c  }
 AppType Type {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c (llen)(v) ==(a2)
 	 , 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , _lbv7, u ) = (true) > >c  }}                                                                                                                                                                             
# of Final Z3 expressions 86
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
  Show *************** TypeChecking Succsessful {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c (llen)(v) ==(a2)
 	 , 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , _lbv7, u ) = (true) > >c  }}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 let _lbv41 = apply take  (, a2 ), _lbv7 )
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 Finding Already seen tree for apply take  (, ep ), _lbv15 )
 Typechecking apply take  (, ep ), apply goal  (, n ), apply last  (, apply init  (, a3 ) ) ), l ) )
 Against {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , a3, u ) = (true) >
 	 , 
 	 Conj <c (llen)(v) ==((llen)(a3) + (2))
 	 , 
 	 Conj <c (nth)( , a3, a1 ) ==(pen)(v)
 	 , (nth)( , a3, a2 ) ==(last)(v) >c  >c  >c  }}
 Typechecking the Term apply take  (, ep ), _lbv15 )
 Against {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , a3, u ) = (true) >
 	 , 
 	 Conj <c (llen)(v) ==((llen)(a3) + (2))
 	 , 
 	 Conj <c (nth)( , a3, a1 ) ==(pen)(v)
 	 , (nth)( , a3, a2 ) ==(last)(v) >c  >c  >c  }}
 Argument ep :: {var_v0:int | true} | true
 Argument _lbv15 :: {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , l, u ) = (true) >
 	 , 
 	 Conj <c (llen)(v) ==((llen)(l) + (2))
 	 , 
 	 Conj <c (nth)( , l, n ) ==(pen)(v)
 	 , (nth)( , l, _lbv2 ) ==(last)(v) >c  >c  >c  }} | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , _lbv15, u ) = (true)
 	 (lmem)( , l, u ) = (true) >
 	 , 
 	 Conj <c (llen)(_lbv15) ==((llen)(l) + (2))
 	 , 
 	 Conj <c (nth)( , l, n ) ==(pen)(_lbv15)
 	 , (nth)( , l, _lbv2 ) ==(last)(_lbv15) >c  >c  >c  }
 AppType Type {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c (llen)(v) ==(ep)
 	 , 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , _lbv15, u ) = (true) > >c  }}                                                                                                                                                                                 
# of Final Z3 expressions 88
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
  Show *************** TypeChecking Succsessful {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c (llen)(v) ==(ep)
 	 , 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , _lbv15, u ) = (true) > >c  }}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 let _lbv42 = apply take  (, ep ), _lbv15 )
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  ###################################################
  The Choice of Function take Was Successfull for {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , a3, u ) = (true) >
 	 , 
 	 Conj <c (llen)(v) ==((llen)(a3) + (2))
 	 , 
 	 Conj <c (nth)( , a3, a1 ) ==(pen)(v)
 	 , (nth)( , a3, a2 ) ==(last)(v) >c  >c  >c  }} Continuing for completeness
  ###################################################
 *************************
 Success : 
 Number of synthesized programs : 20
 ************************* : 
  EXPLORED Args.parser output 
 EXPLORED learningOn  true
 EXPLORED bidirectionality  true
 EXPLORED effect-filter  false
 EXPLORED specfile :: ./prudent_tests/hegel/Hoogle+/map.spec
 EXPLORED goal Number :: 0
 EXPLORED Max path length :: 2
 EXPLORED Nested If :: 1typewhitespace var: ipair
semicolon
typewhitespace var: plist
semicolon
stexcwhitespace var: llen
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: pllen
whitespace colon
whitespace lbrace
var: ipair
rbrace
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: lmem
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: int
whitespace colon
whitespace var: bool
semicolon
stexcwhitespace var: lhd
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: plhd
whitespace colon
whitespace lbrace
var: ipair
rbrace
whitespace colon
whitespace var: ipair
semicolon
stexcwhitespace var: last
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: pllast
whitespace colon
whitespace lbrace
var: ipair
rbrace
whitespace colon
whitespace var: ipair
semicolon
stexcwhitespace var: ppr1
whitespace colon
whitespace var: ipair
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: ppr2
whitespace colon
whitespace var: ipair
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: nth
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: int
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: lsnd
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: pen
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: fst
whitespace colon
whitespace var: plist
whitespace colon
whitespace lbrace
var: int
rbrace
semicolon
stexcwhitespace var: snd
whitespace colon
whitespace var: plist
whitespace colon
whitespace lbrace
var: int
rbrace
semicolon
var: ep
whitespace colon
whitespace var: int
semicolon
var: length
whitespace colon
whitespace lparen
var: x
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace var: llen
whitespace lparen
var: x
rparen
whitespace equalopwhitespace var: v
rcurly
semicolon
whitespace var: rev
whitespace colon
whitespace lparen
var: l
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace pipe
whitespace whitespace var: llen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: llen
whitespace lparen
var: l
rparen
whitespace conjwhitespace var: lhd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: last
whitespace lparen
var: l
rparen
whitespace conjwhitespace var: last
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: lhd
whitespace lparen
var: l
rparen
whitespace conjwhitespace var: lsnd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: pen
whitespace lparen
var: l
rparen
whitespace conjwhitespace var: pen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: lsnd
whitespace lparen
var: v
rparen
whitespace rcurly
semicolon
var: compare_lengths
whitespace colon
whitespace lparen
var: x
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lparen
var: y
colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace var: bool
whitespace pipe
whitespace lbrace
var: v
equaloptruerbrace
whitespace iffwhitespace lparen
var: llen
whitespace lparen
var: x
rparen
whitespace equalopwhitespace var: llen
whitespace lparen
var: y
rparen
rparen
rcurly
semicolon
var: cons
whitespace colon
whitespace lparen
var: x
whitespace colon
whitespace var: int
rparen
whitespace arrow
whitespace lparen
var: xs
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace pipe
whitespace var: llen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: llen
whitespace lparen
var: xs
rparen
whitespace pluswhitespace int: 1
whitespace conjwhitespace var: lmem
whitespace lparen
var: v
comma
whitespace var: x
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace var: lhd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: x
whitespace conjwhitespace var: lsnd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: lhd
whitespace lparen
var: xs
rparen
whitespace conjwhitespace var: last
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: last
whitespace lparen
var: xs
rparen
whitespace conjwhitespace var: pen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: pen
whitespace lparen
var: xs
rparen
whitespace rcurly
semicolon
var: hd
whitespace colon
whitespace lparen
var: l
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace var: lmem
whitespace lparen
var: l
comma
whitespace var: v
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace var: lhd
whitespace lparen
var: l
rparen
whitespace equalopwhitespace var: v
whitespace whitespace rcurly
semicolon
var: tl
whitespace colon
whitespace lparen
var: l
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace pipe
whitespace var: llen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: llen
whitespace lparen
var: l
rparen
whitespace ar-minuswhitespace int: 1
whitespace conjwhitespace var: last
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: last
whitespace lparen
var: l
rparen
whitespace conjwhitespace var: lhd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: lsnd
whitespace lparen
var: l
rparen
whitespace conjwhitespace var: pen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: pen
whitespace lparen
var: l
rparen
whitespace rcurly
semicolon
var: nth
whitespace colon
whitespace lparen
var: l
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lparen
var: n
whitespace colon
whitespace var: int
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace var: lmem
whitespace lparen
var: l
comma
whitespace var: v
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace var: nth
whitespace lparen
var: l
comma
whitespace var: n
rparen
whitespace equalopwhitespace var: v
whitespace whitespace rcurly
semicolon
var: append
whitespace colon
whitespace lparen
var: l1
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lparen
var: l2
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace pipe
whitespace whitespace var: llen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: llen
whitespace lparen
var: l1
rparen
whitespace pluswhitespace var: llen
whitespace lparen
var: l2
rparen
whitespace conjwhitespace var: lhd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: lhd
whitespace lparen
var: l1
rparen
whitespace conjwhitespace var: lsnd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: lsnd
whitespace lparen
var: l1
rparen
whitespace conjwhitespace var: last
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: last
whitespace lparen
var: l2
rparen
whitespace conjwhitespace var: pen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: pen
whitespace lparen
var: l2
rparen
whitespace rcurly
semicolon
var: combine
whitespace colon
whitespace lparen
var: l1
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lparen
var: l2
whitespace colon
whitespace lcurly
var: v
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace pipe
whitespace var: llen
whitespace lparen
var: l1
rparen
whitespace equalopwhitespace var: llen
whitespace lparen
var: l2
rparen
rcurly
rparen
whitespace arrow
whitespace whitespace lcurly
var: v
whitespace colon
whitespace lbrace
var: ipair
rbrace
whitespace pipe
whitespace lambdalparen
var: H
whitespace colon
whitespace var: ipair
rparen
comma
whitespace lparen
var: L
whitespace colon
whitespace var: ipair
rparen
dotwhitespace var: pllen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: pllen
whitespace lparen
var: l1
rparen
whitespace conjwhitespace var: plhd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: H
whitespace conjwhitespace var: pllast
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: L
whitespace conjwhitespace var: ppr1
whitespace lparen
var: H
rparen
whitespace equalopwhitespace var: lhd
whitespace lparen
var: l1
rparen
whitespace conjwhitespace var: ppr2
whitespace lparen
var: H
rparen
whitespace equalopwhitespace var: lhd
whitespace lparen
var: l2
rparen
whitespace conjwhitespace var: ppr1
whitespace lparen
var: L
rparen
whitespace equalopwhitespace var: last
whitespace lparen
var: l1
rparen
whitespace conjwhitespace var: ppr2
whitespace lparen
var: L
rparen
whitespace equalopwhitespace var: last
whitespace lparen
var: l2
rparen
whitespace whitespace rcurly
semicolon
var: splitAt
whitespace colon
whitespace lparen
var: y
colon
var: int
rparen
whitespace arrow
whitespace lparen
var: l
whitespace colon
whitespace lcurly
whitespace var: v
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace pipe
whitespace var: llen
whitespace lparen
var: v
rparen
whitespace lessthanopwhitespace var: y
rcurly
rparen
whitespace arrow
whitespace whitespace lcurly
var: v
colon
var: plist
whitespace pipe
whitespace lambdalparen
var: H
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
comma
whitespace lparen
var: L
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
dotwhitespace lparen
var: fst
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: H
whitespace conjwhitespace var: snd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: L
rparen
whitespace implieswhitespace whitespace var: llen
whitespace lparen
var: H
rparen
whitespace equalopwhitespace var: y
whitespace conjwhitespace var: llen
whitespace lparen
var: L
rparen
whitespace equalopwhitespace var: llen
whitespace lparen
var: l
rparen
whitespace ar-minuswhitespace var: y
whitespace whitespace rcurly
semicolon
var: null
whitespace colon
whitespace lparen
var: l
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace var: bool
whitespace pipe
whitespace lbrace
var: v
equaloptruerbrace
whitespace iffwhitespace var: llen
whitespace lparen
var: l
rparen
whitespace equalopwhitespace int: 0
rcurly
semicolon
var: last
whitespace colon
whitespace lparen
var: l
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace var: last
whitespace lparen
var: l
rparen
whitespace equalopwhitespace var: v
rcurly
semicolon
whitespace var: init
whitespace colon
whitespace lparen
var: l
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace pipe
whitespace var: llen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: llen
whitespace lparen
var: v
rparen
whitespace ar-minusint: 1
rcurly
semicolon
whitespace var: take
whitespace colon
whitespace lparen
var: n
whitespace colon
whitespace var: int
rparen
whitespace arrow
whitespace lparen
var: l
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace pipe
whitespace lambdalparen
var: u
whitespace colon
whitespace var: int
rparen
dotwhitespace whitespace var: llen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: n
whitespace conjwhitespace whitespace lparen
var: lmem
whitespace lparen
var: v
comma
whitespace var: u
rparen
whitespace equalopwhitespace truerparen
whitespace implieswhitespace var: lmem
whitespace lparen
var: l
comma
whitespace var: u
rparen
whitespace equalopwhitespace truercurly
semicolon
whitespace stexcwhitespace var: slen
whitespace colon
whitespace lbrace
var: a
rbrace
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: ord
whitespace colon
whitespace var: int
whitespace colon
whitespace var: int
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: bool
semicolon
stexcwhitespace var: p
whitespace colon
whitespace var: int
whitespace colon
whitespace var: int
whitespace colon
whitespace var: bool
semicolon
stexcwhitespace var: q
whitespace colon
whitespace var: int
whitespace colon
whitespace var: int
whitespace colon
whitespace var: bool
semicolon
whitespace var: goal
whitespace colon
whitespace lparen
var: f
whitespace colon
whitespace lparen
var: x
whitespace colon
whitespace var: int
rparen
whitespace arrow
whitespace lcurly
whitespace var: v1
whitespace colon
whitespace var: int
whitespace pipe
whitespace var: p
whitespace lparen
var: x
comma
whitespace var: v1
rparen
whitespace equalopwhitespace truercurly
rparen
whitespace arrow
whitespace whitespace lparen
var: l
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace pipe
whitespace lambdalparen
var: u
whitespace colon
whitespace var: int
rparen
comma
whitespace lparen
var: u1
whitespace colon
whitespace var: int
rparen
comma
whitespace lparen
var: lel
whitespace colon
whitespace var: int
rparen
dotwhitespace whitespace lparen
var: lmem
whitespace lparen
var: lel
comma
whitespace var: l
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace var: lmem
whitespace lparen
var: u
whitespace comma
whitespace var: v
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace var: u1
whitespace equalopwhitespace var: u
whitespace ar-minuswhitespace int: 1
rparen
implieswhitespace whitespace var: p
whitespace lparen
var: lel
comma
whitespace var: u1
rparen
whitespace equalopwhitespace truewhitespace rcurly
semicolon
RelSpec {  SRs ;  PRs ;  TSs  
 Assume false
 name ep : 
 params :
 Type {var_v0:int | true} 
 Assume false
 name length : 
 params :
 Type  Arrow ( ( x : {var_v1:Ty_list int | true} ) -> {v:int | (llen)(x) ==(v)} 
 Assume false
 name rev : 
 params :
 Type  Arrow ( ( l : {var_v2:Ty_list int | true} ) -> {v:Ty_list int | 
 	 Conj <c (llen)(v) ==(llen)(l)
 	 , 
 	 Conj <c (lhd)(v) ==(last)(l)
 	 , 
 	 Conj <c (last)(v) ==(lhd)(l)
 	 , 
 	 Conj <c (lsnd)(v) ==(pen)(l)
 	 , (pen)(v) ==(lsnd)(v) >c  >c  >c  >c } 
 Assume false
 name compare_lengths : 
 params :
 Type  Arrow ( ( x : {var_v3:Ty_list int | true} ) ->  Arrow ( ( y : {var_v4:Ty_list int | true} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  (llen)(x) ==(llen)(y)} 
 Assume false
 name cons : 
 params :
 Type  Arrow ( ( x : {var_v5:int | true} ) ->  Arrow ( ( xs : {var_v6:Ty_list int | true} ) -> {v:Ty_list int | 
 	 Conj <c (llen)(v) ==((llen)(xs) + (1))
 	 , 
 	 Conj <c (lmem)( , v, x ) = (true)
 	 , 
 	 Conj <c (lhd)(v) ==(x)
 	 , 
 	 Conj <c (lsnd)(v) ==(lhd)(xs)
 	 , 
 	 Conj <c (last)(v) ==(last)(xs)
 	 , (pen)(v) ==(pen)(xs) >c  >c  >c  >c  >c } 
 Assume false
 name hd : 
 params :
 Type  Arrow ( ( l : {var_v7:Ty_list int | true} ) -> {v:int | 
 	 Conj <c (lmem)( , l, v ) = (true)
 	 , (lhd)(l) ==(v) >c } 
 Assume false
 name tl : 
 params :
 Type  Arrow ( ( l : {var_v8:Ty_list int | true} ) -> {v:Ty_list int | 
 	 Conj <c (llen)(v) ==((llen)(l) -- (1))
 	 , 
 	 Conj <c (last)(v) ==(last)(l)
 	 , 
 	 Conj <c (lhd)(v) ==(lsnd)(l)
 	 , (pen)(v) ==(pen)(l) >c  >c  >c } 
 Assume false
 name nth : 
 params :
 Type  Arrow ( ( l : {var_v9:Ty_list int | true} ) ->  Arrow ( ( n : {var_v10:int | true} ) -> {v:int | 
 	 Conj <c (lmem)( , l, v ) = (true)
 	 , (nth)( , l, n ) ==(v) >c } 
 Assume false
 name append : 
 params :
 Type  Arrow ( ( l1 : {var_v11:Ty_list int | true} ) ->  Arrow ( ( l2 : {var_v12:Ty_list int | true} ) -> {v:Ty_list int | 
 	 Conj <c (llen)(v) ==((llen)(l1) + (llen)(l2))
 	 , 
 	 Conj <c (lhd)(v) ==(lhd)(l1)
 	 , 
 	 Conj <c (lsnd)(v) ==(lsnd)(l1)
 	 , 
 	 Conj <c (last)(v) ==(last)(l2)
 	 , (pen)(v) ==(pen)(l2) >c  >c  >c  >c } 
 Assume false
 name combine : 
 params :
 Type  Arrow ( ( l1 : {var_v13:Ty_list int | true} ) ->  Arrow ( ( l2 : {v:Ty_list int | (llen)(l1) ==(llen)(l2)} ) -> {v:Ty_list int ipair | Forall 
 	 
 Key =H Value = int ipair
 Key =L Value = int ipair{ 
 	 Conj <c (pllen)(v) ==(pllen)(l1)
 	 , 
 	 Conj <c (plhd)(v) = (H)
 	 , 
 	 Conj <c (pllast)(v) = (L)
 	 , 
 	 Conj <c (ppr1)(H) ==(lhd)(l1)
 	 , 
 	 Conj <c (ppr2)(H) ==(lhd)(l2)
 	 , 
 	 Conj <c (ppr1)(L) ==(last)(l1)
 	 , (ppr2)(L) ==(last)(l2) >c  >c  >c  >c  >c  >c  }} 
 Assume false
 name splitAt : 
 params :
 Type  Arrow ( ( y : {var_v14:int | true} ) ->  Arrow ( ( l : {v:Ty_list int | (llen)(v) > (y)} ) -> {v:int plist | Forall 
 	 
 Key =H Value = Ty_list int
 Key =L Value = Ty_list int{ 
 	 Impl < 
 	 Conj <c (fst)(v) = (H)
 	 , (snd)(v) = (L) >c 
 	 
 	 Conj <c (llen)(H) ==(y)
 	 , (llen)(L) ==((llen)(l) -- (y)) >c  > }} 
 Assume false
 name null : 
 params :
 Type  Arrow ( ( l : {var_v15:Ty_list int | true} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  (llen)(l) ==(0)} 
 Assume false
 name last : 
 params :
 Type  Arrow ( ( l : {var_v16:Ty_list int | true} ) -> {v:int | (last)(l) ==(v)} 
 Assume false
 name init : 
 params :
 Type  Arrow ( ( l : {var_v17:Ty_list int | true} ) -> {v:Ty_list int | (llen)(v) ==((llen)(v) -- (1))} 
 Assume false
 name take : 
 params :
 Type  Arrow ( ( n : {var_v18:int | true} ) ->  Arrow ( ( l : {var_v19:Ty_list int | true} ) -> {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c (llen)(v) ==(n)
 	 , 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , l, u ) = (true) > >c  }} 
 Assume false
 name goal : 
 params :
 Type  Arrow ( ( f :  Arrow ( ( x : {var_v20:int | true} ) -> {v1:int | (p)( , x, v1 ) = (true)} ) ->  Arrow ( ( l : {var_v21:Ty_list int | true} ) -> {v:Ty_list int | Forall 
 	 
 Key =u Value = int
 Key =u1 Value = int
 Key =lel Value = int{ 
 	 Impl < 
 	 Conj <c (lmem)( , lel, l ) = (true)
 	 , 
 	 Conj <c (lmem)( , u, v ) = (true)
 	 , (u1) ==((u) -- (1)) >c  >c 
 	 (p)( , lel, u1 ) = (true) > }};  Formulas  }
 INITIAL GAMMA 
 
 goal :  Arrow ( ( f :  Arrow ( ( x : {var_v20:int | true} ) -> {v1:int | (p)( , x, v1 ) = (true)} ) ->  Arrow ( ( l : {var_v21:Ty_list int | true} ) -> {v:Ty_list int | Forall 
 	 
 Key =u Value = int
 Key =u1 Value = int
 Key =lel Value = int{ 
 	 Impl < 
 	 Conj <c (lmem)( , lel, l ) = (true)
 	 , 
 	 Conj <c (lmem)( , u, v ) = (true)
 	 , (u1) ==((u) -- (1)) >c  >c 
 	 (p)( , lel, u1 ) = (true) > }}
 take :  Arrow ( ( n : {var_v18:int | true} ) ->  Arrow ( ( l : {var_v19:Ty_list int | true} ) -> {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c (llen)(v) ==(n)
 	 , 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , l, u ) = (true) > >c  }}
 init :  Arrow ( ( l : {var_v17:Ty_list int | true} ) -> {v:Ty_list int | (llen)(v) ==((llen)(v) -- (1))}
 last :  Arrow ( ( l : {var_v16:Ty_list int | true} ) -> {v:int | (last)(l) ==(v)}
 null :  Arrow ( ( l : {var_v15:Ty_list int | true} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  (llen)(l) ==(0)}
 splitAt :  Arrow ( ( y : {var_v14:int | true} ) ->  Arrow ( ( l : {v:Ty_list int | (llen)(v) > (y)} ) -> {v:int plist | Forall 
 	 
 Key =H Value = Ty_list int
 Key =L Value = Ty_list int{ 
 	 Impl < 
 	 Conj <c (fst)(v) = (H)
 	 , (snd)(v) = (L) >c 
 	 
 	 Conj <c (llen)(H) ==(y)
 	 , (llen)(L) ==((llen)(l) -- (y)) >c  > }}
 combine :  Arrow ( ( l1 : {var_v13:Ty_list int | true} ) ->  Arrow ( ( l2 : {v:Ty_list int | (llen)(l1) ==(llen)(l2)} ) -> {v:Ty_list int ipair | Forall 
 	 
 Key =H Value = int ipair
 Key =L Value = int ipair{ 
 	 Conj <c (pllen)(v) ==(pllen)(l1)
 	 , 
 	 Conj <c (plhd)(v) = (H)
 	 , 
 	 Conj <c (pllast)(v) = (L)
 	 , 
 	 Conj <c (ppr1)(H) ==(lhd)(l1)
 	 , 
 	 Conj <c (ppr2)(H) ==(lhd)(l2)
 	 , 
 	 Conj <c (ppr1)(L) ==(last)(l1)
 	 , (ppr2)(L) ==(last)(l2) >c  >c  >c  >c  >c  >c  }}
 append :  Arrow ( ( l1 : {var_v11:Ty_list int | true} ) ->  Arrow ( ( l2 : {var_v12:Ty_list int | true} ) -> {v:Ty_list int | 
 	 Conj <c (llen)(v) ==((llen)(l1) + (llen)(l2))
 	 , 
 	 Conj <c (lhd)(v) ==(lhd)(l1)
 	 , 
 	 Conj <c (lsnd)(v) ==(lsnd)(l1)
 	 , 
 	 Conj <c (last)(v) ==(last)(l2)
 	 , (pen)(v) ==(pen)(l2) >c  >c  >c  >c }
 nth :  Arrow ( ( l : {var_v9:Ty_list int | true} ) ->  Arrow ( ( n : {var_v10:int | true} ) -> {v:int | 
 	 Conj <c (lmem)( , l, v ) = (true)
 	 , (nth)( , l, n ) ==(v) >c }
 tl :  Arrow ( ( l : {var_v8:Ty_list int | true} ) -> {v:Ty_list int | 
 	 Conj <c (llen)(v) ==((llen)(l) -- (1))
 	 , 
 	 Conj <c (last)(v) ==(last)(l)
 	 , 
 	 Conj <c (lhd)(v) ==(lsnd)(l)
 	 , (pen)(v) ==(pen)(l) >c  >c  >c }
 hd :  Arrow ( ( l : {var_v7:Ty_list int | true} ) -> {v:int | 
 	 Conj <c (lmem)( , l, v ) = (true)
 	 , (lhd)(l) ==(v) >c }
 cons :  Arrow ( ( x : {var_v5:int | true} ) ->  Arrow ( ( xs : {var_v6:Ty_list int | true} ) -> {v:Ty_list int | 
 	 Conj <c (llen)(v) ==((llen)(xs) + (1))
 	 , 
 	 Conj <c (lmem)( , v, x ) = (true)
 	 , 
 	 Conj <c (lhd)(v) ==(x)
 	 , 
 	 Conj <c (lsnd)(v) ==(lhd)(xs)
 	 , 
 	 Conj <c (last)(v) ==(last)(xs)
 	 , (pen)(v) ==(pen)(xs) >c  >c  >c  >c  >c }
 compare_lengths :  Arrow ( ( x : {var_v3:Ty_list int | true} ) ->  Arrow ( ( y : {var_v4:Ty_list int | true} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  (llen)(x) ==(llen)(y)}
 rev :  Arrow ( ( l : {var_v2:Ty_list int | true} ) -> {v:Ty_list int | 
 	 Conj <c (llen)(v) ==(llen)(l)
 	 , 
 	 Conj <c (lhd)(v) ==(last)(l)
 	 , 
 	 Conj <c (last)(v) ==(lhd)(l)
 	 , 
 	 Conj <c (lsnd)(v) ==(pen)(l)
 	 , (pen)(v) ==(lsnd)(v) >c  >c  >c  >c }
 length :  Arrow ( ( x : {var_v1:Ty_list int | true} ) -> {v:int | (llen)(x) ==(v)}
 ep : {var_v0:int | true}
 INITIAL SIGMA 
 
 TypeNames 
 
 plist
 ipair
 Qualifiers 
 
 Qual llen :  :-> Ty_list int :-> int
 Qual pllen :  :-> Ty_list int ipair :-> int
 Qual lmem :  :-> Ty_list int :-> int :-> Ty_bool
 Qual lhd :  :-> Ty_list int :-> int
 Qual plhd :  :-> Ty_list int ipair :-> int ipair
 Qual last :  :-> Ty_list int :-> int
 Qual pllast :  :-> Ty_list int ipair :-> int ipair
 Qual ppr1 :  :-> int ipair :-> int
 Qual ppr2 :  :-> int ipair :-> int
 Qual nth :  :-> Ty_list int :-> int :-> int
 Qual lsnd :  :-> Ty_list int :-> int
 Qual pen :  :-> Ty_list int :-> int
 Qual fst :  :-> int plist :-> Ty_list int
 Qual snd :  :-> int plist :-> Ty_list int
 Qual slen :  :-> Ty_list int a :-> int
 Qual ord :  :-> int :-> int :-> Ty_list int :-> Ty_bool
 Qual p :  :-> int :-> int :-> Ty_bool
 Qual q :  :-> int :-> int :-> Ty_bool
 Show ***********Calling S-FUNC synthesize***************
 Show Uncurried , f: Arrow ( ( x : {var_v20:int | true} ) -> {v1:int | (p)( , x, v1 ) = (true)}, l:{var_v21:Ty_list int | true} -> {v:Ty_list int | Forall 
 	 
 Key =u Value = int
 Key =u1 Value = int
 Key =lel Value = int{ 
 	 Impl < 
 	 Conj <c (lmem)( , lel, l ) = (true)
 	 , 
 	 Conj <c (lmem)( , u, v ) = (true)
 	 , (u1) ==((u) -- (1)) >c  >c 
 	 (p)( , lel, u1 ) = (true) > }}
 Decreasing Measure f
 Decreasing Type  Arrow ( ( x : {var_v20:int | true} ) -> {v1:int | (p)( , x, v1 ) = (true)}
 Show Trying :: Top-level Match
 Show :: Synthesize Match {v:Ty_list int | Forall 
 	 
 Key =u Value = int
 Key =u1 Value = int
 Key =lel Value = int{ 
 	 Impl < 
 	 Conj <c (lmem)( , lel, l ) = (true)
 	 , 
 	 Conj <c (lmem)( , u, v ) = (true)
 	 , (u1) ==((u) -- (1)) >c  >c 
 	 (p)( , lel, u1 ) = (true) > }}
  EXPLORED Args.parser output 
 EXPLORED learningOn  true
 EXPLORED bidirectionality  true
 EXPLORED effect-filter  false
 EXPLORED specfile :: ./prudent_tests/hegel/Hoogle+/applyNInv.spec
 EXPLORED goal Number :: 0
 EXPLORED Max path length :: 2
 EXPLORED Nested If :: 1typewhitespace var: ipair
semicolon
typewhitespace var: plist
semicolon
stexcwhitespace var: llen
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: pllen
whitespace colon
whitespace lbrace
var: ipair
rbrace
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: lmem
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: int
whitespace colon
whitespace var: bool
semicolon
stexcwhitespace var: lhd
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: plhd
whitespace colon
whitespace lbrace
var: ipair
rbrace
whitespace colon
whitespace var: ipair
semicolon
stexcwhitespace var: last
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: pllast
whitespace colon
whitespace lbrace
var: ipair
rbrace
whitespace colon
whitespace var: ipair
semicolon
stexcwhitespace var: ppr1
whitespace colon
whitespace var: ipair
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: ppr2
whitespace colon
whitespace var: ipair
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: nth
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: int
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: lsnd
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: pen
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: fst
whitespace colon
whitespace var: plist
whitespace colon
whitespace lbrace
var: int
rbrace
semicolon
stexcwhitespace var: snd
whitespace colon
whitespace var: plist
whitespace colon
whitespace lbrace
var: int
rbrace
semicolon
var: ep
whitespace colon
whitespace var: int
semicolon
var: length
whitespace colon
whitespace lparen
var: x
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace var: llen
whitespace lparen
var: x
rparen
whitespace equalopwhitespace var: v
rcurly
semicolon
whitespace var: rev
whitespace colon
whitespace lparen
var: l
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace pipe
whitespace whitespace var: llen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: llen
whitespace lparen
var: l
rparen
whitespace conjwhitespace var: lhd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: last
whitespace lparen
var: l
rparen
whitespace conjwhitespace var: last
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: lhd
whitespace lparen
var: l
rparen
whitespace conjwhitespace var: lsnd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: pen
whitespace lparen
var: l
rparen
whitespace conjwhitespace var: pen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: lsnd
whitespace lparen
var: v
rparen
whitespace rcurly
semicolon
var: compare_lengths
whitespace colon
whitespace lparen
var: x
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lparen
var: y
colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace var: bool
whitespace pipe
whitespace lbrace
var: v
equaloptruerbrace
whitespace iffwhitespace lparen
var: llen
whitespace lparen
var: x
rparen
whitespace equalopwhitespace var: llen
whitespace lparen
var: y
rparen
rparen
rcurly
semicolon
var: cons
whitespace colon
whitespace lparen
var: x
whitespace colon
whitespace var: int
rparen
whitespace arrow
whitespace lparen
var: xs
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace pipe
whitespace var: llen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: llen
whitespace lparen
var: xs
rparen
whitespace pluswhitespace int: 1
whitespace conjwhitespace var: lmem
whitespace lparen
var: v
comma
whitespace var: x
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace var: lhd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: x
whitespace conjwhitespace var: lsnd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: lhd
whitespace lparen
var: xs
rparen
whitespace conjwhitespace var: last
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: last
whitespace lparen
var: xs
rparen
whitespace conjwhitespace var: pen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: pen
whitespace lparen
var: xs
rparen
whitespace rcurly
semicolon
var: hd
whitespace colon
whitespace lparen
var: l
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace var: lmem
whitespace lparen
var: l
comma
whitespace var: v
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace var: lhd
whitespace lparen
var: l
rparen
whitespace equalopwhitespace var: v
whitespace whitespace rcurly
semicolon
var: tl
whitespace colon
whitespace lparen
var: l
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace pipe
whitespace var: llen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: llen
whitespace lparen
var: l
rparen
whitespace ar-minuswhitespace int: 1
whitespace conjwhitespace var: last
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: last
whitespace lparen
var: l
rparen
whitespace conjwhitespace var: lhd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: lsnd
whitespace lparen
var: l
rparen
whitespace conjwhitespace var: pen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: pen
whitespace lparen
var: l
rparen
whitespace rcurly
semicolon
var: nth
whitespace colon
whitespace lparen
var: l
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lparen
var: n
whitespace colon
whitespace var: int
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace var: lmem
whitespace lparen
var: l
comma
whitespace var: v
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace var: nth
whitespace lparen
var: l
comma
whitespace var: n
rparen
whitespace equalopwhitespace var: v
whitespace whitespace rcurly
semicolon
var: append
whitespace colon
whitespace lparen
var: l1
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lparen
var: l2
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace pipe
whitespace whitespace var: llen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: llen
whitespace lparen
var: l1
rparen
whitespace pluswhitespace var: llen
whitespace lparen
var: l2
rparen
whitespace conjwhitespace var: lhd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: lhd
whitespace lparen
var: l1
rparen
whitespace conjwhitespace var: lsnd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: lsnd
whitespace lparen
var: l1
rparen
whitespace conjwhitespace var: last
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: last
whitespace lparen
var: l2
rparen
whitespace conjwhitespace var: pen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: pen
whitespace lparen
var: l2
rparen
whitespace rcurly
semicolon
var: combine
whitespace colon
whitespace lparen
var: l1
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lparen
var: l2
whitespace colon
whitespace lcurly
var: v
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace pipe
whitespace var: llen
whitespace lparen
var: l1
rparen
whitespace equalopwhitespace var: llen
whitespace lparen
var: l2
rparen
rcurly
rparen
whitespace arrow
whitespace whitespace lcurly
var: v
whitespace colon
whitespace lbrace
var: ipair
rbrace
whitespace pipe
whitespace lambdalparen
var: H
whitespace colon
whitespace var: ipair
rparen
comma
whitespace lparen
var: L
whitespace colon
whitespace var: ipair
rparen
dotwhitespace var: pllen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: pllen
whitespace lparen
var: l1
rparen
whitespace conjwhitespace var: plhd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: H
whitespace conjwhitespace var: pllast
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: L
whitespace conjwhitespace var: ppr1
whitespace lparen
var: H
rparen
whitespace equalopwhitespace var: lhd
whitespace lparen
var: l1
rparen
whitespace conjwhitespace var: ppr2
whitespace lparen
var: H
rparen
whitespace equalopwhitespace var: lhd
whitespace lparen
var: l2
rparen
whitespace conjwhitespace var: ppr1
whitespace lparen
var: L
rparen
whitespace equalopwhitespace var: last
whitespace lparen
var: l1
rparen
whitespace conjwhitespace var: ppr2
whitespace lparen
var: L
rparen
whitespace equalopwhitespace var: last
whitespace lparen
var: l2
rparen
whitespace whitespace rcurly
semicolon
var: splitAt
whitespace colon
whitespace lparen
var: y
colon
var: int
rparen
whitespace arrow
whitespace lparen
var: l
whitespace colon
whitespace lcurly
whitespace var: v
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace pipe
whitespace var: llen
whitespace lparen
var: v
rparen
whitespace lessthanopwhitespace var: y
rcurly
rparen
whitespace arrow
whitespace whitespace lcurly
var: v
colon
var: plist
whitespace pipe
whitespace lambdalparen
var: H
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
comma
whitespace lparen
var: L
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
dotwhitespace lparen
var: fst
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: H
whitespace conjwhitespace var: snd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: L
rparen
whitespace implieswhitespace whitespace var: llen
whitespace lparen
var: H
rparen
whitespace equalopwhitespace var: y
whitespace conjwhitespace var: llen
whitespace lparen
var: L
rparen
whitespace equalopwhitespace var: llen
whitespace lparen
var: l
rparen
whitespace ar-minuswhitespace var: y
whitespace whitespace rcurly
semicolon
var: null
whitespace colon
whitespace lparen
var: l
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace var: bool
whitespace pipe
whitespace lbrace
var: v
equaloptruerbrace
whitespace iffwhitespace var: llen
whitespace lparen
var: l
rparen
whitespace equalopwhitespace int: 0
rcurly
semicolon
var: last
whitespace colon
whitespace lparen
var: l
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace var: last
whitespace lparen
var: l
rparen
whitespace equalopwhitespace var: v
rcurly
semicolon
whitespace var: init
whitespace colon
whitespace lparen
var: l
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace pipe
whitespace var: llen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: llen
whitespace lparen
var: v
rparen
whitespace ar-minusint: 1
rcurly
semicolon
whitespace var: take
whitespace colon
whitespace lparen
var: n
whitespace colon
whitespace var: int
rparen
whitespace arrow
whitespace lparen
var: l
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace pipe
whitespace lambdalparen
var: u
whitespace colon
whitespace var: int
rparen
dotwhitespace whitespace var: llen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: n
whitespace conjwhitespace whitespace lparen
var: lmem
whitespace lparen
var: v
comma
whitespace var: u
rparen
whitespace equalopwhitespace truerparen
whitespace implieswhitespace var: lmem
whitespace lparen
var: l
comma
whitespace var: u
rparen
whitespace equalopwhitespace truercurly
semicolon
whitespace whitespace var: goal
whitespace var: p

  EXPLORED Args.parser output 
 EXPLORED learningOn  true
 EXPLORED bidirectionality  true
 EXPLORED effect-filter  false
 EXPLORED specfile :: ./prudent_tests/hegel/Hoogle+/mapDouble.spec
 EXPLORED goal Number :: 0
 EXPLORED Max path length :: 2
 EXPLORED Nested If :: 1typewhitespace var: ipair
semicolon
typewhitespace var: plist
semicolon
stexcwhitespace var: llen
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: pllen
whitespace colon
whitespace lbrace
var: ipair
rbrace
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: lmem
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: int
whitespace colon
whitespace var: bool
semicolon
stexcwhitespace var: lhd
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: plhd
whitespace colon
whitespace lbrace
var: ipair
rbrace
whitespace colon
whitespace var: ipair
semicolon
stexcwhitespace var: last
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: pllast
whitespace colon
whitespace lbrace
var: ipair
rbrace
whitespace colon
whitespace var: ipair
semicolon
stexcwhitespace var: ppr1
whitespace colon
whitespace var: ipair
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: ppr2
whitespace colon
whitespace var: ipair
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: nth
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: int
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: lsnd
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: pen
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: fst
whitespace colon
whitespace var: plist
whitespace colon
whitespace lbrace
var: int
rbrace
semicolon
stexcwhitespace var: snd
whitespace colon
whitespace var: plist
whitespace colon
whitespace lbrace
var: int
rbrace
semicolon
var: ep
whitespace colon
whitespace var: int
semicolon
var: length
whitespace colon
whitespace lparen
var: x
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace var: llen
whitespace lparen
var: x
rparen
whitespace equalopwhitespace var: v
rcurly
semicolon
whitespace var: rev
whitespace colon
whitespace lparen
var: l
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace pipe
whitespace whitespace var: llen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: llen
whitespace lparen
var: l
rparen
whitespace conjwhitespace var: lhd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: last
whitespace lparen
var: l
rparen
whitespace conjwhitespace var: last
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: lhd
whitespace lparen
var: l
rparen
whitespace conjwhitespace var: lsnd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: pen
whitespace lparen
var: l
rparen
whitespace conjwhitespace var: pen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: lsnd
whitespace lparen
var: v
rparen
whitespace rcurly
semicolon
var: compare_lengths
whitespace colon
whitespace lparen
var: x
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lparen
var: y
colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace var: bool
whitespace pipe
whitespace lbrace
var: v
equaloptruerbrace
whitespace iffwhitespace lparen
var: llen
whitespace lparen
var: x
rparen
whitespace equalopwhitespace var: llen
whitespace lparen
var: y
rparen
rparen
rcurly
semicolon
var: cons
whitespace colon
whitespace lparen
var: x
whitespace colon
whitespace var: int
rparen
whitespace arrow
whitespace lparen
var: xs
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace pipe
whitespace var: llen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: llen
whitespace lparen
var: xs
rparen
whitespace pluswhitespace int: 1
whitespace conjwhitespace var: lmem
whitespace lparen
var: v
comma
whitespace var: x
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace var: lhd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: x
whitespace conjwhitespace var: lsnd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: lhd
whitespace lparen
var: xs
rparen
whitespace conjwhitespace var: last
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: last
whitespace lparen
var: xs
rparen
whitespace conjwhitespace var: pen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: pen
whitespace lparen
var: xs
rparen
whitespace rcurly
semicolon
var: hd
whitespace colon
whitespace lparen
var: l
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace var: lmem
whitespace lparen
var: l
comma
whitespace var: v
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace var: lhd
whitespace lparen
var: l
rparen
whitespace equalopwhitespace var: v
whitespace whitespace rcurly
semicolon
var: tl
whitespace colon
whitespace lparen
var: l
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace pipe
whitespace var: llen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: llen
whitespace lparen
var: l
rparen
whitespace ar-minuswhitespace int: 1
whitespace conjwhitespace var: last
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: last
whitespace lparen
var: l
rparen
whitespace conjwhitespace var: lhd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: lsnd
whitespace lparen
var: l
rparen
whitespace conjwhitespace var: pen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: pen
whitespace lparen
var: l
rparen
whitespace rcurly
semicolon
var: nth
whitespace colon
whitespace lparen
var: l
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lparen
var: n
whitespace colon
whitespace var: int
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace var: lmem
whitespace lparen
var: l
comma
whitespace var: v
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace var: nth
whitespace lparen
var: l
comma
whitespace var: n
rparen
whitespace equalopwhitespace var: v
whitespace whitespace rcurly
semicolon
var: append
whitespace colon
whitespace lparen
var: l1
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lparen
var: l2
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace pipe
whitespace whitespace var: llen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: llen
whitespace lparen
var: l1
rparen
whitespace pluswhitespace var: llen
whitespace lparen
var: l2
rparen
whitespace conjwhitespace var: lhd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: lhd
whitespace lparen
var: l1
rparen
whitespace conjwhitespace var: lsnd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: lsnd
whitespace lparen
var: l1
rparen
whitespace conjwhitespace var: last
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: last
whitespace lparen
var: l2
rparen
whitespace conjwhitespace var: pen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: pen
whitespace lparen
var: l2
rparen
whitespace rcurly
semicolon
var: combine
whitespace colon
whitespace lparen
var: l1
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lparen
var: l2
whitespace colon
whitespace lcurly
var: v
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace pipe
whitespace var: llen
whitespace lparen
var: l1
rparen
whitespace equalopwhitespace var: llen
whitespace lparen
var: l2
rparen
rcurly
rparen
whitespace arrow
whitespace whitespace lcurly
var: v
whitespace colon
whitespace lbrace
var: ipair
rbrace
whitespace pipe
whitespace lambdalparen
var: H
whitespace colon
whitespace var: ipair
rparen
comma
whitespace lparen
var: L
whitespace colon
whitespace var: ipair
rparen
dotwhitespace var: pllen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: pllen
whitespace lparen
var: l1
rparen
whitespace conjwhitespace var: plhd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: H
whitespace conjwhitespace var: pllast
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: L
whitespace conjwhitespace var: ppr1
whitespace lparen
var: H
rparen
whitespace equalopwhitespace var: lhd
whitespace lparen
var: l1
rparen
whitespace conjwhitespace var: ppr2
whitespace lparen
var: H
rparen
whitespace equalopwhitespace var: lhd
whitespace lparen
var: l2
rparen
whitespace conjwhitespace var: ppr1
whitespace lparen
var: L
rparen
whitespace equalopwhitespace var: last
whitespace lparen
var: l1
rparen
whitespace conjwhitespace var: ppr2
whitespace lparen
var: L
rparen
whitespace equalopwhitespace var: last
whitespace lparen
var: l2
rparen
whitespace whitespace rcurly
semicolon
var: splitAt
whitespace colon
whitespace lparen
var: y
colon
var: int
rparen
whitespace arrow
whitespace lparen
var: l
whitespace colon
whitespace lcurly
whitespace var: v
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace pipe
whitespace var: llen
whitespace lparen
var: v
rparen
whitespace lessthanopwhitespace var: y
rcurly
rparen
whitespace arrow
whitespace whitespace lcurly
var: v
colon
var: plist
whitespace pipe
whitespace lambdalparen
var: H
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
comma
whitespace lparen
var: L
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
dotwhitespace lparen
var: fst
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: H
whitespace conjwhitespace var: snd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: L
rparen
whitespace implieswhitespace whitespace var: llen
whitespace lparen
var: H
rparen
whitespace equalopwhitespace var: y
whitespace conjwhitespace var: llen
whitespace lparen
var: L
rparen
whitespace equalopwhitespace var: llen
whitespace lparen
var: l
rparen
whitespace ar-minuswhitespace var: y
whitespace whitespace rcurly
semicolon
var: null
whitespace colon
whitespace lparen
var: l
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace var: bool
whitespace pipe
whitespace lbrace
var: v
equaloptruerbrace
whitespace iffwhitespace var: llen
whitespace lparen
var: l
rparen
whitespace equalopwhitespace int: 0
rcurly
semicolon
var: last
whitespace colon
whitespace lparen
var: l
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace var: last
whitespace lparen
var: l
rparen
whitespace equalopwhitespace var: v
rcurly
semicolon
whitespace var: init
whitespace colon
whitespace lparen
var: l
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace pipe
whitespace var: llen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: llen
whitespace lparen
var: v
rparen
whitespace ar-minusint: 1
rcurly
semicolon
whitespace var: take
whitespace colon
whitespace lparen
var: n
whitespace colon
whitespace var: int
rparen
whitespace arrow
whitespace lparen
var: l
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace pipe
whitespace lambdalparen
var: u
whitespace colon
whitespace var: int
rparen
dotwhitespace whitespace var: llen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: n
whitespace conjwhitespace whitespace lparen
var: lmem
whitespace lparen
var: v
comma
whitespace var: u
rparen
whitespace equalopwhitespace truerparen
whitespace implieswhitespace var: lmem
whitespace lparen
var: l
comma
whitespace var: u
rparen
whitespace equalopwhitespace truercurly
semicolon
whitespace stexcwhitespace var: slen
whitespace colon
whitespace lbrace
var: a
rbrace
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: ord
whitespace colon
whitespace var: int
whitespace colon
whitespace var: int
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: bool
semicolon
stexcwhitespace var: p
whitespace colon
whitespace var: int
whitespace colon
whitespace var: int
whitespace colon
whitespace var: bool
semicolon
stexcwhitespace var: q
whitespace colon
whitespace var: int
whitespace colon
whitespace var: int
whitespace colon
whitespace var: bool
semicolon
var: goal
colon
whitespace lparen
var: f
whitespace colon
whitespace lparen
var: x
whitespace colon
whitespace var: int
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace var: p
whitespace lparen
var: x
comma
whitespace var: v
rparen
whitespace equalopwhitespace truercurly
rparen
whitespace arrow
whitespace whitespace lparen
var: g
whitespace colon
whitespace lparen
var: x
whitespace colon
whitespace var: int
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace var: q
whitespace lparen
var: x
comma
whitespace var: v
rparen
whitespace equalopwhitespace truercurly
rparen
whitespace arrow
whitespace whitespace lparen
var: l
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace whitespace lcurly
var: v
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace pipe
whitespace lambdalparen
var: u
whitespace colon
whitespace var: int
rparen
comma
whitespace lparen
var: w
whitespace colon
whitespace var: int
rparen
comma
whitespace lparen
var: z
whitespace colon
whitespace var: int
rparen
comma
whitespace lparen
var: l1
colon
whitespace lbrace
var: int
rbrace
rparen
dotwhitespace whitespace lparen
var: lmem
whitespace lparen
var: u
comma
whitespace var: l
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace var: lmem
whitespace lparen
var: z
whitespace comma
whitespace var: v
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace whitespace var: lmem
whitespace lparen
var: w
comma
whitespace var: l1
rparen
whitespace equalopwhitespace truerparen
whitespace implieswhitespace whitespace lparen
whitespace var: p
whitespace lparen
var: u
whitespace comma
whitespace var: w
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace var: q
whitespace lparen
var: w
whitespace comma
whitespace var: z
rparen
whitespace equalopwhitespace truewhitespace rparen
whitespace rcurly
semicolon
RelSpec {  SRs ;  PRs ;  TSs  
 Assume false
 name ep : 
 params :
 Type {var_v0:int | true} 
 Assume false
 name length : 
 params :
 Type  Arrow ( ( x : {var_v1:Ty_list int | true} ) -> {v:int | (llen)(x) ==(v)} 
 Assume false
 name rev : 
 params :
 Type  Arrow ( ( l : {var_v2:Ty_list int | true} ) -> {v:Ty_list int | 
 	 Conj <c (llen)(v) ==(llen)(l)
 	 , 
 	 Conj <c (lhd)(v) ==(last)(l)
 	 , 
 	 Conj <c (last)(v) ==(lhd)(l)
 	 , 
 	 Conj <c (lsnd)(v) ==(pen)(l)
 	 , (pen)(v) ==(lsnd)(v) >c  >c  >c  >c } 
 Assume false
 name compare_lengths : 
 params :
 Type  Arrow ( ( x : {var_v3:Ty_list int | true} ) ->  Arrow ( ( y : {var_v4:Ty_list int | true} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  (llen)(x) ==(llen)(y)} 
 Assume false
 name cons : 
 params :
 Type  Arrow ( ( x : {var_v5:int | true} ) ->  Arrow ( ( xs : {var_v6:Ty_list int | true} ) -> {v:Ty_list int | 
 	 Conj <c (llen)(v) ==((llen)(xs) + (1))
 	 , 
 	 Conj <c (lmem)( , v, x ) = (true)
 	 , 
 	 Conj <c (lhd)(v) ==(x)
 	 , 
 	 Conj <c (lsnd)(v) ==(lhd)(xs)
 	 , 
 	 Conj <c (last)(v) ==(last)(xs)
 	 , (pen)(v) ==(pen)(xs) >c  >c  >c  >c  >c } 
 Assume false
 name hd : 
 params :
 Type  Arrow ( ( l : {var_v7:Ty_list int | true} ) -> {v:int | 
 	 Conj <c (lmem)( , l, v ) = (true)
 	 , (lhd)(l) ==(v) >c } 
 Assume false
 name tl : 
 params :
 Type  Arrow ( ( l : {var_v8:Ty_list int | true} ) -> {v:Ty_list int | 
 	 Conj <c (llen)(v) ==((llen)(l) -- (1))
 	 , 
 	 Conj <c (last)(v) ==(last)(l)
 	 , 
 	 Conj <c (lhd)(v) ==(lsnd)(l)
 	 , (pen)(v) ==(pen)(l) >c  >c  >c } 
 Assume false
 name nth : 
 params :
 Type  Arrow ( ( l : {var_v9:Ty_list int | true} ) ->  Arrow ( ( n : {var_v10:int | true} ) -> {v:int | 
 	 Conj <c (lmem)( , l, v ) = (true)
 	 , (nth)( , l, n ) ==(v) >c } 
 Assume false
 name append : 
 params :
 Type  Arrow ( ( l1 : {var_v11:Ty_list int | true} ) ->  Arrow ( ( l2 : {var_v12:Ty_list int | true} ) -> {v:Ty_list int | 
 	 Conj <c (llen)(v) ==((llen)(l1) + (llen)(l2))
 	 , 
 	 Conj <c (lhd)(v) ==(lhd)(l1)
 	 , 
 	 Conj <c (lsnd)(v) ==(lsnd)(l1)
 	 , 
 	 Conj <c (last)(v) ==(last)(l2)
 	 , (pen)(v) ==(pen)(l2) >c  >c  >c  >c } 
 Assume false
 name combine : 
 params :
 Type  Arrow ( ( l1 : {var_v13:Ty_list int | true} ) ->  Arrow ( ( l2 : {v:Ty_list int | (llen)(l1) ==(llen)(l2)} ) -> {v:Ty_list int ipair | Forall 
 	 
 Key =H Value = int ipair
 Key =L Value = int ipair{ 
 	 Conj <c (pllen)(v) ==(pllen)(l1)
 	 , 
 	 Conj <c (plhd)(v) = (H)
 	 , 
 	 Conj <c (pllast)(v) = (L)
 	 , 
 	 Conj <c (ppr1)(H) ==(lhd)(l1)
 	 , 
 	 Conj <c (ppr2)(H) ==(lhd)(l2)
 	 , 
 	 Conj <c (ppr1)(L) ==(last)(l1)
 	 , (ppr2)(L) ==(last)(l2) >c  >c  >c  >c  >c  >c  }} 
 Assume false
 name splitAt : 
 params :
 Type  Arrow ( ( y : {var_v14:int | true} ) ->  Arrow ( ( l : {v:Ty_list int | (llen)(v) > (y)} ) -> {v:int plist | Forall 
 	 
 Key =H Value = Ty_list int
 Key =L Value = Ty_list int{ 
 	 Impl < 
 	 Conj <c (fst)(v) = (H)
 	 , (snd)(v) = (L) >c 
 	 
 	 Conj <c (llen)(H) ==(y)
 	 , (llen)(L) ==((llen)(l) -- (y)) >c  > }} 
 Assume false
 name null : 
 params :
 Type  Arrow ( ( l : {var_v15:Ty_list int | true} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  (llen)(l) ==(0)} 
 Assume false
 name last : 
 params :
 Type  Arrow ( ( l : {var_v16:Ty_list int | true} ) -> {v:int | (last)(l) ==(v)} 
 Assume false
 name init : 
 params :
 Type  Arrow ( ( l : {var_v17:Ty_list int | true} ) -> {v:Ty_list int | (llen)(v) ==((llen)(v) -- (1))} 
 Assume false
 name take : 
 params :
 Type  Arrow ( ( n : {var_v18:int | true} ) ->  Arrow ( ( l : {var_v19:Ty_list int | true} ) -> {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c (llen)(v) ==(n)
 	 , 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , l, u ) = (true) > >c  }} 
 Assume false
 name goal : 
 params :
 Type  Arrow ( ( f :  Arrow ( ( x : {var_v20:int | true} ) -> {v:int | (p)( , x, v ) = (true)} ) ->  Arrow ( ( g :  Arrow ( ( x : {var_v21:int | true} ) -> {v:int | (q)( , x, v ) = (true)} ) ->  Arrow ( ( l : {var_v22:Ty_list int | true} ) -> {v:Ty_list int | Forall 
 	 
 Key =u Value = int
 Key =w Value = int
 Key =z Value = int
 Key =l1 Value = Ty_list int{ 
 	 Impl < 
 	 Conj <c (lmem)( , u, l ) = (true)
 	 , 
 	 Conj <c (lmem)( , z, v ) = (true)
 	 , (lmem)( , w, l1 ) = (true) >c  >c 
 	 
 	 Conj <c (p)( , u, w ) = (true)
 	 , (q)( , w, z ) = (true) >c  > }};  Formulas  }
 INITIAL GAMMA 
 
 goal :  Arrow ( ( f :  Arrow ( ( x : {var_v20:int | true} ) -> {v:int | (p)( , x, v ) = (true)} ) ->  Arrow ( ( g :  Arrow ( ( x : {var_v21:int | true} ) -> {v:int | (q)( , x, v ) = (true)} ) ->  Arrow ( ( l : {var_v22:Ty_list int | true} ) -> {v:Ty_list int | Forall 
 	 
 Key =u Value = int
 Key =w Value = int
 Key =z Value = int
 Key =l1 Value = Ty_list int{ 
 	 Impl < 
 	 Conj <c (lmem)( , u, l ) = (true)
 	 , 
 	 Conj <c (lmem)( , z, v ) = (true)
 	 , (lmem)( , w, l1 ) = (true) >c  >c 
 	 
 	 Conj <c (p)( , u, w ) = (true)
 	 , (q)( , w, z ) = (true) >c  > }}
 take :  Arrow ( ( n : {var_v18:int | true} ) ->  Arrow ( ( l : {var_v19:Ty_list int | true} ) -> {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c (llen)(v) ==(n)
 	 , 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , l, u ) = (true) > >c  }}
 init :  Arrow ( ( l : {var_v17:Ty_list int | true} ) -> {v:Ty_list int | (llen)(v) ==((llen)(v) -- (1))}
 last :  Arrow ( ( l : {var_v16:Ty_list int | true} ) -> {v:int | (last)(l) ==(v)}
 null :  Arrow ( ( l : {var_v15:Ty_list int | true} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  (llen)(l) ==(0)}
 splitAt :  Arrow ( ( y : {var_v14:int | true} ) ->  Arrow ( ( l : {v:Ty_list int | (llen)(v) > (y)} ) -> {v:int plist | Forall 
 	 
 Key =H Value = Ty_list int
 Key =L Value = Ty_list int{ 
 	 Impl < 
 	 Conj <c (fst)(v) = (H)
 	 , (snd)(v) = (L) >c 
 	 
 	 Conj <c (llen)(H) ==(y)
 	 , (llen)(L) ==((llen)(l) -- (y)) >c  > }}
 combine :  Arrow ( ( l1 : {var_v13:Ty_list int | true} ) ->  Arrow ( ( l2 : {v:Ty_list int | (llen)(l1) ==(llen)(l2)} ) -> {v:Ty_list int ipair | Forall 
 	 
 Key =H Value = int ipair
 Key =L Value = int ipair{ 
 	 Conj <c (pllen)(v) ==(pllen)(l1)
 	 , 
 	 Conj <c (plhd)(v) = (H)
 	 , 
 	 Conj <c (pllast)(v) = (L)
 	 , 
 	 Conj <c (ppr1)(H) ==(lhd)(l1)
 	 , 
 	 Conj <c (ppr2)(H) ==(lhd)(l2)
 	 , 
 	 Conj <c (ppr1)(L) ==(last)(l1)
 	 , (ppr2)(L) ==(last)(l2) >c  >c  >c  >c  >c  >c  }}
 append :  Arrow ( ( l1 : {var_v11:Ty_list int | true} ) ->  Arrow ( ( l2 : {var_v12:Ty_list int | true} ) -> {v:Ty_list int | 
 	 Conj <c (llen)(v) ==((llen)(l1) + (llen)(l2))
 	 , 
 	 Conj <c (lhd)(v) ==(lhd)(l1)
 	 , 
 	 Conj <c (lsnd)(v) ==(lsnd)(l1)
 	 , 
 	 Conj <c (last)(v) ==(last)(l2)
 	 , (pen)(v) ==(pen)(l2) >c  >c  >c  >c }
 nth :  Arrow ( ( l : {var_v9:Ty_list int | true} ) ->  Arrow ( ( n : {var_v10:int | true} ) -> {v:int | 
 	 Conj <c (lmem)( , l, v ) = (true)
 	 , (nth)( , l, n ) ==(v) >c }
 tl :  Arrow ( ( l : {var_v8:Ty_list int | true} ) -> {v:Ty_list int | 
 	 Conj <c (llen)(v) ==((llen)(l) -- (1))
 	 , 
 	 Conj <c (last)(v) ==(last)(l)
 	 , 
 	 Conj <c (lhd)(v) ==(lsnd)(l)
 	 , (pen)(v) ==(pen)(l) >c  >c  >c }
 hd :  Arrow ( ( l : {var_v7:Ty_list int | true} ) -> {v:int | 
 	 Conj <c (lmem)( , l, v ) = (true)
 	 , (lhd)(l) ==(v) >c }
 cons :  Arrow ( ( x : {var_v5:int | true} ) ->  Arrow ( ( xs : {var_v6:Ty_list int | true} ) -> {v:Ty_list int | 
 	 Conj <c (llen)(v) ==((llen)(xs) + (1))
 	 , 
 	 Conj <c (lmem)( , v, x ) = (true)
 	 , 
 	 Conj <c (lhd)(v) ==(x)
 	 , 
 	 Conj <c (lsnd)(v) ==(lhd)(xs)
 	 , 
 	 Conj <c (last)(v) ==(last)(xs)
 	 , (pen)(v) ==(pen)(xs) >c  >c  >c  >c  >c }
 compare_lengths :  Arrow ( ( x : {var_v3:Ty_list int | true} ) ->  Arrow ( ( y : {var_v4:Ty_list int | true} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  (llen)(x) ==(llen)(y)}
 rev :  Arrow ( ( l : {var_v2:Ty_list int | true} ) -> {v:Ty_list int | 
 	 Conj <c (llen)(v) ==(llen)(l)
 	 , 
 	 Conj <c (lhd)(v) ==(last)(l)
 	 , 
 	 Conj <c (last)(v) ==(lhd)(l)
 	 , 
 	 Conj <c (lsnd)(v) ==(pen)(l)
 	 , (pen)(v) ==(lsnd)(v) >c  >c  >c  >c }
 length :  Arrow ( ( x : {var_v1:Ty_list int | true} ) -> {v:int | (llen)(x) ==(v)}
 ep : {var_v0:int | true}
 INITIAL SIGMA 
 
 TypeNames 
 
 plist
 ipair
 Qualifiers 
 
 Qual llen :  :-> Ty_list int :-> int
 Qual pllen :  :-> Ty_list int ipair :-> int
 Qual lmem :  :-> Ty_list int :-> int :-> Ty_bool
 Qual lhd :  :-> Ty_list int :-> int
 Qual plhd :  :-> Ty_list int ipair :-> int ipair
 Qual last :  :-> Ty_list int :-> int
 Qual pllast :  :-> Ty_list int ipair :-> int ipair
 Qual ppr1 :  :-> int ipair :-> int
 Qual ppr2 :  :-> int ipair :-> int
 Qual nth :  :-> Ty_list int :-> int :-> int
 Qual lsnd :  :-> Ty_list int :-> int
 Qual pen :  :-> Ty_list int :-> int
 Qual fst :  :-> int plist :-> Ty_list int
 Qual snd :  :-> int plist :-> Ty_list int
 Qual slen :  :-> Ty_list int a :-> int
 Qual ord :  :-> int :-> int :-> Ty_list int :-> Ty_bool
 Qual p :  :-> int :-> int :-> Ty_bool
 Qual q :  :-> int :-> int :-> Ty_bool
 Show ***********Calling S-FUNC synthesize***************
 Show Uncurried , f: Arrow ( ( x : {var_v20:int | true} ) -> {v:int | (p)( , x, v ) = (true)}, g: Arrow ( ( x : {var_v21:int | true} ) -> {v:int | (q)( , x, v ) = (true)}, l:{var_v22:Ty_list int | true} -> {v:Ty_list int | Forall 
 	 
 Key =u Value = int
 Key =w Value = int
 Key =z Value = int
 Key =l1 Value = Ty_list int{ 
 	 Impl < 
 	 Conj <c (lmem)( , u, l ) = (true)
 	 , 
 	 Conj <c (lmem)( , z, v ) = (true)
 	 , (lmem)( , w, l1 ) = (true) >c  >c 
 	 
 	 Conj <c (p)( , u, w ) = (true)
 	 , (q)( , w, z ) = (true) >c  > }}
 Decreasing Measure f
 Decreasing Type  Arrow ( ( x : {var_v20:int | true} ) -> {v:int | (p)( , x, v ) = (true)}
 Show Trying :: Top-level Match
 Show :: Synthesize Match {v:Ty_list int | Forall 
 	 
 Key =u Value = int
 Key =w Value = int
 Key =z Value = int
 Key =l1 Value = Ty_list int{ 
 	 Impl < 
 	 Conj <c (lmem)( , u, l ) = (true)
 	 , 
 	 Conj <c (lmem)( , z, v ) = (true)
 	 , (lmem)( , w, l1 ) = (true) >c  >c 
 	 
 	 Conj <c (p)( , u, w ) = (true)
 	 , (q)( , w, z ) = (true) >c  > }}
  EXPLORED Args.parser output 
 EXPLORED learningOn  true
 EXPLORED bidirectionality  true
 EXPLORED effect-filter  false
 EXPLORED specfile :: ./prudent_tests/hegel/Hoogle+/applyNAdd.spec
 EXPLORED goal Number :: 0
 EXPLORED Max path length :: 2
 EXPLORED Nested If :: 1typewhitespace var: ipair
semicolon
typewhitespace var: plist
semicolon
stexcwhitespace var: llen
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: pllen
whitespace colon
whitespace lbrace
var: ipair
rbrace
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: lmem
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: int
whitespace colon
whitespace var: bool
semicolon
stexcwhitespace var: lhd
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: plhd
whitespace colon
whitespace lbrace
var: ipair
rbrace
whitespace colon
whitespace var: ipair
semicolon
stexcwhitespace var: last
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: pllast
whitespace colon
whitespace lbrace
var: ipair
rbrace
whitespace colon
whitespace var: ipair
semicolon
stexcwhitespace var: ppr1
whitespace colon
whitespace var: ipair
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: ppr2
whitespace colon
whitespace var: ipair
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: nth
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: int
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: lsnd
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: pen
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: fst
whitespace colon
whitespace var: plist
whitespace colon
whitespace lbrace
var: int
rbrace
semicolon
stexcwhitespace var: snd
whitespace colon
whitespace var: plist
whitespace colon
whitespace lbrace
var: int
rbrace
semicolon
var: ep
whitespace colon
whitespace var: int
semicolon
var: length
whitespace colon
whitespace lparen
var: x
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace var: llen
whitespace lparen
var: x
rparen
whitespace equalopwhitespace var: v
rcurly
semicolon
whitespace var: rev
whitespace colon
whitespace lparen
var: l
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace pipe
whitespace whitespace var: llen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: llen
whitespace lparen
var: l
rparen
whitespace conjwhitespace var: lhd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: last
whitespace lparen
var: l
rparen
whitespace conjwhitespace var: last
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: lhd
whitespace lparen
var: l
rparen
whitespace conjwhitespace var: lsnd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: pen
whitespace lparen
var: l
rparen
whitespace conjwhitespace var: pen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: lsnd
whitespace lparen
var: v
rparen
whitespace rcurly
semicolon
var: compare_lengths
whitespace colon
whitespace lparen
var: x
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lparen
var: y
colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace var: bool
whitespace pipe
whitespace lbrace
var: v
equaloptruerbrace
whitespace iffwhitespace lparen
var: llen
whitespace lparen
var: x
rparen
whitespace equalopwhitespace var: llen
whitespace lparen
var: y
rparen
rparen
rcurly
semicolon
var: cons
whitespace colon
whitespace lparen
var: x
whitespace colon
whitespace var: int
rparen
whitespace arrow
whitespace lparen
var: xs
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace pipe
whitespace var: llen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: llen
whitespace lparen
var: xs
rparen
whitespace pluswhitespace int: 1
whitespace conjwhitespace var: lmem
whitespace lparen
var: v
comma
whitespace var: x
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace var: lhd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: x
whitespace conjwhitespace var: lsnd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: lhd
whitespace lparen
var: xs
rparen
whitespace conjwhitespace var: last
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: last
whitespace lparen
var: xs
rparen
whitespace conjwhitespace var: pen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: pen
whitespace lparen
var: xs
rparen
whitespace rcurly
semicolon
var: hd
whitespace colon
whitespace lparen
var: l
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace var: lmem
whitespace lparen
var: l
comma
whitespace var: v
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace var: lhd
whitespace lparen
var: l
rparen
whitespace equalopwhitespace var: v
whitespace whitespace rcurly
semicolon
var: tl
whitespace colon
whitespace lparen
var: l
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace pipe
whitespace var: llen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: llen
whitespace lparen
var: l
rparen
whitespace ar-minuswhitespace int: 1
whitespace conjwhitespace var: last
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: last
whitespace lparen
var: l
rparen
whitespace conjwhitespace var: lhd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: lsnd
whitespace lparen
var: l
rparen
whitespace conjwhitespace var: pen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: pen
whitespace lparen
var: l
rparen
whitespace rcurly
semicolon
var: nth
whitespace colon
whitespace lparen
var: l
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lparen
var: n
whitespace colon
whitespace var: int
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace var: lmem
whitespace lparen
var: l
comma
whitespace var: v
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace var: nth
whitespace lparen
var: l
comma
whitespace var: n
rparen
whitespace equalopwhitespace var: v
whitespace whitespace rcurly
semicolon
var: append
whitespace colon
whitespace lparen
var: l1
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lparen
var: l2
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace pipe
whitespace whitespace var: llen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: llen
whitespace lparen
var: l1
rparen
whitespace pluswhitespace var: llen
whitespace lparen
var: l2
rparen
whitespace conjwhitespace var: lhd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: lhd
whitespace lparen
var: l1
rparen
whitespace conjwhitespace var: lsnd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: lsnd
whitespace lparen
var: l1
rparen
whitespace conjwhitespace var: last
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: last
whitespace lparen
var: l2
rparen
whitespace conjwhitespace var: pen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: pen
whitespace lparen
var: l2
rparen
whitespace rcurly
semicolon
var: combine
whitespace colon
whitespace lparen
var: l1
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lparen
var: l2
whitespace colon
whitespace lcurly
var: v
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace pipe
whitespace var: llen
whitespace lparen
var: l1
rparen
whitespace equalopwhitespace var: llen
whitespace lparen
var: l2
rparen
rcurly
rparen
whitespace arrow
whitespace whitespace lcurly
var: v
whitespace colon
whitespace lbrace
var: ipair
rbrace
whitespace pipe
whitespace lambdalparen
var: H
whitespace colon
whitespace var: ipair
rparen
comma
whitespace lparen
var: L
whitespace colon
whitespace var: ipair
rparen
dotwhitespace var: pllen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: pllen
whitespace lparen
var: l1
rparen
whitespace conjwhitespace var: plhd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: H
whitespace conjwhitespace var: pllast
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: L
whitespace conjwhitespace var: ppr1
whitespace lparen
var: H
rparen
whitespace equalopwhitespace var: lhd
whitespace lparen
var: l1
rparen
whitespace conjwhitespace var: ppr2
whitespace lparen
var: H
rparen
whitespace equalopwhitespace var: lhd
whitespace lparen
var: l2
rparen
whitespace conjwhitespace var: ppr1
whitespace lparen
var: L
rparen
whitespace equalopwhitespace var: last
whitespace lparen
var: l1
rparen
whitespace conjwhitespace var: ppr2
whitespace lparen
var: L
rparen
whitespace equalopwhitespace var: last
whitespace lparen
var: l2
rparen
whitespace whitespace rcurly
semicolon
var: splitAt
whitespace colon
whitespace lparen
var: y
colon
var: int
rparen
whitespace arrow
whitespace lparen
var: l
whitespace colon
whitespace lcurly
whitespace var: v
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace pipe
whitespace var: llen
whitespace lparen
var: v
rparen
whitespace lessthanopwhitespace var: y
rcurly
rparen
whitespace arrow
whitespace whitespace lcurly
var: v
colon
var: plist
whitespace pipe
whitespace lambdalparen
var: H
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
comma
whitespace lparen
var: L
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
dotwhitespace lparen
var: fst
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: H
whitespace conjwhitespace var: snd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: L
rparen
whitespace implieswhitespace whitespace var: llen
whitespace lparen
var: H
rparen
whitespace equalopwhitespace var: y
whitespace conjwhitespace var: llen
whitespace lparen
var: L
rparen
whitespace equalopwhitespace var: llen
whitespace lparen
var: l
rparen
whitespace ar-minuswhitespace var: y
whitespace whitespace rcurly
semicolon
var: null
whitespace colon
whitespace lparen
var: l
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace var: bool
whitespace pipe
whitespace lbrace
var: v
equaloptruerbrace
whitespace iffwhitespace var: llen
whitespace lparen
var: l
rparen
whitespace equalopwhitespace int: 0
rcurly
semicolon
var: last
whitespace colon
whitespace lparen
var: l
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace var: last
whitespace lparen
var: l
rparen
whitespace equalopwhitespace var: v
rcurly
semicolon
whitespace var: init
whitespace colon
whitespace lparen
var: l
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace pipe
whitespace var: llen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: llen
whitespace lparen
var: v
rparen
whitespace ar-minusint: 1
rcurly
semicolon
whitespace var: take
whitespace colon
whitespace lparen
var: n
whitespace colon
whitespace var: int
rparen
whitespace arrow
whitespace lparen
var: l
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace pipe
whitespace lambdalparen
var: u
whitespace colon
whitespace var: int
rparen
dotwhitespace whitespace var: llen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: n
whitespace conjwhitespace whitespace lparen
var: lmem
whitespace lparen
var: v
comma
whitespace var: u
rparen
whitespace equalopwhitespace truerparen
whitespace implieswhitespace var: lmem
whitespace lparen
var: l
comma
whitespace var: u
rparen
whitespace equalopwhitespace truercurly
semicolon
whitespace whitespace var: goal
whitespace var: p

  EXPLORED Args.parser output 
 EXPLORED learningOn  true
 EXPLORED bidirectionality  true
 EXPLORED effect-filter  false
 EXPLORED specfile :: ./prudent_tests/hegel/Hoogle+/containsEdge.spec
 EXPLORED goal Number :: 0
 EXPLORED Max path length :: 2
 EXPLORED Nested If :: 1typewhitespace var: ipair
semicolon
typewhitespace var: plist
semicolon
stexcwhitespace var: llen
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: pllen
whitespace colon
whitespace lbrace
var: ipair
rbrace
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: lmem
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: int
whitespace colon
whitespace var: bool
semicolon
stexcwhitespace var: lhd
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: plhd
whitespace colon
whitespace lbrace
var: ipair
rbrace
whitespace colon
whitespace var: ipair
semicolon
stexcwhitespace var: last
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: pllast
whitespace colon
whitespace lbrace
var: ipair
rbrace
whitespace colon
whitespace var: ipair
semicolon
stexcwhitespace var: ppr1
whitespace colon
whitespace var: ipair
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: ppr2
whitespace colon
whitespace var: ipair
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: nth
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: int
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: lsnd
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: pen
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: fst
whitespace colon
whitespace var: plist
whitespace colon
whitespace lbrace
var: int
rbrace
semicolon
stexcwhitespace var: snd
whitespace colon
whitespace var: plist
whitespace colon
whitespace lbrace
var: int
rbrace
semicolon
var: ep
whitespace colon
whitespace var: int
semicolon
var: length
whitespace colon
whitespace lparen
var: x
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace var: llen
whitespace lparen
var: x
rparen
whitespace equalopwhitespace var: v
rcurly
semicolon
whitespace var: rev
whitespace colon
whitespace lparen
var: l
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace pipe
whitespace whitespace var: llen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: llen
whitespace lparen
var: l
rparen
whitespace conjwhitespace var: lhd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: last
whitespace lparen
var: l
rparen
whitespace conjwhitespace var: last
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: lhd
whitespace lparen
var: l
rparen
whitespace conjwhitespace var: lsnd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: pen
whitespace lparen
var: l
rparen
whitespace conjwhitespace var: pen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: lsnd
whitespace lparen
var: v
rparen
whitespace rcurly
semicolon
var: compare_lengths
whitespace colon
whitespace lparen
var: x
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lparen
var: y
colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace var: bool
whitespace pipe
whitespace lbrace
var: v
equaloptruerbrace
whitespace iffwhitespace lparen
var: llen
whitespace lparen
var: x
rparen
whitespace equalopwhitespace var: llen
whitespace lparen
var: y
rparen
rparen
rcurly
semicolon
var: cons
whitespace colon
whitespace lparen
var: x
whitespace colon
whitespace var: int
rparen
whitespace arrow
whitespace lparen
var: xs
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace pipe
whitespace var: llen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: llen
whitespace lparen
var: xs
rparen
whitespace pluswhitespace int: 1
whitespace conjwhitespace var: lmem
whitespace lparen
var: v
comma
whitespace var: x
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace var: lhd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: x
whitespace conjwhitespace var: lsnd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: lhd
whitespace lparen
var: xs
rparen
whitespace conjwhitespace var: last
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: last
whitespace lparen
var: xs
rparen
whitespace conjwhitespace var: pen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: pen
whitespace lparen
var: xs
rparen
whitespace rcurly
semicolon
var: hd
whitespace colon
whitespace lparen
var: l
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace var: lmem
whitespace lparen
var: l
comma
whitespace var: v
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace var: lhd
whitespace lparen
var: l
rparen
whitespace equalopwhitespace var: v
whitespace whitespace rcurly
semicolon
var: tl
whitespace colon
whitespace lparen
var: l
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace pipe
whitespace var: llen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: llen
whitespace lparen
var: l
rparen
whitespace ar-minuswhitespace int: 1
whitespace conjwhitespace var: last
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: last
whitespace lparen
var: l
rparen
whitespace conjwhitespace var: lhd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: lsnd
whitespace lparen
var: l
rparen
whitespace conjwhitespace var: pen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: pen
whitespace lparen
var: l
rparen
whitespace rcurly
semicolon
var: nth
whitespace colon
whitespace lparen
var: l
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lparen
var: n
whitespace colon
whitespace var: int
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace var: lmem
whitespace lparen
var: l
comma
whitespace var: v
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace var: nth
whitespace lparen
var: l
comma
whitespace var: n
rparen
whitespace equalopwhitespace var: v
whitespace whitespace rcurly
semicolon
var: append
whitespace colon
whitespace lparen
var: l1
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lparen
var: l2
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace pipe
whitespace whitespace var: llen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: llen
whitespace lparen
var: l1
rparen
whitespace pluswhitespace var: llen
whitespace lparen
var: l2
rparen
whitespace conjwhitespace var: lhd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: lhd
whitespace lparen
var: l1
rparen
whitespace conjwhitespace var: lsnd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: lsnd
whitespace lparen
var: l1
rparen
whitespace conjwhitespace var: last
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: last
whitespace lparen
var: l2
rparen
whitespace conjwhitespace var: pen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: pen
whitespace lparen
var: l2
rparen
whitespace rcurly
semicolon
var: combine
whitespace colon
whitespace lparen
var: l1
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lparen
var: l2
whitespace colon
whitespace lcurly
var: v
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace pipe
whitespace var: llen
whitespace lparen
var: l1
rparen
whitespace equalopwhitespace var: llen
whitespace lparen
var: l2
rparen
rcurly
rparen
whitespace arrow
whitespace whitespace lcurly
var: v
whitespace colon
whitespace lbrace
var: ipair
rbrace
whitespace pipe
whitespace lambdalparen
var: H
whitespace colon
whitespace var: ipair
rparen
comma
whitespace lparen
var: L
whitespace colon
whitespace var: ipair
rparen
dotwhitespace var: pllen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: pllen
whitespace lparen
var: l1
rparen
whitespace conjwhitespace var: plhd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: H
whitespace conjwhitespace var: pllast
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: L
whitespace conjwhitespace var: ppr1
whitespace lparen
var: H
rparen
whitespace equalopwhitespace var: lhd
whitespace lparen
var: l1
rparen
whitespace conjwhitespace var: ppr2
whitespace lparen
var: H
rparen
whitespace equalopwhitespace var: lhd
whitespace lparen
var: l2
rparen
whitespace conjwhitespace var: ppr1
whitespace lparen
var: L
rparen
whitespace equalopwhitespace var: last
whitespace lparen
var: l1
rparen
whitespace conjwhitespace var: ppr2
whitespace lparen
var: L
rparen
whitespace equalopwhitespace var: last
whitespace lparen
var: l2
rparen
whitespace whitespace rcurly
semicolon
var: splitAt
whitespace colon
whitespace lparen
var: y
colon
var: int
rparen
whitespace arrow
whitespace lparen
var: l
whitespace colon
whitespace lcurly
whitespace var: v
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace pipe
whitespace var: llen
whitespace lparen
var: v
rparen
whitespace lessthanopwhitespace var: y
rcurly
rparen
whitespace arrow
whitespace whitespace lcurly
var: v
colon
var: plist
whitespace pipe
whitespace lambdalparen
var: H
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
comma
whitespace lparen
var: L
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
dotwhitespace lparen
var: fst
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: H
whitespace conjwhitespace var: snd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: L
rparen
whitespace implieswhitespace whitespace var: llen
whitespace lparen
var: H
rparen
whitespace equalopwhitespace var: y
whitespace conjwhitespace var: llen
whitespace lparen
var: L
rparen
whitespace equalopwhitespace var: llen
whitespace lparen
var: l
rparen
whitespace ar-minuswhitespace var: y
whitespace whitespace rcurly
semicolon
var: null
whitespace colon
whitespace lparen
var: l
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace var: bool
whitespace pipe
whitespace lbrace
var: v
equaloptruerbrace
whitespace iffwhitespace var: llen
whitespace lparen
var: l
rparen
whitespace equalopwhitespace int: 0
rcurly
semicolon
var: last
whitespace colon
whitespace lparen
var: l
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace var: last
whitespace lparen
var: l
rparen
whitespace equalopwhitespace var: v
rcurly
semicolon
whitespace var: init
whitespace colon
whitespace lparen
var: l
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace pipe
whitespace var: llen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: llen
whitespace lparen
var: v
rparen
whitespace ar-minusint: 1
rcurly
semicolon
whitespace var: take
whitespace colon
whitespace lparen
var: n
whitespace colon
whitespace var: int
rparen
whitespace arrow
whitespace lparen
var: l
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace pipe
whitespace lambdalparen
var: u
whitespace colon
whitespace var: int
rparen
dotwhitespace whitespace var: llen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: n
whitespace conjwhitespace whitespace lparen
var: lmem
whitespace lparen
var: v
comma
whitespace var: u
rparen
whitespace equalopwhitespace truerparen
whitespace implieswhitespace var: lmem
whitespace lparen
var: l
comma
whitespace var: u
rparen
whitespace equalopwhitespace truercurly
semicolon
whitespace var: goal
whitespace colon
whitespace lparen
var: xs
whitespace colon
whitespace var: int
rparen
whitespace arrow
whitespace var: y
whitespace colon

  EXPLORED Args.parser output 
 EXPLORED learningOn  true
 EXPLORED bidirectionality  true
 EXPLORED effect-filter  false
 EXPLORED specfile :: ./prudent_tests/hegel/Hoogle+/splitAt.spec
 EXPLORED goal Number :: 0
 EXPLORED Max path length :: 2
 EXPLORED Nested If :: 1typewhitespace var: ipair
semicolon
typewhitespace var: plist
semicolon
stexcwhitespace var: llen
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: pllen
whitespace colon
whitespace lbrace
var: ipair
rbrace
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: lmem
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: int
whitespace colon
whitespace var: bool
semicolon
stexcwhitespace var: lhd
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: plhd
whitespace colon
whitespace lbrace
var: ipair
rbrace
whitespace colon
whitespace var: ipair
semicolon
stexcwhitespace var: last
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: pllast
whitespace colon
whitespace lbrace
var: ipair
rbrace
whitespace colon
whitespace var: ipair
semicolon
stexcwhitespace var: ppr1
whitespace colon
whitespace var: ipair
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: ppr2
whitespace colon
whitespace var: ipair
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: nth
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: int
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: lsnd
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: pen
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: fst
whitespace colon
whitespace var: plist
whitespace colon
whitespace lbrace
var: int
rbrace
semicolon
stexcwhitespace var: snd
whitespace colon
whitespace var: plist
whitespace colon
whitespace lbrace
var: int
rbrace
semicolon
var: ep
whitespace colon
whitespace var: int
semicolon
var: length
whitespace colon
whitespace lparen
var: x
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace var: llen
whitespace lparen
var: x
rparen
whitespace equalopwhitespace var: v
rcurly
semicolon
whitespace var: rev
whitespace colon
whitespace lparen
var: l
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace pipe
whitespace whitespace var: llen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: llen
whitespace lparen
var: l
rparen
whitespace conjwhitespace var: lhd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: last
whitespace lparen
var: l
rparen
whitespace conjwhitespace var: last
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: lhd
whitespace lparen
var: l
rparen
whitespace conjwhitespace var: lsnd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: pen
whitespace lparen
var: l
rparen
whitespace conjwhitespace var: pen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: lsnd
whitespace lparen
var: v
rparen
whitespace rcurly
semicolon
var: compare_lengths
whitespace colon
whitespace lparen
var: x
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lparen
var: y
colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace var: bool
whitespace pipe
whitespace lbrace
var: v
equaloptruerbrace
whitespace iffwhitespace lparen
var: llen
whitespace lparen
var: x
rparen
whitespace equalopwhitespace var: llen
whitespace lparen
var: y
rparen
rparen
rcurly
semicolon
var: cons
whitespace colon
whitespace lparen
var: x
whitespace colon
whitespace var: int
rparen
whitespace arrow
whitespace lparen
var: xs
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace pipe
whitespace var: llen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: llen
whitespace lparen
var: xs
rparen
whitespace pluswhitespace int: 1
whitespace conjwhitespace var: lmem
whitespace lparen
var: v
comma
whitespace var: x
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace var: lhd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: x
whitespace conjwhitespace var: lsnd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: lhd
whitespace lparen
var: xs
rparen
whitespace conjwhitespace var: last
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: last
whitespace lparen
var: xs
rparen
whitespace conjwhitespace var: pen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: pen
whitespace lparen
var: xs
rparen
whitespace rcurly
semicolon
var: hd
whitespace colon
whitespace lparen
var: l
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace var: lmem
whitespace lparen
var: l
comma
whitespace var: v
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace var: lhd
whitespace lparen
var: l
rparen
whitespace equalopwhitespace var: v
whitespace whitespace rcurly
semicolon
var: tl
whitespace colon
whitespace lparen
var: l
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace pipe
whitespace var: llen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: llen
whitespace lparen
var: l
rparen
whitespace ar-minuswhitespace int: 1
whitespace conjwhitespace var: last
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: last
whitespace lparen
var: l
rparen
whitespace conjwhitespace var: lhd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: lsnd
whitespace lparen
var: l
rparen
whitespace conjwhitespace var: pen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: pen
whitespace lparen
var: l
rparen
whitespace rcurly
semicolon
var: nth
whitespace colon
whitespace lparen
var: l
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lparen
var: n
whitespace colon
whitespace var: int
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace var: lmem
whitespace lparen
var: l
comma
whitespace var: v
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace var: nth
whitespace lparen
var: l
comma
whitespace var: n
rparen
whitespace equalopwhitespace var: v
whitespace whitespace rcurly
semicolon
var: append
whitespace colon
whitespace lparen
var: l1
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lparen
var: l2
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace pipe
whitespace whitespace var: llen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: llen
whitespace lparen
var: l1
rparen
whitespace pluswhitespace var: llen
whitespace lparen
var: l2
rparen
whitespace conjwhitespace var: lhd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: lhd
whitespace lparen
var: l1
rparen
whitespace conjwhitespace var: lsnd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: lsnd
whitespace lparen
var: l1
rparen
whitespace conjwhitespace var: last
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: last
whitespace lparen
var: l2
rparen
whitespace conjwhitespace var: pen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: pen
whitespace lparen
var: l2
rparen
whitespace rcurly
semicolon
var: combine
whitespace colon
whitespace lparen
var: l1
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lparen
var: l2
whitespace colon
whitespace lcurly
var: v
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace pipe
whitespace var: llen
whitespace lparen
var: l1
rparen
whitespace equalopwhitespace var: llen
whitespace lparen
var: l2
rparen
rcurly
rparen
whitespace arrow
whitespace whitespace lcurly
var: v
whitespace colon
whitespace lbrace
var: ipair
rbrace
whitespace pipe
whitespace lambdalparen
var: H
whitespace colon
whitespace var: ipair
rparen
comma
whitespace lparen
var: L
whitespace colon
whitespace var: ipair
rparen
dotwhitespace var: pllen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: pllen
whitespace lparen
var: l1
rparen
whitespace conjwhitespace var: plhd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: H
whitespace conjwhitespace var: pllast
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: L
whitespace conjwhitespace var: ppr1
whitespace lparen
var: H
rparen
whitespace equalopwhitespace var: lhd
whitespace lparen
var: l1
rparen
whitespace conjwhitespace var: ppr2
whitespace lparen
var: H
rparen
whitespace equalopwhitespace var: lhd
whitespace lparen
var: l2
rparen
whitespace conjwhitespace var: ppr1
whitespace lparen
var: L
rparen
whitespace equalopwhitespace var: last
whitespace lparen
var: l1
rparen
whitespace conjwhitespace var: ppr2
whitespace lparen
var: L
rparen
whitespace equalopwhitespace var: last
whitespace lparen
var: l2
rparen
whitespace whitespace rcurly
semicolon
var: splitAt
whitespace colon
whitespace lparen
var: y
colon
var: int
rparen
whitespace arrow
whitespace lparen
var: l
whitespace colon
whitespace lcurly
whitespace var: v
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace pipe
whitespace var: llen
whitespace lparen
var: v
rparen
whitespace lessthanopwhitespace var: y
rcurly
rparen
whitespace arrow
whitespace whitespace lcurly
var: v
colon
var: plist
whitespace pipe
whitespace lambdalparen
var: H
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
comma
whitespace lparen
var: L
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
dotwhitespace lparen
var: fst
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: H
whitespace conjwhitespace var: snd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: L
rparen
whitespace implieswhitespace whitespace var: llen
whitespace lparen
var: H
rparen
whitespace equalopwhitespace var: y
whitespace conjwhitespace var: llen
whitespace lparen
var: L
rparen
whitespace equalopwhitespace var: llen
whitespace lparen
var: l
rparen
whitespace ar-minuswhitespace var: y
whitespace whitespace rcurly
semicolon
var: null
whitespace colon
whitespace lparen
var: l
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace var: bool
whitespace pipe
whitespace lbrace
var: v
equaloptruerbrace
whitespace iffwhitespace var: llen
whitespace lparen
var: l
rparen
whitespace equalopwhitespace int: 0
rcurly
semicolon
var: last
whitespace colon
whitespace lparen
var: l
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace var: last
whitespace lparen
var: l
rparen
whitespace equalopwhitespace var: v
rcurly
semicolon
whitespace var: init
whitespace colon
whitespace lparen
var: l
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace pipe
whitespace var: llen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: llen
whitespace lparen
var: v
rparen
whitespace ar-minusint: 1
rcurly
semicolon
whitespace var: take
whitespace colon
whitespace lparen
var: n
whitespace colon
whitespace var: int
rparen
whitespace arrow
whitespace lparen
var: l
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace pipe
whitespace lambdalparen
var: u
whitespace colon
whitespace var: int
rparen
dotwhitespace whitespace var: llen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: n
whitespace conjwhitespace whitespace lparen
var: lmem
whitespace lparen
var: v
comma
whitespace var: u
rparen
whitespace equalopwhitespace truerparen
whitespace implieswhitespace var: lmem
whitespace lparen
var: l
comma
whitespace var: u
rparen
whitespace equalopwhitespace truercurly
semicolon
whitespace var: goal
whitespace colon
whitespace lparen
var: x
colon
var: int
rparen
whitespace arrow
whitespace lparen
var: y
whitespace colon
whitespace var: int
rparen
whitespace arrow
whitespace lparen
var: xs
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: plist
whitespace pipe
whitespace lambdalparen
var: f
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
comma
whitespace lparen
var: sn
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
dotwhitespace var: f
whitespace equalopwhitespace var: fst
whitespace lparen
var: v
rparen
whitespace conjwhitespace var: sn
whitespace equalopwhitespace var: snd
whitespace lparen
var: v
rparen
whitespace implieswhitespace lparen
notwhitespace lparen
var: len
whitespace lparen
var: f
rparen
whitespace lessthanopwhitespace var: x
rparen
whitespace conjwhitespace notwhitespace lparen
var: len
whitespace lparen
var: sn
rparen
whitespace lessthanopwhitespace var: len
whitespace lparen
var: xs
rparen
whitespace minuswhitespace var: y
rparen
whitespace disjwhitespace var: len
whitespace lparen
var: sn
rparen
whitespace equalopwhitespace int: 0
whitespace conjwhitespace lambdalparen
var: u
whitespace colon
whitespace var: a
rparen
dotwhitespace var: mem
whitespace lparen
var: f
comma
whitespace var: u
rparen
whitespace equalopwhitespace truewhitespace implieswhitespace var: mem
whitespace lparen
var: xs
comma
whitespace var: u
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace lambdalparen
var: u
whitespace colon
whitespace var: a
rparen
dotwhitespace var: mem
whitespace lparen
var: sn
comma
whitespace var: u
rparen
whitespace equalopwhitespace truewhitespace implieswhitespace var: mem
whitespace lparen
var: xs
comma
whitespace var: u
rparen
whitespace equalopwhitespace truerparen
rcurly
semicolon
RelSpec {  SRs ;  PRs ;  TSs  
 Assume false
 name ep : 
 params :
 Type {var_v0:int | true} 
 Assume false
 name length : 
 params :
 Type  Arrow ( ( x : {var_v1:Ty_list int | true} ) -> {v:int | (llen)(x) ==(v)} 
 Assume false
 name rev : 
 params :
 Type  Arrow ( ( l : {var_v2:Ty_list int | true} ) -> {v:Ty_list int | 
 	 Conj <c (llen)(v) ==(llen)(l)
 	 , 
 	 Conj <c (lhd)(v) ==(last)(l)
 	 , 
 	 Conj <c (last)(v) ==(lhd)(l)
 	 , 
 	 Conj <c (lsnd)(v) ==(pen)(l)
 	 , (pen)(v) ==(lsnd)(v) >c  >c  >c  >c } 
 Assume false
 name compare_lengths : 
 params :
 Type  Arrow ( ( x : {var_v3:Ty_list int | true} ) ->  Arrow ( ( y : {var_v4:Ty_list int | true} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  (llen)(x) ==(llen)(y)} 
 Assume false
 name cons : 
 params :
 Type  Arrow ( ( x : {var_v5:int | true} ) ->  Arrow ( ( xs : {var_v6:Ty_list int | true} ) -> {v:Ty_list int | 
 	 Conj <c (llen)(v) ==((llen)(xs) + (1))
 	 , 
 	 Conj <c (lmem)( , v, x ) = (true)
 	 , 
 	 Conj <c (lhd)(v) ==(x)
 	 , 
 	 Conj <c (lsnd)(v) ==(lhd)(xs)
 	 , 
 	 Conj <c (last)(v) ==(last)(xs)
 	 , (pen)(v) ==(pen)(xs) >c  >c  >c  >c  >c } 
 Assume false
 name hd : 
 params :
 Type  Arrow ( ( l : {var_v7:Ty_list int | true} ) -> {v:int | 
 	 Conj <c (lmem)( , l, v ) = (true)
 	 , (lhd)(l) ==(v) >c } 
 Assume false
 name tl : 
 params :
 Type  Arrow ( ( l : {var_v8:Ty_list int | true} ) -> {v:Ty_list int | 
 	 Conj <c (llen)(v) ==((llen)(l) -- (1))
 	 , 
 	 Conj <c (last)(v) ==(last)(l)
 	 , 
 	 Conj <c (lhd)(v) ==(lsnd)(l)
 	 , (pen)(v) ==(pen)(l) >c  >c  >c } 
 Assume false
 name nth : 
 params :
 Type  Arrow ( ( l : {var_v9:Ty_list int | true} ) ->  Arrow ( ( n : {var_v10:int | true} ) -> {v:int | 
 	 Conj <c (lmem)( , l, v ) = (true)
 	 , (nth)( , l, n ) ==(v) >c } 
 Assume false
 name append : 
 params :
 Type  Arrow ( ( l1 : {var_v11:Ty_list int | true} ) ->  Arrow ( ( l2 : {var_v12:Ty_list int | true} ) -> {v:Ty_list int | 
 	 Conj <c (llen)(v) ==((llen)(l1) + (llen)(l2))
 	 , 
 	 Conj <c (lhd)(v) ==(lhd)(l1)
 	 , 
 	 Conj <c (lsnd)(v) ==(lsnd)(l1)
 	 , 
 	 Conj <c (last)(v) ==(last)(l2)
 	 , (pen)(v) ==(pen)(l2) >c  >c  >c  >c } 
 Assume false
 name combine : 
 params :
 Type  Arrow ( ( l1 : {var_v13:Ty_list int | true} ) ->  Arrow ( ( l2 : {v:Ty_list int | (llen)(l1) ==(llen)(l2)} ) -> {v:Ty_list int ipair | Forall 
 	 
 Key =H Value = int ipair
 Key =L Value = int ipair{ 
 	 Conj <c (pllen)(v) ==(pllen)(l1)
 	 , 
 	 Conj <c (plhd)(v) = (H)
 	 , 
 	 Conj <c (pllast)(v) = (L)
 	 , 
 	 Conj <c (ppr1)(H) ==(lhd)(l1)
 	 , 
 	 Conj <c (ppr2)(H) ==(lhd)(l2)
 	 , 
 	 Conj <c (ppr1)(L) ==(last)(l1)
 	 , (ppr2)(L) ==(last)(l2) >c  >c  >c  >c  >c  >c  }} 
 Assume false
 name splitAt : 
 params :
 Type  Arrow ( ( y : {var_v14:int | true} ) ->  Arrow ( ( l : {v:Ty_list int | (llen)(v) > (y)} ) -> {v:int plist | Forall 
 	 
 Key =H Value = Ty_list int
 Key =L Value = Ty_list int{ 
 	 Impl < 
 	 Conj <c (fst)(v) = (H)
 	 , (snd)(v) = (L) >c 
 	 
 	 Conj <c (llen)(H) ==(y)
 	 , (llen)(L) ==((llen)(l) -- (y)) >c  > }} 
 Assume false
 name null : 
 params :
 Type  Arrow ( ( l : {var_v15:Ty_list int | true} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  (llen)(l) ==(0)} 
 Assume false
 name last : 
 params :
 Type  Arrow ( ( l : {var_v16:Ty_list int | true} ) -> {v:int | (last)(l) ==(v)} 
 Assume false
 name init : 
 params :
 Type  Arrow ( ( l : {var_v17:Ty_list int | true} ) -> {v:Ty_list int | (llen)(v) ==((llen)(v) -- (1))} 
 Assume false
 name take : 
 params :
 Type  Arrow ( ( n : {var_v18:int | true} ) ->  Arrow ( ( l : {var_v19:Ty_list int | true} ) -> {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c (llen)(v) ==(n)
 	 , 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , l, u ) = (true) > >c  }} 
 Assume false
 name goal : 
 params :
 Type  Arrow ( ( x : {var_v20:int | true} ) ->  Arrow ( ( y : {var_v21:int | true} ) ->  Arrow ( ( xs : {var_v22:Ty_list int | true} ) -> {v:int plist | Forall 
 	 
 Key =f Value = Ty_list int
 Key =sn Value = Ty_list int{ 
 	 Conj <c (f) = (fst)(v)
 	 , 
 	 Impl < (sn) = (snd)(v)
 	 
 	 Conj <c Negation (len)(f) > (x)
 	 , 
 Disj <d  Negation (len)(sn) > ((len)(xs) - (y))
 	,   
 	 Conj <c (len)(sn) ==(0)
 	 , Forall 
 	 
 Key =u Value = int a{ 
 	 Impl < (mem)( , f, u ) = (true)
 	 
 	 Conj <c (mem)( , xs, u ) = (true)
 	 , Forall 
 	 
 Key =u Value = int a{ 
 	 Impl < (mem)( , sn, u ) = (true)
 	 (mem)( , xs, u ) = (true) > } >c  > } >c >d  >c  > >c  }};  Formulas  }
 INITIAL GAMMA 
 
 goal :  Arrow ( ( x : {var_v20:int | true} ) ->  Arrow ( ( y : {var_v21:int | true} ) ->  Arrow ( ( xs : {var_v22:Ty_list int | true} ) -> {v:int plist | Forall 
 	 
 Key =f Value = Ty_list int
 Key =sn Value = Ty_list int{ 
 	 Conj <c (f) = (fst)(v)
 	 , 
 	 Impl < (sn) = (snd)(v)
 	 
 	 Conj <c Negation (len)(f) > (x)
 	 , 
 Disj <d  Negation (len)(sn) > ((len)(xs) - (y))
 	,   
 	 Conj <c (len)(sn) ==(0)
 	 , Forall 
 	 
 Key =u Value = int a{ 
 	 Impl < (mem)( , f, u ) = (true)
 	 
 	 Conj <c (mem)( , xs, u ) = (true)
 	 , Forall 
 	 
 Key =u Value = int a{ 
 	 Impl < (mem)( , sn, u ) = (true)
 	 (mem)( , xs, u ) = (true) > } >c  > } >c >d  >c  > >c  }}
 take :  Arrow ( ( n : {var_v18:int | true} ) ->  Arrow ( ( l : {var_v19:Ty_list int | true} ) -> {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c (llen)(v) ==(n)
 	 , 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , l, u ) = (true) > >c  }}
 init :  Arrow ( ( l : {var_v17:Ty_list int | true} ) -> {v:Ty_list int | (llen)(v) ==((llen)(v) -- (1))}
 last :  Arrow ( ( l : {var_v16:Ty_list int | true} ) -> {v:int | (last)(l) ==(v)}
 null :  Arrow ( ( l : {var_v15:Ty_list int | true} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  (llen)(l) ==(0)}
 splitAt :  Arrow ( ( y : {var_v14:int | true} ) ->  Arrow ( ( l : {v:Ty_list int | (llen)(v) > (y)} ) -> {v:int plist | Forall 
 	 
 Key =H Value = Ty_list int
 Key =L Value = Ty_list int{ 
 	 Impl < 
 	 Conj <c (fst)(v) = (H)
 	 , (snd)(v) = (L) >c 
 	 
 	 Conj <c (llen)(H) ==(y)
 	 , (llen)(L) ==((llen)(l) -- (y)) >c  > }}
 combine :  Arrow ( ( l1 : {var_v13:Ty_list int | true} ) ->  Arrow ( ( l2 : {v:Ty_list int | (llen)(l1) ==(llen)(l2)} ) -> {v:Ty_list int ipair | Forall 
 	 
 Key =H Value = int ipair
 Key =L Value = int ipair{ 
 	 Conj <c (pllen)(v) ==(pllen)(l1)
 	 , 
 	 Conj <c (plhd)(v) = (H)
 	 , 
 	 Conj <c (pllast)(v) = (L)
 	 , 
 	 Conj <c (ppr1)(H) ==(lhd)(l1)
 	 , 
 	 Conj <c (ppr2)(H) ==(lhd)(l2)
 	 , 
 	 Conj <c (ppr1)(L) ==(last)(l1)
 	 , (ppr2)(L) ==(last)(l2) >c  >c  >c  >c  >c  >c  }}
 append :  Arrow ( ( l1 : {var_v11:Ty_list int | true} ) ->  Arrow ( ( l2 : {var_v12:Ty_list int | true} ) -> {v:Ty_list int | 
 	 Conj <c (llen)(v) ==((llen)(l1) + (llen)(l2))
 	 , 
 	 Conj <c (lhd)(v) ==(lhd)(l1)
 	 , 
 	 Conj <c (lsnd)(v) ==(lsnd)(l1)
 	 , 
 	 Conj <c (last)(v) ==(last)(l2)
 	 , (pen)(v) ==(pen)(l2) >c  >c  >c  >c }
 nth :  Arrow ( ( l : {var_v9:Ty_list int | true} ) ->  Arrow ( ( n : {var_v10:int | true} ) -> {v:int | 
 	 Conj <c (lmem)( , l, v ) = (true)
 	 , (nth)( , l, n ) ==(v) >c }
 tl :  Arrow ( ( l : {var_v8:Ty_list int | true} ) -> {v:Ty_list int | 
 	 Conj <c (llen)(v) ==((llen)(l) -- (1))
 	 , 
 	 Conj <c (last)(v) ==(last)(l)
 	 , 
 	 Conj <c (lhd)(v) ==(lsnd)(l)
 	 , (pen)(v) ==(pen)(l) >c  >c  >c }
 hd :  Arrow ( ( l : {var_v7:Ty_list int | true} ) -> {v:int | 
 	 Conj <c (lmem)( , l, v ) = (true)
 	 , (lhd)(l) ==(v) >c }
 cons :  Arrow ( ( x : {var_v5:int | true} ) ->  Arrow ( ( xs : {var_v6:Ty_list int | true} ) -> {v:Ty_list int | 
 	 Conj <c (llen)(v) ==((llen)(xs) + (1))
 	 , 
 	 Conj <c (lmem)( , v, x ) = (true)
 	 , 
 	 Conj <c (lhd)(v) ==(x)
 	 , 
 	 Conj <c (lsnd)(v) ==(lhd)(xs)
 	 , 
 	 Conj <c (last)(v) ==(last)(xs)
 	 , (pen)(v) ==(pen)(xs) >c  >c  >c  >c  >c }
 compare_lengths :  Arrow ( ( x : {var_v3:Ty_list int | true} ) ->  Arrow ( ( y : {var_v4:Ty_list int | true} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  (llen)(x) ==(llen)(y)}
 rev :  Arrow ( ( l : {var_v2:Ty_list int | true} ) -> {v:Ty_list int | 
 	 Conj <c (llen)(v) ==(llen)(l)
 	 , 
 	 Conj <c (lhd)(v) ==(last)(l)
 	 , 
 	 Conj <c (last)(v) ==(lhd)(l)
 	 , 
 	 Conj <c (lsnd)(v) ==(pen)(l)
 	 , (pen)(v) ==(lsnd)(v) >c  >c  >c  >c }
 length :  Arrow ( ( x : {var_v1:Ty_list int | true} ) -> {v:int | (llen)(x) ==(v)}
 ep : {var_v0:int | true}
 INITIAL SIGMA 
 
 TypeNames 
 
 plist
 ipair
 Qualifiers 
 
 Qual llen :  :-> Ty_list int :-> int
 Qual pllen :  :-> Ty_list int ipair :-> int
 Qual lmem :  :-> Ty_list int :-> int :-> Ty_bool
 Qual lhd :  :-> Ty_list int :-> int
 Qual plhd :  :-> Ty_list int ipair :-> int ipair
 Qual last :  :-> Ty_list int :-> int
 Qual pllast :  :-> Ty_list int ipair :-> int ipair
 Qual ppr1 :  :-> int ipair :-> int
 Qual ppr2 :  :-> int ipair :-> int
 Qual nth :  :-> Ty_list int :-> int :-> int
 Qual lsnd :  :-> Ty_list int :-> int
 Qual pen :  :-> Ty_list int :-> int
 Qual fst :  :-> int plist :-> Ty_list int
 Qual snd :  :-> int plist :-> Ty_list int
 Show ***********Calling S-FUNC synthesize***************
 Show Uncurried , x:{var_v20:int | true}, y:{var_v21:int | true}, xs:{var_v22:Ty_list int | true} -> {v:int plist | Forall 
 	 
 Key =f Value = Ty_list int
 Key =sn Value = Ty_list int{ 
 	 Conj <c (f) = (fst)(v)
 	 , 
 	 Impl < (sn) = (snd)(v)
 	 
 	 Conj <c Negation (len)(f) > (x)
 	 , 
 Disj <d  Negation (len)(sn) > ((len)(xs) - (y))
 	,   
 	 Conj <c (len)(sn) ==(0)
 	 , Forall 
 	 
 Key =u Value = int a{ 
 	 Impl < (mem)( , f, u ) = (true)
 	 
 	 Conj <c (mem)( , xs, u ) = (true)
 	 , Forall 
 	 
 Key =u Value = int a{ 
 	 Impl < (mem)( , sn, u ) = (true)
 	 (mem)( , xs, u ) = (true) > } >c  > } >c >d  >c  > >c  }}
 Decreasing Measure x
 Decreasing Type {var_v20:int | true}
 Calculated Decreasing Predicate x > var_v20
 Calculated Decreased Goal Type  Arrow ( ( x1 : {var_v20:int | 
 	 Conj <c true
 	 , x > var_v20 >c } ) ->  Arrow ( ( y : {var_v21:int | true} ) ->  Arrow ( ( xs : {var_v22:Ty_list int | true} ) -> {v:int plist | Forall 
 	 
 Key =f Value = Ty_list int
 Key =sn Value = Ty_list int{ 
 	 Conj <c (f) = (fst)(v)
 	 , 
 	 Impl < (sn) = (snd)(v)
 	 
 	 Conj <c Negation (len)(f) > (x1)
 	 , 
 Disj <d  Negation (len)(sn) > ((len)(xs) - (y))
 	,   
 	 Conj <c (len)(sn) ==(0)
 	 , Forall 
 	 
 Key =u Value = int a{ 
 	 Impl < (mem)( , f, u ) = (true)
 	 
 	 Conj <c (mem)( , xs, u ) = (true)
 	 , Forall 
 	 
 Key =u Value = int a{ 
 	 Impl < (mem)( , sn, u ) = (true)
 	 (mem)( , xs, u ) = (true) > } >c  > } >c >d  >c  > >c  }}
 Show Trying :: Top-level Match
 Show :: Synthesize Match {v:int plist | Forall 
 	 
 Key =f Value = Ty_list int
 Key =sn Value = Ty_list int{ 
 	 Conj <c (f) = (fst)(v)
 	 , 
 	 Impl < (sn) = (snd)(v)
 	 
 	 Conj <c Negation (len)(f) > (x)
 	 , 
 Disj <d  Negation (len)(sn) > ((len)(xs) - (y))
 	,   
 	 Conj <c (len)(sn) ==(0)
 	 , Forall 
 	 
 Key =u Value = int a{ 
 	 Impl < (mem)( , f, u ) = (true)
 	 
 	 Conj <c (mem)( , xs, u ) = (true)
 	 , Forall 
 	 
 Key =u Value = int a{ 
 	 Impl < (mem)( , sn, u ) = (true)
 	 (mem)( , xs, u ) = (true) > } >c  > } >c >d  >c  > >c  }}
 Show :: List int
 Show :: Non List Case
 Match-case failed :: Try Top-level If-then-else 
 **********************************************
 iSynthesize If-THEN-ELSE {v:int plist | Forall 
 	 
 Key =f Value = Ty_list int
 Key =sn Value = Ty_list int{ 
 	 Conj <c (f) = (fst)(v)
 	 , 
 	 Impl < (sn) = (snd)(v)
 	 
 	 Conj <c Negation (len)(f) > (x)
 	 , 
 Disj <d  Negation (len)(sn) > ((len)(xs) - (y))
 	,   
 	 Conj <c (len)(sn) ==(0)
 	 , Forall 
 	 
 Key =u Value = int a{ 
 	 Impl < (mem)( , f, u ) = (true)
 	 
 	 Conj <c (mem)( , xs, u ) = (true)
 	 , Forall 
 	 
 Key =u Value = int a{ 
 	 Impl < (mem)( , sn, u ) = (true)
 	 (mem)( , xs, u ) = (true) > } >c  > } >c >d  >c  > >c  }}
 **********************************************
  *********************Synthesizing the Guard*******************
 iSynthesize Boolean Guard {var_v23:Ty_bool | true}
  *********************Synthesizing the Guard*******************
 esynthesizeScalar for {var_v23:Ty_bool | true}
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
  *********************Guard Synthesized*******************
 iSynthesize Following Boolean Guards Found 
  ********************Guard Synthesized*******************
  If then else Failed :: Try without subdivision
 
  Entering Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  , 
 goal, 
 splitAt
 ############################################################
  Synthesizing the Function application Pure Component goal
  *************** Trying Arrow Component ************goal :  Arrow ( ( x1 : {var_v20:int | 
 	 Conj <c true
 	 , x > var_v20 >c } ) ->  Arrow ( ( y : {var_v21:int | true} ) ->  Arrow ( ( xs : {var_v22:Ty_list int | true} ) -> {v:int plist | Forall 
 	 
 Key =f Value = Ty_list int
 Key =sn Value = Ty_list int{ 
 	 Conj <c (f) = (fst)(v)
 	 , 
 	 Impl < (sn) = (snd)(v)
 	 
 	 Conj <c Negation (len)(f) > (x1)
 	 , 
 Disj <d  Negation (len)(sn) > ((len)(xs) - (y))
 	,   
 	 Conj <c (len)(sn) ==(0)
 	 , Forall 
 	 
 Key =u Value = int a{ 
 	 Impl < (mem)( , f, u ) = (true)
 	 
 	 Conj <c (mem)( , xs, u ) = (true)
 	 , Forall 
 	 
 Key =u Value = int a{ 
 	 Impl < (mem)( , sn, u ) = (true)
 	 (mem)( , xs, u ) = (true) > } >c  > } >c >d  >c  > >c  }}
  *************** Synthesizing Args ei : ti for ************goal
 ##################################################################################
  Synthesizing the 1th argument for Function goal
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v20:int | 
 	 Conj <c true
 	 , x > var_v20 >c }
 
 Enumerating a Scalar Term ep
 
 Type of the Scalar Term {var_v0:int | true}     
# of Final Z3 expressions 2
 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term x
 
 Type of the Scalar Term {var_v20:int | true}
 ################################################
 Skipping Variable x as it is bound variable for Cons constructor
 ################################################
 
 Enumerating a Scalar Term y
 
 Type of the Scalar Term {var_v21:int | true}     
# of Final Z3 expressions 2
 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 
 FaileD the subtype check T_vi <: T_goal
  Entering Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  , 
 last, 
 nth, 
 hd, 
 length
 ############################################################
  Synthesizing the Function application Pure Component last
  *************** Trying Arrow Component ************last :  Arrow ( ( l : {var_v16:Ty_list int | true} ) -> {v:int | (last)(l) ==(v)}
  *************** Synthesizing Args ei : ti for ************last
 ##################################################################################
  Synthesizing the 1th argument for Function last
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v16:Ty_list int | true}
 
 Enumerating a Scalar Term xs
 
 Type of the Scalar Term {var_v22:Ty_list int | true}
 ################################################
 Skipping Variable xs as it is bound variable for Cons constructor
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  *************** Synthesizing Args ei : Failed for some  arg
 ############################################################
  Synthesizing the Function application Pure Component nth
  *************** Trying Arrow Component ************nth :  Arrow ( ( l : {var_v9:Ty_list int | true} ) ->  Arrow ( ( n : {var_v10:int | true} ) -> {v:int | 
 	 Conj <c (lmem)( , l, v ) = (true)
 	 , (nth)( , l, n ) ==(v) >c }
  *************** Synthesizing Args ei : ti for ************nth
 ##################################################################################
  Synthesizing the 1th argument for Function nth
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v9:Ty_list int | true}
 
 Enumerating a Scalar Term xs
 
 Type of the Scalar Term {var_v22:Ty_list int | true}
 ################################################
 Skipping Variable xs as it is bound variable for Cons constructor
 ################################################
 
 Enumerating a Scalar Term l
 
 Type of the Scalar Term {var_v16:Ty_list int | true}
 ################################################
 Skipping Variable l As this a  Formal Parameter to the current function Call
 Outer Function calls nth
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  Synthesizing the 2th argument for Function nth
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v10:int | true}
 
 Enumerating a Scalar Term ep
 
 Type of the Scalar Term {var_v0:int | true}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term x
 
 Type of the Scalar Term {var_v20:int | true}
 ################################################
 Skipping Variable x as it is bound variable for Cons constructor
 ################################################
 
 Enumerating a Scalar Term y
 
 Type of the Scalar Term {var_v21:int | true}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 2th Args option for nth : y
 >>>>>>>>>>>>>>>>>>> 2th Args option for nth : ep
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  *************** Synthesizing Args ei : Failed for some  arg
 ############################################################
  Synthesizing the Function application Pure Component hd
  *************** Trying Arrow Component ************hd :  Arrow ( ( l : {var_v7:Ty_list int | true} ) -> {v:int | 
 	 Conj <c (lmem)( , l, v ) = (true)
 	 , (lhd)(l) ==(v) >c }
  *************** Synthesizing Args ei : ti for ************hd
 ##################################################################################
  Synthesizing the 1th argument for Function hd
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v7:Ty_list int | true}
 
 Enumerating a Scalar Term xs
 
 Type of the Scalar Term {var_v22:Ty_list int | true}
 ################################################
 Skipping Variable xs as it is bound variable for Cons constructor
 ################################################
 
 Enumerating a Scalar Term l
 
 Type of the Scalar Term {var_v9:Ty_list int | true}
 ################################################
 Skipping Variable l As this a  Formal Parameter to the current function Call
 Outer Function calls hd
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  *************** Synthesizing Args ei : Failed for some  arg
 ############################################################
  Synthesizing the Function application Pure Component length
  *************** Trying Arrow Component ************length :  Arrow ( ( x : {var_v1:Ty_list int | true} ) -> {v:int | (llen)(x) ==(v)}
  *************** Synthesizing Args ei : ti for ************length
 ##################################################################################
  Synthesizing the 1th argument for Function length
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v1:Ty_list int | true}
 
 Enumerating a Scalar Term xs
 
 Type of the Scalar Term {var_v22:Ty_list int | true}
 ################################################
 Skipping Variable xs as it is bound variable for Cons constructor
 ################################################
 
 Enumerating a Scalar Term l
 
 Type of the Scalar Term {var_v7:Ty_list int | true}
# of Final Z3 expressions 2
 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 1th Args option for length : l
  DEPTH vs MAX  1 vs 2
 ##################################################################################
  *************** Successfully Synthesized Args ei Forall i 
 1 th Argument Options for length
 EI l
 # of Possible Argument Options for length 1
 # of Possible Argument Options for length 1
 Possible Arg Options 
 EI l
 Apply Single Argument Case : f (ei) Case length
  Case : f (ei) Case length l
 Finding Already seen tree for apply length  (, l )
 Typechecking apply length  (, l )
 Against {var_v20:int | 
 	 Conj <c true
 	 , x > var_v20 >c }
 Typechecking the Term apply length  (, l )
 Against {var_v20:int | 
 	 Conj <c true
 	 , x > var_v20 >c }
 Argument l :: {var_v7:Ty_list int | true} | true
 AppType Type {v:int | (llen)(l) ==(v)}     
  EXPLORED Args.parser output 
 EXPLORED learningOn  true
 EXPLORED bidirectionality  true
 EXPLORED effect-filter  false
 EXPLORED specfile :: ./prudent_tests/hegel/Hoogle+/splitStr.spec
 EXPLORED goal Number :: 0
 EXPLORED Max path length :: 2
 EXPLORED Nested If :: 1typewhitespace var: ipair
semicolon
typewhitespace var: plist
semicolon
stexcwhitespace var: llen
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: pllen
whitespace colon
whitespace lbrace
var: ipair
rbrace
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: lmem
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: int
whitespace colon
whitespace var: bool
semicolon
stexcwhitespace var: lhd
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: plhd
whitespace colon
whitespace lbrace
var: ipair
rbrace
whitespace colon
whitespace var: ipair
semicolon
stexcwhitespace var: last
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: pllast
whitespace colon
whitespace lbrace
var: ipair
rbrace
whitespace colon
whitespace var: ipair
semicolon
stexcwhitespace var: ppr1
whitespace colon
whitespace var: ipair
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: ppr2
whitespace colon
whitespace var: ipair
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: nth
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: int
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: lsnd
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: pen
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: fst
whitespace colon
whitespace var: plist
whitespace colon
whitespace lbrace
var: int
rbrace
semicolon
stexcwhitespace var: snd
whitespace colon
whitespace var: plist
whitespace colon
whitespace lbrace
var: int
rbrace
semicolon
var: ep
whitespace colon
whitespace var: int
semicolon
var: length
whitespace colon
whitespace lparen
var: x
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace var: llen
whitespace lparen
var: x
rparen
whitespace equalopwhitespace var: v
rcurly
semicolon
whitespace var: rev
whitespace colon
whitespace lparen
var: l
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace pipe
whitespace whitespace var: llen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: llen
whitespace lparen
var: l
rparen
whitespace conjwhitespace var: lhd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: last
whitespace lparen
var: l
rparen
whitespace conjwhitespace var: last
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: lhd
whitespace lparen
var: l
rparen
whitespace conjwhitespace var: lsnd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: pen
whitespace lparen
var: l
rparen
whitespace conjwhitespace var: pen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: lsnd
whitespace lparen
var: v
rparen
whitespace rcurly
semicolon
var: compare_lengths
whitespace colon
whitespace lparen
var: x
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lparen
var: y
colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace var: bool
whitespace pipe
whitespace lbrace
var: v
equaloptruerbrace
whitespace iffwhitespace lparen
var: llen
whitespace lparen
var: x
rparen
whitespace equalopwhitespace var: llen
whitespace lparen
var: y
rparen
rparen
rcurly
semicolon
var: cons
whitespace colon
whitespace lparen
var: x
whitespace colon
whitespace var: int
rparen
whitespace arrow
whitespace lparen
var: xs
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace pipe
whitespace var: llen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: llen
whitespace lparen
var: xs
rparen
whitespace pluswhitespace int: 1
whitespace conjwhitespace var: lmem
whitespace lparen
var: v
comma
whitespace var: x
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace var: lhd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: x
whitespace conjwhitespace var: lsnd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: lhd
whitespace lparen
var: xs
rparen
whitespace conjwhitespace var: last
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: last
whitespace lparen
var: xs
rparen
whitespace conjwhitespace var: pen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: pen
whitespace lparen
var: xs
rparen
whitespace rcurly
semicolon
var: hd
whitespace colon
whitespace lparen
var: l
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace var: lmem
whitespace lparen
var: l
comma
whitespace var: v
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace var: lhd
whitespace lparen
var: l
rparen
whitespace equalopwhitespace var: v
whitespace whitespace rcurly
semicolon
var: tl
whitespace colon
whitespace lparen
var: l
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace pipe
whitespace var: llen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: llen
whitespace lparen
var: l
rparen
whitespace ar-minuswhitespace int: 1
whitespace conjwhitespace var: last
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: last
whitespace lparen
var: l
rparen
whitespace conjwhitespace var: lhd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: lsnd
whitespace lparen
var: l
rparen
whitespace conjwhitespace var: pen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: pen
whitespace lparen
var: l
rparen
whitespace rcurly
semicolon
var: nth
whitespace colon
whitespace lparen
var: l
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lparen
var: n
whitespace colon
whitespace var: int
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace var: lmem
whitespace lparen
var: l
comma
whitespace var: v
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace var: nth
whitespace lparen
var: l
comma
whitespace var: n
rparen
whitespace equalopwhitespace var: v
whitespace whitespace rcurly
semicolon
var: append
whitespace colon
whitespace lparen
var: l1
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lparen
var: l2
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace pipe
whitespace whitespace var: llen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: llen
whitespace lparen
var: l1
rparen
whitespace pluswhitespace var: llen
whitespace lparen
var: l2
rparen
whitespace conjwhitespace var: lhd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: lhd
whitespace lparen
var: l1
rparen
whitespace conjwhitespace var: lsnd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: lsnd
whitespace lparen
var: l1
rparen
whitespace conjwhitespace var: last
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: last
whitespace lparen
var: l2
rparen
whitespace conjwhitespace var: pen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: pen
whitespace lparen
var: l2
rparen
whitespace rcurly
semicolon
var: combine
whitespace colon
whitespace lparen
var: l1
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lparen
var: l2
whitespace colon
whitespace lcurly
var: v
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace pipe
whitespace var: llen
whitespace lparen
var: l1
rparen
whitespace equalopwhitespace var: llen
whitespace lparen
var: l2
rparen
rcurly
rparen
whitespace arrow
whitespace whitespace lcurly
var: v
whitespace colon
whitespace lbrace
var: ipair
rbrace
whitespace pipe
whitespace lambdalparen
var: H
whitespace colon
whitespace var: ipair
rparen
comma
whitespace lparen
var: L
whitespace colon
whitespace var: ipair
rparen
dotwhitespace var: pllen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: pllen
whitespace lparen
var: l1
rparen
whitespace conjwhitespace var: plhd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: H
whitespace conjwhitespace var: pllast
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: L
whitespace conjwhitespace var: ppr1
whitespace lparen
var: H
rparen
whitespace equalopwhitespace var: lhd
whitespace lparen
var: l1
rparen
whitespace conjwhitespace var: ppr2
whitespace lparen
var: H
rparen
whitespace equalopwhitespace var: lhd
whitespace lparen
var: l2
rparen
whitespace conjwhitespace var: ppr1
whitespace lparen
var: L
rparen
whitespace equalopwhitespace var: last
whitespace lparen
var: l1
rparen
whitespace conjwhitespace var: ppr2
whitespace lparen
var: L
rparen
whitespace equalopwhitespace var: last
whitespace lparen
var: l2
rparen
whitespace whitespace rcurly
semicolon
var: splitAt
whitespace colon
whitespace lparen
var: y
colon
var: int
rparen
whitespace arrow
whitespace lparen
var: l
whitespace colon
whitespace lcurly
whitespace var: v
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace pipe
whitespace var: llen
whitespace lparen
var: v
rparen
whitespace lessthanopwhitespace var: y
rcurly
rparen
whitespace arrow
whitespace whitespace lcurly
var: v
colon
var: plist
whitespace pipe
whitespace lambdalparen
var: H
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
comma
whitespace lparen
var: L
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
dotwhitespace lparen
var: fst
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: H
whitespace conjwhitespace var: snd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: L
rparen
whitespace implieswhitespace whitespace var: llen
whitespace lparen
var: H
rparen
whitespace equalopwhitespace var: y
whitespace conjwhitespace var: llen
whitespace lparen
var: L
rparen
whitespace equalopwhitespace var: llen
whitespace lparen
var: l
rparen
whitespace ar-minuswhitespace var: y
whitespace whitespace rcurly
semicolon
var: null
whitespace colon
whitespace lparen
var: l
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace var: bool
whitespace pipe
whitespace lbrace
var: v
equaloptruerbrace
whitespace iffwhitespace var: llen
whitespace lparen
var: l
rparen
whitespace equalopwhitespace int: 0
rcurly
semicolon
var: last
whitespace colon
whitespace lparen
var: l
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace var: last
whitespace lparen
var: l
rparen
whitespace equalopwhitespace var: v
rcurly
semicolon
whitespace var: init
whitespace colon
whitespace lparen
var: l
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace pipe
whitespace var: llen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: llen
whitespace lparen
var: v
rparen
whitespace ar-minusint: 1
rcurly
semicolon
whitespace var: take
whitespace colon
whitespace lparen
var: n
whitespace colon
whitespace var: int
rparen
whitespace arrow
whitespace lparen
var: l
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace pipe
whitespace lambdalparen
var: u
whitespace colon
whitespace var: int
rparen
dotwhitespace whitespace var: llen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: n
whitespace conjwhitespace whitespace lparen
var: lmem
whitespace lparen
var: v
comma
whitespace var: u
rparen
whitespace equalopwhitespace truerparen
whitespace implieswhitespace var: lmem
whitespace lparen
var: l
comma
whitespace var: u
rparen
whitespace equalopwhitespace truercurly
semicolon
whitespace typewhitespace var: spair
semicolon
stexcwhitespace var: sfst
whitespace colon
whitespace var: spair
whitespace colon
whitespace var: string
semicolon
stexcwhitespace var: ssnd
whitespace colon
whitespace var: spair
whitespace colon
whitespace var: string
semicolon
stexcwhitespace var: smem
whitespace colon
whitespace var: char
whitespace colon
whitespace var: string
whitespace colon
whitespace var: bool
semicolon
var: goal
whitespace colon
whitespace lparen
var: s
whitespace colon
whitespace var: string
rparen
whitespace arrow
whitespace lparen
var: c
whitespace colon
whitespace var: char
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: spair
whitespace pipe
whitespace var: f
whitespace equalopwhitespace var: sfst
whitespace lparen
var: v
rparen
whitespace conjwhitespace var: sn
whitespace equalopwhitespace var: ssnd
whitespace lparen
var: v
rparen
whitespace conjwhitespace var: smem
whitespace lparen
var: c
comma
whitespace var: f
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace lambdalparen
var: u
whitespace colon
whitespace var: char
rparen
dotwhitespace var: smem
whitespace lparen
var: u
comma
whitespace var: f
rparen
whitespace equalopwhitespace truewhitespace implieswhitespace var: smem
whitespace lparen
var: u
whitespace comma
whitespace var: s
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace lambdalparen
var: u
whitespace colon
whitespace var: char
rparen
dotwhitespace var: smem
whitespace lparen
var: u
comma
whitespace var: sn
rparen
whitespace equalopwhitespace truewhitespace implieswhitespace var: smem
whitespace lparen
var: u
comma
whitespace var: s
rparen
whitespace equalopwhitespace truewhitespace rcurly
semicolon
RelSpec {  SRs ;  PRs ;  TSs  
 Assume false
 name ep : 
 params :
 Type {var_v0:int | true} 
 Assume false
 name length : 
 params :
 Type  Arrow ( ( x : {var_v1:Ty_list int | true} ) -> {v:int | (llen)(x) ==(v)} 
 Assume false
 name rev : 
 params :
 Type  Arrow ( ( l : {var_v2:Ty_list int | true} ) -> {v:Ty_list int | 
 	 Conj <c (llen)(v) ==(llen)(l)
 	 , 
 	 Conj <c (lhd)(v) ==(last)(l)
 	 , 
 	 Conj <c (last)(v) ==(lhd)(l)
 	 , 
 	 Conj <c (lsnd)(v) ==(pen)(l)
 	 , (pen)(v) ==(lsnd)(v) >c  >c  >c  >c } 
 Assume false
 name compare_lengths : 
 params :
 Type  Arrow ( ( x : {var_v3:Ty_list int | true} ) ->  Arrow ( ( y : {var_v4:Ty_list int | true} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  (llen)(x) ==(llen)(y)} 
 Assume false
 name cons : 
 params :
 Type  Arrow ( ( x : {var_v5:int | true} ) ->  Arrow ( ( xs : {var_v6:Ty_list int | true} ) -> {v:Ty_list int | 
 	 Conj <c (llen)(v) ==((llen)(xs) + (1))
 	 , 
 	 Conj <c (lmem)( , v, x ) = (true)
 	 , 
 	 Conj <c (lhd)(v) ==(x)
 	 , 
 	 Conj <c (lsnd)(v) ==(lhd)(xs)
 	 , 
 	 Conj <c (last)(v) ==(last)(xs)
 	 , (pen)(v) ==(pen)(xs) >c  >c  >c  >c  >c } 
 Assume false
 name hd : 
 params :
 Type  Arrow ( ( l : {var_v7:Ty_list int | true} ) -> {v:int | 
 	 Conj <c (lmem)( , l, v ) = (true)
 	 , (lhd)(l) ==(v) >c } 
 Assume false
 name tl : 
 params :
 Type  Arrow ( ( l : {var_v8:Ty_list int | true} ) -> {v:Ty_list int | 
 	 Conj <c (llen)(v) ==((llen)(l) -- (1))
 	 , 
 	 Conj <c (last)(v) ==(last)(l)
 	 , 
 	 Conj <c (lhd)(v) ==(lsnd)(l)
 	 , (pen)(v) ==(pen)(l) >c  >c  >c } 
 Assume false
 name nth : 
 params :
 Type  Arrow ( ( l : {var_v9:Ty_list int | true} ) ->  Arrow ( ( n : {var_v10:int | true} ) -> {v:int | 
 	 Conj <c (lmem)( , l, v ) = (true)
 	 , (nth)( , l, n ) ==(v) >c } 
 Assume false
 name append : 
 params :
 Type  Arrow ( ( l1 : {var_v11:Ty_list int | true} ) ->  Arrow ( ( l2 : {var_v12:Ty_list int | true} ) -> {v:Ty_list int | 
 	 Conj <c (llen)(v) ==((llen)(l1) + (llen)(l2))
 	 , 
 	 Conj <c (lhd)(v) ==(lhd)(l1)
 	 , 
 	 Conj <c (lsnd)(v) ==(lsnd)(l1)
 	 , 
 	 Conj <c (last)(v) ==(last)(l2)
 	 , (pen)(v) ==(pen)(l2) >c  >c  >c  >c } 
 Assume false
 name combine : 
 params :
 Type  Arrow ( ( l1 : {var_v13:Ty_list int | true} ) ->  Arrow ( ( l2 : {v:Ty_list int | (llen)(l1) ==(llen)(l2)} ) -> {v:Ty_list int ipair | Forall 
 	 
 Key =H Value = int ipair
 Key =L Value = int ipair{ 
 	 Conj <c (pllen)(v) ==(pllen)(l1)
 	 , 
 	 Conj <c (plhd)(v) = (H)
 	 , 
 	 Conj <c (pllast)(v) = (L)
 	 , 
 	 Conj <c (ppr1)(H) ==(lhd)(l1)
 	 , 
 	 Conj <c (ppr2)(H) ==(lhd)(l2)
 	 , 
 	 Conj <c (ppr1)(L) ==(last)(l1)
 	 , (ppr2)(L) ==(last)(l2) >c  >c  >c  >c  >c  >c  }} 
 Assume false
 name splitAt : 
 params :
 Type  Arrow ( ( y : {var_v14:int | true} ) ->  Arrow ( ( l : {v:Ty_list int | (llen)(v) > (y)} ) -> {v:int plist | Forall 
 	 
 Key =H Value = Ty_list int
 Key =L Value = Ty_list int{ 
 	 Impl < 
 	 Conj <c (fst)(v) = (H)
 	 , (snd)(v) = (L) >c 
 	 
 	 Conj <c (llen)(H) ==(y)
 	 , (llen)(L) ==((llen)(l) -- (y)) >c  > }} 
 Assume false
 name null : 
 params :
 Type  Arrow ( ( l : {var_v15:Ty_list int | true} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  (llen)(l) ==(0)} 
 Assume false
 name last : 
 params :
 Type  Arrow ( ( l : {var_v16:Ty_list int | true} ) -> {v:int | (last)(l) ==(v)} 
 Assume false
 name init : 
 params :
 Type  Arrow ( ( l : {var_v17:Ty_list int | true} ) -> {v:Ty_list int | (llen)(v) ==((llen)(v) -- (1))} 
 Assume false
 name take : 
 params :
 Type  Arrow ( ( n : {var_v18:int | true} ) ->  Arrow ( ( l : {var_v19:Ty_list int | true} ) -> {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c (llen)(v) ==(n)
 	 , 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , l, u ) = (true) > >c  }} 
 Assume false
 name goal : 
 params :
 Type  Arrow ( ( s : {var_v20:Ty_string | true} ) ->  Arrow ( ( c : {var_v21:Ty_char | true} ) -> {v:int spair | 
 	 Conj <c (f) = (sfst)(v)
 	 , 
 	 Conj <c (sn) = (ssnd)(v)
 	 , 
 	 Conj <c (smem)( , c, f ) = (true)
 	 , Forall 
 	 
 Key =u Value = Ty_char{ 
 	 Impl < (smem)( , u, f ) = (true)
 	 
 	 Conj <c (smem)( , u, s ) = (true)
 	 , Forall 
 	 
 Key =u Value = Ty_char{ 
 	 Impl < (smem)( , u, sn ) = (true)
 	 (smem)( , u, s ) = (true) > } >c  > } >c  >c  >c };  Formulas  }
 INITIAL GAMMA 
 
 goal :  Arrow ( ( s : {var_v20:Ty_string | true} ) ->  Arrow ( ( c : {var_v21:Ty_char | true} ) -> {v:int spair | 
 	 Conj <c (f) = (sfst)(v)
 	 , 
 	 Conj <c (sn) = (ssnd)(v)
 	 , 
 	 Conj <c (smem)( , c, f ) = (true)
 	 , Forall 
 	 
 Key =u Value = Ty_char{ 
 	 Impl < (smem)( , u, f ) = (true)
 	 
 	 Conj <c (smem)( , u, s ) = (true)
 	 , Forall 
 	 
 Key =u Value = Ty_char{ 
 	 Impl < (smem)( , u, sn ) = (true)
 	 (smem)( , u, s ) = (true) > } >c  > } >c  >c  >c }
 take :  Arrow ( ( n : {var_v18:int | true} ) ->  Arrow ( ( l : {var_v19:Ty_list int | true} ) -> {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c (llen)(v) ==(n)
 	 , 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , l, u ) = (true) > >c  }}
 init :  Arrow ( ( l : {var_v17:Ty_list int | true} ) -> {v:Ty_list int | (llen)(v) ==((llen)(v) -- (1))}
 last :  Arrow ( ( l : {var_v16:Ty_list int | true} ) -> {v:int | (last)(l) ==(v)}
 null :  Arrow ( ( l : {var_v15:Ty_list int | true} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  (llen)(l) ==(0)}
 splitAt :  Arrow ( ( y : {var_v14:int | true} ) ->  Arrow ( ( l : {v:Ty_list int | (llen)(v) > (y)} ) -> {v:int plist | Forall 
 	 
 Key =H Value = Ty_list int
 Key =L Value = Ty_list int{ 
 	 Impl < 
 	 Conj <c (fst)(v) = (H)
 	 , (snd)(v) = (L) >c 
 	 
 	 Conj <c (llen)(H) ==(y)
 	 , (llen)(L) ==((llen)(l) -- (y)) >c  > }}
 combine :  Arrow ( ( l1 : {var_v13:Ty_list int | true} ) ->  Arrow ( ( l2 : {v:Ty_list int | (llen)(l1) ==(llen)(l2)} ) -> {v:Ty_list int ipair | Forall 
 	 
 Key =H Value = int ipair
 Key =L Value = int ipair{ 
 	 Conj <c (pllen)(v) ==(pllen)(l1)
 	 , 
 	 Conj <c (plhd)(v) = (H)
 	 , 
 	 Conj <c (pllast)(v) = (L)
 	 , 
 	 Conj <c (ppr1)(H) ==(lhd)(l1)
 	 , 
 	 Conj <c (ppr2)(H) ==(lhd)(l2)
 	 , 
 	 Conj <c (ppr1)(L) ==(last)(l1)
 	 , (ppr2)(L) ==(last)(l2) >c  >c  >c  >c  >c  >c  }}
 append :  Arrow ( ( l1 : {var_v11:Ty_list int | true} ) ->  Arrow ( ( l2 : {var_v12:Ty_list int | true} ) -> {v:Ty_list int | 
 	 Conj <c (llen)(v) ==((llen)(l1) + (llen)(l2))
 	 , 
 	 Conj <c (lhd)(v) ==(lhd)(l1)
 	 , 
 	 Conj <c (lsnd)(v) ==(lsnd)(l1)
 	 , 
 	 Conj <c (last)(v) ==(last)(l2)
 	 , (pen)(v) ==(pen)(l2) >c  >c  >c  >c }
 nth :  Arrow ( ( l : {var_v9:Ty_list int | true} ) ->  Arrow ( ( n : {var_v10:int | true} ) -> {v:int | 
 	 Conj <c (lmem)( , l, v ) = (true)
 	 , (nth)( , l, n ) ==(v) >c }
 tl :  Arrow ( ( l : {var_v8:Ty_list int | true} ) -> {v:Ty_list int | 
 	 Conj <c (llen)(v) ==((llen)(l) -- (1))
 	 , 
 	 Conj <c (last)(v) ==(last)(l)
 	 , 
 	 Conj <c (lhd)(v) ==(lsnd)(l)
 	 , (pen)(v) ==(pen)(l) >c  >c  >c }
 hd :  Arrow ( ( l : {var_v7:Ty_list int | true} ) -> {v:int | 
 	 Conj <c (lmem)( , l, v ) = (true)
 	 , (lhd)(l) ==(v) >c }
 cons :  Arrow ( ( x : {var_v5:int | true} ) ->  Arrow ( ( xs : {var_v6:Ty_list int | true} ) -> {v:Ty_list int | 
 	 Conj <c (llen)(v) ==((llen)(xs) + (1))
 	 , 
 	 Conj <c (lmem)( , v, x ) = (true)
 	 , 
 	 Conj <c (lhd)(v) ==(x)
 	 , 
 	 Conj <c (lsnd)(v) ==(lhd)(xs)
 	 , 
 	 Conj <c (last)(v) ==(last)(xs)
 	 , (pen)(v) ==(pen)(xs) >c  >c  >c  >c  >c }
 compare_lengths :  Arrow ( ( x : {var_v3:Ty_list int | true} ) ->  Arrow ( ( y : {var_v4:Ty_list int | true} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  (llen)(x) ==(llen)(y)}
 rev :  Arrow ( ( l : {var_v2:Ty_list int | true} ) -> {v:Ty_list int | 
 	 Conj <c (llen)(v) ==(llen)(l)
 	 , 
 	 Conj <c (lhd)(v) ==(last)(l)
 	 , 
 	 Conj <c (last)(v) ==(lhd)(l)
 	 , 
 	 Conj <c (lsnd)(v) ==(pen)(l)
 	 , (pen)(v) ==(lsnd)(v) >c  >c  >c  >c }
 length :  Arrow ( ( x : {var_v1:Ty_list int | true} ) -> {v:int | (llen)(x) ==(v)}
 ep : {var_v0:int | true}
 INITIAL SIGMA 
 
 TypeNames 
 
 spair
 plist
 ipair
 Qualifiers 
 
 Qual llen :  :-> Ty_list int :-> int
 Qual pllen :  :-> Ty_list int ipair :-> int
 Qual lmem :  :-> Ty_list int :-> int :-> Ty_bool
 Qual lhd :  :-> Ty_list int :-> int
 Qual plhd :  :-> Ty_list int ipair :-> int ipair
 Qual last :  :-> Ty_list int :-> int
 Qual pllast :  :-> Ty_list int ipair :-> int ipair
 Qual ppr1 :  :-> int ipair :-> int
 Qual ppr2 :  :-> int ipair :-> int
 Qual nth :  :-> Ty_list int :-> int :-> int
 Qual lsnd :  :-> Ty_list int :-> int
 Qual pen :  :-> Ty_list int :-> int
 Qual fst :  :-> int plist :-> Ty_list int
 Qual snd :  :-> int plist :-> Ty_list int
 Qual sfst :  :-> int spair :-> Ty_string
 Qual ssnd :  :-> int spair :-> Ty_string
 Qual smem :  :-> Ty_char :-> Ty_string :-> Ty_bool
 Show ***********Calling S-FUNC synthesize***************
 Show Uncurried , s:{var_v20:Ty_string | true}, c:{var_v21:Ty_char | true} -> {v:int spair | 
 	 Conj <c (f) = (sfst)(v)
 	 , 
 	 Conj <c (sn) = (ssnd)(v)
 	 , 
 	 Conj <c (smem)( , c, f ) = (true)
 	 , Forall 
 	 
 Key =u Value = Ty_char{ 
 	 Impl < (smem)( , u, f ) = (true)
 	 
 	 Conj <c (smem)( , u, s ) = (true)
 	 , Forall 
 	 
 Key =u Value = Ty_char{ 
 	 Impl < (smem)( , u, sn ) = (true)
 	 (smem)( , u, s ) = (true) > } >c  > } >c  >c  >c }
 Decreasing Measure s
 Decreasing Type {var_v20:Ty_string | true}
 Show Trying :: Top-level Match
 Show :: Synthesize Match {v:int spair | 
 	 Conj <c (f) = (sfst)(v)
 	 , 
 	 Conj <c (sn) = (ssnd)(v)
 	 , 
 	 Conj <c (smem)( , c, f ) = (true)
 	 , Forall 
 	 
 Key =u Value = Ty_char{ 
 	 Impl < (smem)( , u, f ) = (true)
 	 
 	 Conj <c (smem)( , u, s ) = (true)
 	 , Forall 
 	 
 Key =u Value = Ty_char{ 
 	 Impl < (smem)( , u, sn ) = (true)
 	 (smem)( , u, s ) = (true) > } >c  > } >c  >c  >c }
 Show :: List Ty_string
 Show :: Non List Case
 Match-case failed :: Try Top-level If-then-else 
 **********************************************
 iSynthesize If-THEN-ELSE {v:int spair | 
 	 Conj <c (f) = (sfst)(v)
 	 , 
 	 Conj <c (sn) = (ssnd)(v)
 	 , 
 	 Conj <c (smem)( , c, f ) = (true)
 	 , Forall 
 	 
 Key =u Value = Ty_char{ 
 	 Impl < (smem)( , u, f ) = (true)
 	 
 	 Conj <c (smem)( , u, s ) = (true)
 	 , Forall 
 	 
 Key =u Value = Ty_char{ 
 	 Impl < (smem)( , u, sn ) = (true)
 	 (smem)( , u, s ) = (true) > } >c  > } >c  >c  >c }
 **********************************************
  *********************Synthesizing the Guard*******************
 iSynthesize Boolean Guard {var_v22:Ty_bool | true}
  *********************Synthesizing the Guard*******************
 esynthesizeScalar for {var_v22:Ty_bool | true}
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
  *********************Guard Synthesized*******************
 iSynthesize Following Boolean Guards Found 
  ********************Guard Synthesized*******************
  If then else Failed :: Try without subdivision
 
  Entering Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  , 
 goal
 ############################################################
  Synthesizing the Function application Pure Component goal
  *************** Trying Arrow Component ************goal :  Arrow ( ( s : {var_v20:Ty_string | true} ) ->  Arrow ( ( c : {var_v21:Ty_char | true} ) -> {v:int spair | 
 	 Conj <c (f) = (sfst)(v)
 	 , 
 	 Conj <c (sn) = (ssnd)(v)
 	 , 
 	 Conj <c (smem)( , c, f ) = (true)
 	 , Forall 
 	 
 Key =u Value = Ty_char{ 
 	 Impl < (smem)( , u, f ) = (true)
 	 
 	 Conj <c (smem)( , u, s ) = (true)
 	 , Forall 
 	 
 Key =u Value = Ty_char{ 
 	 Impl < (smem)( , u, sn ) = (true)
 	 (smem)( , u, s ) = (true) > } >c  > } >c  >c  >c }
  *************** Synthesizing Args ei : ti for ************goal
 ##################################################################################
  Synthesizing the 1th argument for Function goal
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v20:Ty_string | true}
 
 Enumerating a Scalar Term s
 
 Type of the Scalar Term {var_v20:Ty_string | true}
 ################################################
 Skipping Variable s As this a  Formal Parameter to the current function Call
 Outer Function calls goal
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 Found Constructors with required return type
  
 ********************** HERE BEFORE 
 Show No more choices for ConsApp
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  
  DEPTH vs MAX  0 vs 2
 ##################################################################################
  Synthesizing the 2th argument for Function goal
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v21:Ty_char | true}
 
 Enumerating a Scalar Term c
 
 Type of the Scalar Term {var_v21:Ty_char | true}
 ################################################
 Skipping Variable c As this a  Formal Parameter to the current function Call
 Outer Function calls goal
 ################################################
  Entering Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 Found Constructors with required return type
  
 ********************** HERE BEFORE 
 Show No more choices for ConsApp
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  
  DEPTH vs MAX  0 vs 2
 ##################################################################################
  *************** Synthesizing Args ei : Failed for some  arg
  EXPLORED Args.parser output 
 EXPLORED learningOn  true
 EXPLORED bidirectionality  true
 EXPLORED effect-filter  false
 EXPLORED specfile :: ./prudent_tests/hegel/Hoogle+/revZip.spec
 EXPLORED goal Number :: 0
 EXPLORED Max path length :: 2
 EXPLORED Nested If :: 1typewhitespace var: ipair
semicolon
typewhitespace var: plist
semicolon
stexcwhitespace var: llen
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: pllen
whitespace colon
whitespace lbrace
var: ipair
rbrace
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: lmem
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: int
whitespace colon
whitespace var: bool
semicolon
stexcwhitespace var: lhd
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: plhd
whitespace colon
whitespace lbrace
var: ipair
rbrace
whitespace colon
whitespace var: ipair
semicolon
stexcwhitespace var: last
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: pllast
whitespace colon
whitespace lbrace
var: ipair
rbrace
whitespace colon
whitespace var: ipair
semicolon
stexcwhitespace var: ppr1
whitespace colon
whitespace var: ipair
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: ppr2
whitespace colon
whitespace var: ipair
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: nth
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: int
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: lsnd
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: pen
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: fst
whitespace colon
whitespace var: plist
whitespace colon
whitespace lbrace
var: int
rbrace
semicolon
stexcwhitespace var: snd
whitespace colon
whitespace var: plist
whitespace colon
whitespace lbrace
var: int
rbrace
semicolon
var: ep
whitespace colon
whitespace var: int
semicolon
var: length
whitespace colon
whitespace lparen
var: x
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace var: llen
whitespace lparen
var: x
rparen
whitespace equalopwhitespace var: v
rcurly
semicolon
whitespace var: rev
whitespace colon
whitespace lparen
var: l
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace pipe
whitespace whitespace var: llen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: llen
whitespace lparen
var: l
rparen
whitespace conjwhitespace var: lhd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: last
whitespace lparen
var: l
rparen
whitespace conjwhitespace var: last
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: lhd
whitespace lparen
var: l
rparen
whitespace conjwhitespace var: lsnd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: pen
whitespace lparen
var: l
rparen
whitespace conjwhitespace var: pen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: lsnd
whitespace lparen
var: v
rparen
whitespace rcurly
semicolon
var: compare_lengths
whitespace colon
whitespace lparen
var: x
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lparen
var: y
colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace var: bool
whitespace pipe
whitespace lbrace
var: v
equaloptruerbrace
whitespace iffwhitespace lparen
var: llen
whitespace lparen
var: x
rparen
whitespace equalopwhitespace var: llen
whitespace lparen
var: y
rparen
rparen
rcurly
semicolon
var: cons
whitespace colon
whitespace lparen
var: x
whitespace colon
whitespace var: int
rparen
whitespace arrow
whitespace lparen
var: xs
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace pipe
whitespace var: llen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: llen
whitespace lparen
var: xs
rparen
whitespace pluswhitespace int: 1
whitespace conjwhitespace var: lmem
whitespace lparen
var: v
comma
whitespace var: x
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace var: lhd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: x
whitespace conjwhitespace var: lsnd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: lhd
whitespace lparen
var: xs
rparen
whitespace conjwhitespace var: last
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: last
whitespace lparen
var: xs
rparen
whitespace conjwhitespace var: pen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: pen
whitespace lparen
var: xs
rparen
whitespace rcurly
semicolon
var: hd
whitespace colon
whitespace lparen
var: l
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace var: lmem
whitespace lparen
var: l
comma
whitespace var: v
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace var: lhd
whitespace lparen
var: l
rparen
whitespace equalopwhitespace var: v
whitespace whitespace rcurly
semicolon
var: tl
whitespace colon
whitespace lparen
var: l
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace pipe
whitespace var: llen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: llen
whitespace lparen
var: l
rparen
whitespace ar-minuswhitespace int: 1
whitespace conjwhitespace var: last
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: last
whitespace lparen
var: l
rparen
whitespace conjwhitespace var: lhd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: lsnd
whitespace lparen
var: l
rparen
whitespace conjwhitespace var: pen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: pen
whitespace lparen
var: l
rparen
whitespace rcurly
semicolon
var: nth
whitespace colon
whitespace lparen
var: l
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lparen
var: n
whitespace colon
whitespace var: int
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace var: lmem
whitespace lparen
var: l
comma
whitespace var: v
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace var: nth
whitespace lparen
var: l
comma
whitespace var: n
rparen
whitespace equalopwhitespace var: v
whitespace whitespace rcurly
semicolon
var: append
whitespace colon
whitespace lparen
var: l1
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lparen
var: l2
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace pipe
whitespace whitespace var: llen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: llen
whitespace lparen
var: l1
rparen
whitespace pluswhitespace var: llen
whitespace lparen
var: l2
rparen
whitespace conjwhitespace var: lhd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: lhd
whitespace lparen
var: l1
rparen
whitespace conjwhitespace var: lsnd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: lsnd
whitespace lparen
var: l1
rparen
whitespace conjwhitespace var: last
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: last
whitespace lparen
var: l2
rparen
whitespace conjwhitespace var: pen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: pen
whitespace lparen
var: l2
rparen
whitespace rcurly
semicolon
var: combine
whitespace colon
whitespace lparen
var: l1
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lparen
var: l2
whitespace colon
whitespace lcurly
var: v
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace pipe
whitespace var: llen
whitespace lparen
var: l1
rparen
whitespace equalopwhitespace var: llen
whitespace lparen
var: l2
rparen
rcurly
rparen
whitespace arrow
whitespace whitespace lcurly
var: v
whitespace colon
whitespace lbrace
var: ipair
rbrace
whitespace pipe
whitespace lambdalparen
var: H
whitespace colon
whitespace var: ipair
rparen
comma
whitespace lparen
var: L
whitespace colon
whitespace var: ipair
rparen
dotwhitespace var: pllen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: pllen
whitespace lparen
var: l1
rparen
whitespace conjwhitespace var: plhd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: H
whitespace conjwhitespace var: pllast
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: L
whitespace conjwhitespace var: ppr1
whitespace lparen
var: H
rparen
whitespace equalopwhitespace var: lhd
whitespace lparen
var: l1
rparen
whitespace conjwhitespace var: ppr2
whitespace lparen
var: H
rparen
whitespace equalopwhitespace var: lhd
whitespace lparen
var: l2
rparen
whitespace conjwhitespace var: ppr1
whitespace lparen
var: L
rparen
whitespace equalopwhitespace var: last
whitespace lparen
var: l1
rparen
whitespace conjwhitespace var: ppr2
whitespace lparen
var: L
rparen
whitespace equalopwhitespace var: last
whitespace lparen
var: l2
rparen
whitespace whitespace rcurly
semicolon
var: splitAt
whitespace colon
whitespace lparen
var: y
colon
var: int
rparen
whitespace arrow
whitespace lparen
var: l
whitespace colon
whitespace lcurly
whitespace var: v
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace pipe
whitespace var: llen
whitespace lparen
var: v
rparen
whitespace lessthanopwhitespace var: y
rcurly
rparen
whitespace arrow
whitespace whitespace lcurly
var: v
colon
var: plist
whitespace pipe
whitespace lambdalparen
var: H
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
comma
whitespace lparen
var: L
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
dotwhitespace lparen
var: fst
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: H
whitespace conjwhitespace var: snd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: L
rparen
whitespace implieswhitespace whitespace var: llen
whitespace lparen
var: H
rparen
whitespace equalopwhitespace var: y
whitespace conjwhitespace var: llen
whitespace lparen
var: L
rparen
whitespace equalopwhitespace var: llen
whitespace lparen
var: l
rparen
whitespace ar-minuswhitespace var: y
whitespace whitespace rcurly
semicolon
var: null
whitespace colon
whitespace lparen
var: l
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace var: bool
whitespace pipe
whitespace lbrace
var: v
equaloptruerbrace
whitespace iffwhitespace var: llen
whitespace lparen
var: l
rparen
whitespace equalopwhitespace int: 0
rcurly
semicolon
var: last
whitespace colon
whitespace lparen
var: l
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace var: last
whitespace lparen
var: l
rparen
whitespace equalopwhitespace var: v
rcurly
semicolon
whitespace var: init
whitespace colon
whitespace lparen
var: l
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace pipe
whitespace var: llen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: llen
whitespace lparen
var: v
rparen
whitespace ar-minusint: 1
rcurly
semicolon
whitespace var: take
whitespace colon
whitespace lparen
var: n
whitespace colon
whitespace var: int
rparen
whitespace arrow
whitespace lparen
var: l
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace pipe
whitespace lambdalparen
var: u
whitespace colon
whitespace var: int
rparen
dotwhitespace whitespace var: llen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: n
whitespace conjwhitespace whitespace lparen
var: lmem
whitespace lparen
var: v
comma
whitespace var: u
rparen
whitespace equalopwhitespace truerparen
whitespace implieswhitespace var: lmem
whitespace lparen
var: l
comma
whitespace var: u
rparen
whitespace equalopwhitespace truercurly
semicolon
whitespace var: goal
whitespace colon
whitespace lparen
var: x
whitespace colon
whitespace lbrace
var: a
rbrace
rparen
whitespace arrow
whitespace lparen
var: y
whitespace colon
whitespace lbrace
var: a
rbrace
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace lbrace
var: pair
rbrace
whitespace pipe
whitespace lambdalparen
var: u
whitespace colon
whitespace lbrace
var: a
rbrace
rparen
comma
whitespace lparen
var: w
whitespace colon
whitespace var: a
rparen
comma
whitespace lparen
var: z
whitespace colon
whitespace var: a
rparen
dotwhitespace var: sndlist
whitespace lparen
var: v
comma
whitespace var: u
rparen
whitespace equalopwhitespace truewhitespace implieswhitespace lparen
var: mem
whitespace lparen
var: w
comma
whitespace var: u
rparen
whitespace equalopwhitespace truewhitespace implieswhitespace var: mem
whitespace lparen
var: w
comma
whitespace var: y
rparen
whitespace equalopwhitespace truerparen
whitespace conjwhitespace lparen
var: ord
whitespace lparen
var: w
comma
whitespace var: z
comma
whitespace var: u
rparen
whitespace equalopwhitespace truewhitespace implieswhitespace var: ord
whitespace lparen
var: z
comma
whitespace var: w
comma
whitespace var: y
rparen
whitespace equalopwhitespace truerparen
rcurly
semicolon
RelSpec {  SRs ;  PRs ;  TSs  
 Assume false
 name ep : 
 params :
 Type {var_v0:int | true} 
 Assume false
 name length : 
 params :
 Type  Arrow ( ( x : {var_v1:Ty_list int | true} ) -> {v:int | (llen)(x) ==(v)} 
 Assume false
 name rev : 
 params :
 Type  Arrow ( ( l : {var_v2:Ty_list int | true} ) -> {v:Ty_list int | 
 	 Conj <c (llen)(v) ==(llen)(l)
 	 , 
 	 Conj <c (lhd)(v) ==(last)(l)
 	 , 
 	 Conj <c (last)(v) ==(lhd)(l)
 	 , 
 	 Conj <c (lsnd)(v) ==(pen)(l)
 	 , (pen)(v) ==(lsnd)(v) >c  >c  >c  >c } 
 Assume false
 name compare_lengths : 
 params :
 Type  Arrow ( ( x : {var_v3:Ty_list int | true} ) ->  Arrow ( ( y : {var_v4:Ty_list int | true} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  (llen)(x) ==(llen)(y)} 
 Assume false
 name cons : 
 params :
 Type  Arrow ( ( x : {var_v5:int | true} ) ->  Arrow ( ( xs : {var_v6:Ty_list int | true} ) -> {v:Ty_list int | 
 	 Conj <c (llen)(v) ==((llen)(xs) + (1))
 	 , 
 	 Conj <c (lmem)( , v, x ) = (true)
 	 , 
 	 Conj <c (lhd)(v) ==(x)
 	 , 
 	 Conj <c (lsnd)(v) ==(lhd)(xs)
 	 , 
 	 Conj <c (last)(v) ==(last)(xs)
 	 , (pen)(v) ==(pen)(xs) >c  >c  >c  >c  >c } 
 Assume false
 name hd : 
 params :
 Type  Arrow ( ( l : {var_v7:Ty_list int | true} ) -> {v:int | 
 	 Conj <c (lmem)( , l, v ) = (true)
 	 , (lhd)(l) ==(v) >c } 
 Assume false
 name tl : 
 params :
 Type  Arrow ( ( l : {var_v8:Ty_list int | true} ) -> {v:Ty_list int | 
 	 Conj <c (llen)(v) ==((llen)(l) -- (1))
 	 , 
 	 Conj <c (last)(v) ==(last)(l)
 	 , 
 	 Conj <c (lhd)(v) ==(lsnd)(l)
 	 , (pen)(v) ==(pen)(l) >c  >c  >c } 
 Assume false
 name nth : 
 params :
 Type  Arrow ( ( l : {var_v9:Ty_list int | true} ) ->  Arrow ( ( n : {var_v10:int | true} ) -> {v:int | 
 	 Conj <c (lmem)( , l, v ) = (true)
 	 , (nth)( , l, n ) ==(v) >c } 
 Assume false
 name append : 
 params :
 Type  Arrow ( ( l1 : {var_v11:Ty_list int | true} ) ->  Arrow ( ( l2 : {var_v12:Ty_list int | true} ) -> {v:Ty_list int | 
 	 Conj <c (llen)(v) ==((llen)(l1) + (llen)(l2))
 	 , 
 	 Conj <c (lhd)(v) ==(lhd)(l1)
 	 , 
 	 Conj <c (lsnd)(v) ==(lsnd)(l1)
 	 , 
 	 Conj <c (last)(v) ==(last)(l2)
 	 , (pen)(v) ==(pen)(l2) >c  >c  >c  >c } 
 Assume false
 name combine : 
 params :
 Type  Arrow ( ( l1 : {var_v13:Ty_list int | true} ) ->  Arrow ( ( l2 : {v:Ty_list int | (llen)(l1) ==(llen)(l2)} ) -> {v:Ty_list int ipair | Forall 
 	 
 Key =H Value = int ipair
 Key =L Value = int ipair{ 
 	 Conj <c (pllen)(v) ==(pllen)(l1)
 	 , 
 	 Conj <c (plhd)(v) = (H)
 	 , 
 	 Conj <c (pllast)(v) = (L)
 	 , 
 	 Conj <c (ppr1)(H) ==(lhd)(l1)
 	 , 
 	 Conj <c (ppr2)(H) ==(lhd)(l2)
 	 , 
 	 Conj <c (ppr1)(L) ==(last)(l1)
 	 , (ppr2)(L) ==(last)(l2) >c  >c  >c  >c  >c  >c  }} 
 Assume false
 name splitAt : 
 params :
 Type  Arrow ( ( y : {var_v14:int | true} ) ->  Arrow ( ( l : {v:Ty_list int | (llen)(v) > (y)} ) -> {v:int plist | Forall 
 	 
 Key =H Value = Ty_list int
 Key =L Value = Ty_list int{ 
 	 Impl < 
 	 Conj <c (fst)(v) = (H)
 	 , (snd)(v) = (L) >c 
 	 
 	 Conj <c (llen)(H) ==(y)
 	 , (llen)(L) ==((llen)(l) -- (y)) >c  > }} 
 Assume false
 name null : 
 params :
 Type  Arrow ( ( l : {var_v15:Ty_list int | true} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  (llen)(l) ==(0)} 
 Assume false
 name last : 
 params :
 Type  Arrow ( ( l : {var_v16:Ty_list int | true} ) -> {v:int | (last)(l) ==(v)} 
 Assume false
 name init : 
 params :
 Type  Arrow ( ( l : {var_v17:Ty_list int | true} ) -> {v:Ty_list int | (llen)(v) ==((llen)(v) -- (1))} 
 Assume false
 name take : 
 params :
 Type  Arrow ( ( n : {var_v18:int | true} ) ->  Arrow ( ( l : {var_v19:Ty_list int | true} ) -> {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c (llen)(v) ==(n)
 	 , 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , l, u ) = (true) > >c  }} 
 Assume false
 name goal : 
 params :
 Type  Arrow ( ( x : {var_v20:Ty_list int a | true} ) ->  Arrow ( ( y : {var_v21:Ty_list int a | true} ) -> {v:Ty_list int pair | Forall 
 	 
 Key =u Value = Ty_list int a
 Key =w Value = int a
 Key =z Value = int a{ 
 	 Impl < (sndlist)( , v, u ) = (true)
 	 
 	 Conj <c 
 	 Impl < (mem)( , w, u ) = (true)
 	 (mem)( , w, y ) = (true) >
 	 , 
 	 Impl < (ord)( , w, z, u ) = (true)
 	 (ord)( , z, w, y ) = (true) > >c  > }};  Formulas  }
 INITIAL GAMMA 
 
 goal :  Arrow ( ( x : {var_v20:Ty_list int a | true} ) ->  Arrow ( ( y : {var_v21:Ty_list int a | true} ) -> {v:Ty_list int pair | Forall 
 	 
 Key =u Value = Ty_list int a
 Key =w Value = int a
 Key =z Value = int a{ 
 	 Impl < (sndlist)( , v, u ) = (true)
 	 
 	 Conj <c 
 	 Impl < (mem)( , w, u ) = (true)
 	 (mem)( , w, y ) = (true) >
 	 , 
 	 Impl < (ord)( , w, z, u ) = (true)
 	 (ord)( , z, w, y ) = (true) > >c  > }}
 take :  Arrow ( ( n : {var_v18:int | true} ) ->  Arrow ( ( l : {var_v19:Ty_list int | true} ) -> {v:Ty_list int | Forall 
 	 
 Key =u Value = int{ 
 	 Conj <c (llen)(v) ==(n)
 	 , 
 	 Impl < (lmem)( , v, u ) = (true)
 	 (lmem)( , l, u ) = (true) > >c  }}
 init :  Arrow ( ( l : {var_v17:Ty_list int | true} ) -> {v:Ty_list int | (llen)(v) ==((llen)(v) -- (1))}
 last :  Arrow ( ( l : {var_v16:Ty_list int | true} ) -> {v:int | (last)(l) ==(v)}
 null :  Arrow ( ( l : {var_v15:Ty_list int | true} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  (llen)(l) ==(0)}
 splitAt :  Arrow ( ( y : {var_v14:int | true} ) ->  Arrow ( ( l : {v:Ty_list int | (llen)(v) > (y)} ) -> {v:int plist | Forall 
 	 
 Key =H Value = Ty_list int
 Key =L Value = Ty_list int{ 
 	 Impl < 
 	 Conj <c (fst)(v) = (H)
 	 , (snd)(v) = (L) >c 
 	 
 	 Conj <c (llen)(H) ==(y)
 	 , (llen)(L) ==((llen)(l) -- (y)) >c  > }}
 combine :  Arrow ( ( l1 : {var_v13:Ty_list int | true} ) ->  Arrow ( ( l2 : {v:Ty_list int | (llen)(l1) ==(llen)(l2)} ) -> {v:Ty_list int ipair | Forall 
 	 
 Key =H Value = int ipair
 Key =L Value = int ipair{ 
 	 Conj <c (pllen)(v) ==(pllen)(l1)
 	 , 
 	 Conj <c (plhd)(v) = (H)
 	 , 
 	 Conj <c (pllast)(v) = (L)
 	 , 
 	 Conj <c (ppr1)(H) ==(lhd)(l1)
 	 , 
 	 Conj <c (ppr2)(H) ==(lhd)(l2)
 	 , 
 	 Conj <c (ppr1)(L) ==(last)(l1)
 	 , (ppr2)(L) ==(last)(l2) >c  >c  >c  >c  >c  >c  }}
 append :  Arrow ( ( l1 : {var_v11:Ty_list int | true} ) ->  Arrow ( ( l2 : {var_v12:Ty_list int | true} ) -> {v:Ty_list int | 
 	 Conj <c (llen)(v) ==((llen)(l1) + (llen)(l2))
 	 , 
 	 Conj <c (lhd)(v) ==(lhd)(l1)
 	 , 
 	 Conj <c (lsnd)(v) ==(lsnd)(l1)
 	 , 
 	 Conj <c (last)(v) ==(last)(l2)
 	 , (pen)(v) ==(pen)(l2) >c  >c  >c  >c }
 nth :  Arrow ( ( l : {var_v9:Ty_list int | true} ) ->  Arrow ( ( n : {var_v10:int | true} ) -> {v:int | 
 	 Conj <c (lmem)( , l, v ) = (true)
 	 , (nth)( , l, n ) ==(v) >c }
 tl :  Arrow ( ( l : {var_v8:Ty_list int | true} ) -> {v:Ty_list int | 
 	 Conj <c (llen)(v) ==((llen)(l) -- (1))
 	 , 
 	 Conj <c (last)(v) ==(last)(l)
 	 , 
 	 Conj <c (lhd)(v) ==(lsnd)(l)
 	 , (pen)(v) ==(pen)(l) >c  >c  >c }
 hd :  Arrow ( ( l : {var_v7:Ty_list int | true} ) -> {v:int | 
 	 Conj <c (lmem)( , l, v ) = (true)
 	 , (lhd)(l) ==(v) >c }
 cons :  Arrow ( ( x : {var_v5:int | true} ) ->  Arrow ( ( xs : {var_v6:Ty_list int | true} ) -> {v:Ty_list int | 
 	 Conj <c (llen)(v) ==((llen)(xs) + (1))
 	 , 
 	 Conj <c (lmem)( , v, x ) = (true)
 	 , 
 	 Conj <c (lhd)(v) ==(x)
 	 , 
 	 Conj <c (lsnd)(v) ==(lhd)(xs)
 	 , 
 	 Conj <c (last)(v) ==(last)(xs)
 	 , (pen)(v) ==(pen)(xs) >c  >c  >c  >c  >c }
 compare_lengths :  Arrow ( ( x : {var_v3:Ty_list int | true} ) ->  Arrow ( ( y : {var_v4:Ty_list int | true} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  (llen)(x) ==(llen)(y)}
 rev :  Arrow ( ( l : {var_v2:Ty_list int | true} ) -> {v:Ty_list int | 
 	 Conj <c (llen)(v) ==(llen)(l)
 	 , 
 	 Conj <c (lhd)(v) ==(last)(l)
 	 , 
 	 Conj <c (last)(v) ==(lhd)(l)
 	 , 
 	 Conj <c (lsnd)(v) ==(pen)(l)
 	 , (pen)(v) ==(lsnd)(v) >c  >c  >c  >c }
 length :  Arrow ( ( x : {var_v1:Ty_list int | true} ) -> {v:int | (llen)(x) ==(v)}
 ep : {var_v0:int | true}
 INITIAL SIGMA 
 
 TypeNames 
 
 plist
 ipair
 Qualifiers 
 
 Qual llen :  :-> Ty_list int :-> int
 Qual pllen :  :-> Ty_list int ipair :-> int
 Qual lmem :  :-> Ty_list int :-> int :-> Ty_bool
 Qual lhd :  :-> Ty_list int :-> int
 Qual plhd :  :-> Ty_list int ipair :-> int ipair
 Qual last :  :-> Ty_list int :-> int
 Qual pllast :  :-> Ty_list int ipair :-> int ipair
 Qual ppr1 :  :-> int ipair :-> int
 Qual ppr2 :  :-> int ipair :-> int
 Qual nth :  :-> Ty_list int :-> int :-> int
 Qual lsnd :  :-> Ty_list int :-> int
 Qual pen :  :-> Ty_list int :-> int
 Qual fst :  :-> int plist :-> Ty_list int
 Qual snd :  :-> int plist :-> Ty_list int
 Show ***********Calling S-FUNC synthesize***************
 Show Uncurried , x:{var_v20:Ty_list int a | true}, y:{var_v21:Ty_list int a | true} -> {v:Ty_list int pair | Forall 
 	 
 Key =u Value = Ty_list int a
 Key =w Value = int a
 Key =z Value = int a{ 
 	 Impl < (sndlist)( , v, u ) = (true)
 	 
 	 Conj <c 
 	 Impl < (mem)( , w, u ) = (true)
 	 (mem)( , w, y ) = (true) >
 	 , 
 	 Impl < (ord)( , w, z, u ) = (true)
 	 (ord)( , z, w, y ) = (true) > >c  > }}
 Decreasing Measure x
 Decreasing Type {var_v20:Ty_list int a | true}
 Calculated Decreasing Predicate (slen)(x) > (slen)(var_v20)
 Calculated Decreased Goal Type  Arrow ( ( x1 : {var_v20:Ty_list int a | 
 	 Conj <c true
 	 , (slen)(x) > (slen)(var_v20) >c } ) ->  Arrow ( ( y : {var_v21:Ty_list int a | true} ) -> {v:Ty_list int pair | Forall 
 	 
 Key =u Value = Ty_list int a
 Key =w Value = int a
 Key =z Value = int a{ 
 	 Impl < (sndlist)( , v, u ) = (true)
 	 
 	 Conj <c 
 	 Impl < (mem)( , w, u ) = (true)
 	 (mem)( , w, y ) = (true) >
 	 , 
 	 Impl < (ord)( , w, z, u ) = (true)
 	 (ord)( , z, w, y ) = (true) > >c  > }}
 Show Trying :: Top-level Match
 Show :: Synthesize Match {v:Ty_list int pair | Forall 
 	 
 Key =u Value = Ty_list int a
 Key =w Value = int a
 Key =z Value = int a{ 
 	 Impl < (sndlist)( , v, u ) = (true)
 	 
 	 Conj <c 
 	 Impl < (mem)( , w, u ) = (true)
 	 (mem)( , w, y ) = (true) >
 	 , 
 	 Impl < (ord)( , w, z, u ) = (true)
 	 (ord)( , z, w, y ) = (true) > >c  > }}
 Show :: List Ty_list int a
 Show LIST CASE ??Ty_list int a PHI trueNil Length (slen)(x) =={(0)}
 Show Predicate Cons branch :: 
 	 Conj <c (slen)(x) ==((slen)(var_xs23) + {(1)})
 	 , (slen)(x) > {(0)} >c 
 Show Predicate Nil branch :: (slen)(x) =={(0)}
 Show ***********Calling Scalar synthesize***************
 esynthesizeScalar for {v:Ty_list int pair | Forall 
 	 
 Key =u Value = Ty_list int a
 Key =w Value = int a
 Key =z Value = int a{ 
 	 Impl < (sndlist)( , v, u ) = (true)
 	 
 	 Conj <c 
 	 Impl < (mem)( , w, u ) = (true)
 	 (mem)( , w, y ) = (true) >
 	 , 
 	 Impl < (ord)( , w, z, u ) = (true)
 	 (ord)( , z, w, y ) = (true) > >c  > }}
  Entering Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  , 
 goal
 ############################################################
  Synthesizing the Function application Pure Component goal
  *************** Trying Arrow Component ************goal :  Arrow ( ( x1 : {var_v20:Ty_list int a | 
 	 Conj <c true
 	 , (slen)(x) > (slen)(var_v20) >c } ) ->  Arrow ( ( y : {var_v21:Ty_list int a | true} ) -> {v:Ty_list int pair | Forall 
 	 
 Key =u Value = Ty_list int a
 Key =w Value = int a
 Key =z Value = int a{ 
 	 Impl < (sndlist)( , v, u ) = (true)
 	 
 	 Conj <c 
 	 Impl < (mem)( , w, u ) = (true)
 	 (mem)( , w, y ) = (true) >
 	 , 
 	 Impl < (ord)( , w, z, u ) = (true)
 	 (ord)( , z, w, y ) = (true) > >c  > }}
  *************** Synthesizing Args ei : ti for ************goal
 ##################################################################################
  Synthesizing the 1th argument for Function goal
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v20:Ty_list int a | 
 	 Conj <c true
 	 , (slen)(x) > (slen)(var_v20) >c }
 
 Enumerating a Scalar Term x
 
 Type of the Scalar Term {var_v20:Ty_list int a | true}
 ################################################
 Skipping Variable x as it is bound variable for Cons constructor
 ################################################
 
 Enumerating a Scalar Term y
 
 Type of the Scalar Term {var_v21:Ty_list int a | true}
  EXPLORED Args.parser output 
 EXPLORED learningOn  true
 EXPLORED bidirectionality  true
 EXPLORED effect-filter  false
 EXPLORED specfile :: ./prudent_tests/hegel/Hoogle+/appendN.spec
 EXPLORED goal Number :: 0
 EXPLORED Max path length :: 2
 EXPLORED Nested If :: 1typewhitespace var: ipair
semicolon
typewhitespace var: plist
semicolon
stexcwhitespace var: llen
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: pllen
whitespace colon
whitespace lbrace
var: ipair
rbrace
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: lmem
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: int
whitespace colon
whitespace var: bool
semicolon
stexcwhitespace var: lhd
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: plhd
whitespace colon
whitespace lbrace
var: ipair
rbrace
whitespace colon
whitespace var: ipair
semicolon
stexcwhitespace var: last
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: pllast
whitespace colon
whitespace lbrace
var: ipair
rbrace
whitespace colon
whitespace var: ipair
semicolon
stexcwhitespace var: ppr1
whitespace colon
whitespace var: ipair
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: ppr2
whitespace colon
whitespace var: ipair
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: nth
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: int
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: lsnd
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: pen
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: fst
whitespace colon
whitespace var: plist
whitespace colon
whitespace lbrace
var: int
rbrace
semicolon
stexcwhitespace var: snd
whitespace colon
whitespace var: plist
whitespace colon
whitespace lbrace
var: int
rbrace
semicolon
var: ep
whitespace colon
whitespace var: int
semicolon
var: length
whitespace colon
whitespace lparen
var: x
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace var: llen
whitespace lparen
var: x
rparen
whitespace equalopwhitespace var: v
rcurly
semicolon
whitespace var: rev
whitespace colon
whitespace lparen
var: l
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace pipe
whitespace whitespace var: llen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: llen
whitespace lparen
var: l
rparen
whitespace conjwhitespace var: lhd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: last
whitespace lparen
var: l
rparen
whitespace conjwhitespace var: last
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: lhd
whitespace lparen
var: l
rparen
whitespace conjwhitespace var: lsnd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: pen
whitespace lparen
var: l
rparen
whitespace conjwhitespace var: pen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: lsnd
whitespace lparen
var: v
rparen
whitespace rcurly
semicolon
var: compare_lengths
whitespace colon
whitespace lparen
var: x
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lparen
var: y
colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace var: bool
whitespace pipe
whitespace lbrace
var: v
equaloptruerbrace
whitespace iffwhitespace lparen
var: llen
whitespace lparen
var: x
rparen
whitespace equalopwhitespace var: llen
whitespace lparen
var: y
rparen
rparen
rcurly
semicolon
var: cons
whitespace colon
whitespace lparen
var: x
whitespace colon
whitespace var: int
rparen
whitespace arrow
whitespace lparen
var: xs
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace pipe
whitespace var: llen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: llen
whitespace lparen
var: xs
rparen
whitespace pluswhitespace int: 1
whitespace conjwhitespace var: lmem
whitespace lparen
var: v
comma
whitespace var: x
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace var: lhd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: x
whitespace conjwhitespace var: lsnd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: lhd
whitespace lparen
var: xs
rparen
whitespace conjwhitespace var: last
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: last
whitespace lparen
var: xs
rparen
whitespace conjwhitespace var: pen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: pen
whitespace lparen
var: xs
rparen
whitespace rcurly
semicolon
var: hd
whitespace colon
whitespace lparen
var: l
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace var: lmem
whitespace lparen
var: l
comma
whitespace var: v
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace var: lhd
whitespace lparen
var: l
rparen
whitespace equalopwhitespace var: v
whitespace whitespace rcurly
semicolon
var: tl
whitespace colon
whitespace lparen
var: l
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace pipe
whitespace var: llen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: llen
whitespace lparen
var: l
rparen
whitespace ar-minuswhitespace int: 1
whitespace conjwhitespace var: last
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: last
whitespace lparen
var: l
rparen
whitespace conjwhitespace var: lhd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: lsnd
whitespace lparen
var: l
rparen
whitespace conjwhitespace var: pen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: pen
whitespace lparen
var: l
rparen
whitespace rcurly
semicolon
var: nth
whitespace colon
whitespace lparen
var: l
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lparen
var: n
whitespace colon
whitespace var: int
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace var: lmem
whitespace lparen
var: l
comma
whitespace var: v
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace var: nth
whitespace lparen
var: l
comma
whitespace var: n
rparen
whitespace equalopwhitespace var: v
whitespace whitespace rcurly
semicolon
var: append
whitespace colon
whitespace lparen
var: l1
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lparen
var: l2
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace pipe
whitespace whitespace var: llen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: llen
whitespace lparen
var: l1
rparen
whitespace pluswhitespace var: llen
whitespace lparen
var: l2
rparen
whitespace conjwhitespace var: lhd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: lhd
whitespace lparen
var: l1
rparen
whitespace conjwhitespace var: lsnd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: lsnd
whitespace lparen
var: l1
rparen
whitespace conjwhitespace var: last
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: last
whitespace lparen
var: l2
rparen
whitespace conjwhitespace var: pen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: pen
whitespace lparen
var: l2
rparen
whitespace rcurly
semicolon
var: combine
whitespace colon
whitespace lparen
var: l1
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lparen
var: l2
whitespace colon
whitespace lcurly
var: v
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace pipe
whitespace var: llen
whitespace lparen
var: l1
rparen
whitespace equalopwhitespace var: llen
whitespace lparen
var: l2
rparen
rcurly
rparen
whitespace arrow
whitespace whitespace lcurly
var: v
whitespace colon
whitespace lbrace
var: ipair
rbrace
whitespace pipe
whitespace lambdalparen
var: H
whitespace colon
whitespace var: ipair
rparen
comma
whitespace lparen
var: L
whitespace colon
whitespace var: ipair
rparen
dotwhitespace var: pllen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: pllen
whitespace lparen
var: l1
rparen
whitespace conjwhitespace var: plhd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: H
whitespace conjwhitespace var: pllast
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: L
whitespace conjwhitespace var: ppr1
whitespace lparen
var: H
rparen
whitespace equalopwhitespace var: lhd
whitespace lparen
var: l1
rparen
whitespace conjwhitespace var: ppr2
whitespace lparen
var: H
rparen
whitespace equalopwhitespace var: lhd
whitespace lparen
var: l2
rparen
whitespace conjwhitespace var: ppr1
whitespace lparen
var: L
rparen
whitespace equalopwhitespace var: last
whitespace lparen
var: l1
rparen
whitespace conjwhitespace var: ppr2
whitespace lparen
var: L
rparen
whitespace equalopwhitespace var: last
whitespace lparen
var: l2
rparen
whitespace whitespace rcurly
semicolon
var: splitAt
whitespace colon
whitespace lparen
var: y
colon
var: int
rparen
whitespace arrow
whitespace lparen
var: l
whitespace colon
whitespace lcurly
whitespace var: v
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace pipe
whitespace var: llen
whitespace lparen
var: v
rparen
whitespace lessthanopwhitespace var: y
rcurly
rparen
whitespace arrow
whitespace whitespace lcurly
var: v
colon
var: plist
whitespace pipe
whitespace lambdalparen
var: H
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
comma
whitespace lparen
var: L
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
dotwhitespace lparen
var: fst
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: H
whitespace conjwhitespace var: snd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: L
rparen
whitespace implieswhitespace whitespace var: llen
whitespace lparen
var: H
rparen
whitespace equalopwhitespace var: y
whitespace conjwhitespace var: llen
whitespace lparen
var: L
rparen
whitespace equalopwhitespace var: llen
whitespace lparen
var: l
rparen
whitespace ar-minuswhitespace var: y
whitespace whitespace rcurly
semicolon
var: null
whitespace colon
whitespace lparen
var: l
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace var: bool
whitespace pipe
whitespace lbrace
var: v
equaloptruerbrace
whitespace iffwhitespace var: llen
whitespace lparen
var: l
rparen
whitespace equalopwhitespace int: 0
rcurly
semicolon
var: last
whitespace colon
whitespace lparen
var: l
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace var: last
whitespace lparen
var: l
rparen
whitespace equalopwhitespace var: v
rcurly
semicolon
whitespace var: init
whitespace colon
whitespace lparen
var: l
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace pipe
whitespace var: llen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: llen
whitespace lparen
var: v
rparen
whitespace ar-minusint: 1
rcurly
semicolon
whitespace var: take
whitespace colon
whitespace lparen
var: n
whitespace colon
whitespace var: int
rparen
whitespace arrow
whitespace lparen
var: l
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace pipe
whitespace lambdalparen
var: u
whitespace colon
whitespace var: int
rparen
dotwhitespace whitespace var: llen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: n
whitespace conjwhitespace whitespace lparen
var: lmem
whitespace lparen
var: v
comma
whitespace var: u
rparen
whitespace equalopwhitespace truerparen
whitespace implieswhitespace var: lmem
whitespace lparen
var: l
comma
whitespace var: u
rparen
whitespace equalopwhitespace truercurly
semicolon
whitespace var: goal
whitespace colon
whitespace lparen
var: x
whitespace colon
whitespace var: int
rparen
whitespace arrow
whitespace lparen
var: xs
whitespace colon
whitespace lbrace
var: a
rbrace
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace lbrace
var: a
rbrace
whitespace pipe
whitespace lambdalparen
var: u
whitespace colon
whitespace var: a
rparen
dotwhitespace var: mem
whitespace lparen
var: u
comma
whitespace var: xs
rparen
whitespace equalopwhitespace truewhitespace implieswhitespace var: mem
whitespace lparen
var: u
comma
whitespace var: v
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace var: count
whitespace lparen
var: u
comma
whitespace var: v
rparen
whitespace equalopwhitespace var: size
whitespace lparen
var: v
rparen
whitespace equalop
  EXPLORED Args.parser output 
 EXPLORED learningOn  true
 EXPLORED bidirectionality  true
 EXPLORED effect-filter  false
 EXPLORED specfile :: ./prudent_tests/hegel/Hoogle+/lookUpRange.spec
 EXPLORED goal Number :: 0
 EXPLORED Max path length :: 2
 EXPLORED Nested If :: 1typewhitespace var: ipair
semicolon
typewhitespace var: plist
semicolon
stexcwhitespace var: llen
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: pllen
whitespace colon
whitespace lbrace
var: ipair
rbrace
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: lmem
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: int
whitespace colon
whitespace var: bool
semicolon
stexcwhitespace var: lhd
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: plhd
whitespace colon
whitespace lbrace
var: ipair
rbrace
whitespace colon
whitespace var: ipair
semicolon
stexcwhitespace var: last
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: pllast
whitespace colon
whitespace lbrace
var: ipair
rbrace
whitespace colon
whitespace var: ipair
semicolon
stexcwhitespace var: ppr1
whitespace colon
whitespace var: ipair
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: ppr2
whitespace colon
whitespace var: ipair
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: nth
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: int
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: lsnd
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: pen
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: fst
whitespace colon
whitespace var: plist
whitespace colon
whitespace lbrace
var: int
rbrace
semicolon
stexcwhitespace var: snd
whitespace colon
whitespace var: plist
whitespace colon
whitespace lbrace
var: int
rbrace
semicolon
var: ep
whitespace colon
whitespace var: int
semicolon
var: length
whitespace colon
whitespace lparen
var: x
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace var: llen
whitespace lparen
var: x
rparen
whitespace equalopwhitespace var: v
rcurly
semicolon
whitespace var: rev
whitespace colon
whitespace lparen
var: l
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace pipe
whitespace whitespace var: llen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: llen
whitespace lparen
var: l
rparen
whitespace conjwhitespace var: lhd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: last
whitespace lparen
var: l
rparen
whitespace conjwhitespace var: last
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: lhd
whitespace lparen
var: l
rparen
whitespace conjwhitespace var: lsnd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: pen
whitespace lparen
var: l
rparen
whitespace conjwhitespace var: pen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: lsnd
whitespace lparen
var: v
rparen
whitespace rcurly
semicolon
var: compare_lengths
whitespace colon
whitespace lparen
var: x
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lparen
var: y
colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace var: bool
whitespace pipe
whitespace lbrace
var: v
equaloptruerbrace
whitespace iffwhitespace lparen
var: llen
whitespace lparen
var: x
rparen
whitespace equalopwhitespace var: llen
whitespace lparen
var: y
rparen
rparen
rcurly
semicolon
var: cons
whitespace colon
whitespace lparen
var: x
whitespace colon
whitespace var: int
rparen
whitespace arrow
whitespace lparen
var: xs
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace pipe
whitespace var: llen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: llen
whitespace lparen
var: xs
rparen
whitespace pluswhitespace int: 1
whitespace conjwhitespace var: lmem
whitespace lparen
var: v
comma
whitespace var: x
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace var: lhd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: x
whitespace conjwhitespace var: lsnd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: lhd
whitespace lparen
var: xs
rparen
whitespace conjwhitespace var: last
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: last
whitespace lparen
var: xs
rparen
whitespace conjwhitespace var: pen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: pen
whitespace lparen
var: xs
rparen
whitespace rcurly
semicolon
var: hd
whitespace colon
whitespace lparen
var: l
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace var: lmem
whitespace lparen
var: l
comma
whitespace var: v
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace var: lhd
whitespace lparen
var: l
rparen
whitespace equalopwhitespace var: v
whitespace whitespace rcurly
semicolon
var: tl
whitespace colon
whitespace lparen
var: l
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace pipe
whitespace var: llen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: llen
whitespace lparen
var: l
rparen
whitespace ar-minuswhitespace int: 1
whitespace conjwhitespace var: last
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: last
whitespace lparen
var: l
rparen
whitespace conjwhitespace var: lhd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: lsnd
whitespace lparen
var: l
rparen
whitespace conjwhitespace var: pen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: pen
whitespace lparen
var: l
rparen
whitespace rcurly
semicolon
var: nth
whitespace colon
whitespace lparen
var: l
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lparen
var: n
whitespace colon
whitespace var: int
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace var: lmem
whitespace lparen
var: l
comma
whitespace var: v
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace var: nth
whitespace lparen
var: l
comma
whitespace var: n
rparen
whitespace equalopwhitespace var: v
whitespace whitespace rcurly
semicolon
var: append
whitespace colon
whitespace lparen
var: l1
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lparen
var: l2
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace pipe
whitespace whitespace var: llen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: llen
whitespace lparen
var: l1
rparen
whitespace pluswhitespace var: llen
whitespace lparen
var: l2
rparen
whitespace conjwhitespace var: lhd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: lhd
whitespace lparen
var: l1
rparen
whitespace conjwhitespace var: lsnd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: lsnd
whitespace lparen
var: l1
rparen
whitespace conjwhitespace var: last
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: last
whitespace lparen
var: l2
rparen
whitespace conjwhitespace var: pen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: pen
whitespace lparen
var: l2
rparen
whitespace rcurly
semicolon
var: combine
whitespace colon
whitespace lparen
var: l1
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lparen
var: l2
whitespace colon
whitespace lcurly
var: v
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace pipe
whitespace var: llen
whitespace lparen
var: l1
rparen
whitespace equalopwhitespace var: llen
whitespace lparen
var: l2
rparen
rcurly
rparen
whitespace arrow
whitespace whitespace lcurly
var: v
whitespace colon
whitespace lbrace
var: ipair
rbrace
whitespace pipe
whitespace lambdalparen
var: H
whitespace colon
whitespace var: ipair
rparen
comma
whitespace lparen
var: L
whitespace colon
whitespace var: ipair
rparen
dotwhitespace var: pllen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: pllen
whitespace lparen
var: l1
rparen
whitespace conjwhitespace var: plhd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: H
whitespace conjwhitespace var: pllast
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: L
whitespace conjwhitespace var: ppr1
whitespace lparen
var: H
rparen
whitespace equalopwhitespace var: lhd
whitespace lparen
var: l1
rparen
whitespace conjwhitespace var: ppr2
whitespace lparen
var: H
rparen
whitespace equalopwhitespace var: lhd
whitespace lparen
var: l2
rparen
whitespace conjwhitespace var: ppr1
whitespace lparen
var: L
rparen
whitespace equalopwhitespace var: last
whitespace lparen
var: l1
rparen
whitespace conjwhitespace var: ppr2
whitespace lparen
var: L
rparen
whitespace equalopwhitespace var: last
whitespace lparen
var: l2
rparen
whitespace whitespace rcurly
semicolon
var: splitAt
whitespace colon
whitespace lparen
var: y
colon
var: int
rparen
whitespace arrow
whitespace lparen
var: l
whitespace colon
whitespace lcurly
whitespace var: v
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace pipe
whitespace var: llen
whitespace lparen
var: v
rparen
whitespace lessthanopwhitespace var: y
rcurly
rparen
whitespace arrow
whitespace whitespace lcurly
var: v
colon
var: plist
whitespace pipe
whitespace lambdalparen
var: H
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
comma
whitespace lparen
var: L
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
dotwhitespace lparen
var: fst
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: H
whitespace conjwhitespace var: snd
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: L
rparen
whitespace implieswhitespace whitespace var: llen
whitespace lparen
var: H
rparen
whitespace equalopwhitespace var: y
whitespace conjwhitespace var: llen
whitespace lparen
var: L
rparen
whitespace equalopwhitespace var: llen
whitespace lparen
var: l
rparen
whitespace ar-minuswhitespace var: y
whitespace whitespace rcurly
semicolon
var: null
whitespace colon
whitespace lparen
var: l
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace var: bool
whitespace pipe
whitespace lbrace
var: v
equaloptruerbrace
whitespace iffwhitespace var: llen
whitespace lparen
var: l
rparen
whitespace equalopwhitespace int: 0
rcurly
semicolon
var: last
whitespace colon
whitespace lparen
var: l
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace var: last
whitespace lparen
var: l
rparen
whitespace equalopwhitespace var: v
rcurly
semicolon
whitespace var: init
whitespace colon
whitespace lparen
var: l
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace pipe
whitespace var: llen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: llen
whitespace lparen
var: v
rparen
whitespace ar-minusint: 1
rcurly
semicolon
whitespace var: take
whitespace colon
whitespace lparen
var: n
whitespace colon
whitespace var: int
rparen
whitespace arrow
whitespace lparen
var: l
whitespace colon
whitespace lbrace
var: int
rbrace
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace lbrace
var: int
rbrace
whitespace pipe
whitespace lambdalparen
var: u
whitespace colon
whitespace var: int
rparen
dotwhitespace whitespace var: llen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: n
whitespace conjwhitespace whitespace lparen
var: lmem
whitespace lparen
var: v
comma
whitespace var: u
rparen
whitespace equalopwhitespace truerparen
whitespace implieswhitespace var: lmem
whitespace lparen
var: l
comma
whitespace var: u
rparen
whitespace equalopwhitespace truercurly
semicolon
whitespace var: goal
whitespace equalop



goal :: x:Int -> xs:List Int -> u:Int -> {Int|_v == u + 1 && sel xs x == u}
./synquid/test/hegel/nth.sq:53: Error:
  Cannot match shape 'Int'
  with shape '_'
  when checking goal ::
  X2:_ -> X1:_ -> X0:_ -> _ in
  \x . \xs . \u . 
        match goal ?? ?? ?? with





goal :: n:Int -> z:List a -> {List a|len _v > n}




goal :: el:a -> z:{List a|len _v >= 0} -> {List a|len _v > 3}




goal :: n:Int -> z:List a -> {List a|len _v == n - 1}
